        -:    0:Source:/home/kaappo/git/raytracercpp/lib/stb/std_image.h
        -:    0:Graph:/home/kaappo/git/raytracercpp/cmake-build-debug-coverage/CMakeFiles/Main.dir/src/core/engine/Image.cpp.gcno
        -:    0:Data:/home/kaappo/git/raytracercpp/cmake-build-debug-coverage/CMakeFiles/Main.dir/src/core/engine/Image.cpp.gcda
        -:    0:Runs:1
        -:    1:#pragma once
        -:    2:
        -:    3:/* stb_image - v2.27 - public domain image loader - http://nothings.org/stb
        -:    4:                                  no warranty implied; use at your own risk
        -:    5:
        -:    6:   Do this:
        -:    7:      #define STB_IMAGE_IMPLEMENTATION
        -:    8:   before you include this file in *one* C or C++ file to create the implementation.
        -:    9:
        -:   10:   // i.e. it should look like this:
        -:   11:   #include ...
        -:   12:   #include ...
        -:   13:   #include ...
        -:   14:   #define STB_IMAGE_IMPLEMENTATION
        -:   15:   #include "stb_image.h"
        -:   16:
        -:   17:   You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.
        -:   18:   And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free
        -:   19:
        -:   20:
        -:   21:   QUICK NOTES:
        -:   22:      Primarily of interest to game developers and other people who can
        -:   23:          avoid problematic images and only need the trivial interface
        -:   24:
        -:   25:      JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
        -:   26:      PNG 1/2/4/8/16-bit-per-channel
        -:   27:
        -:   28:      TGA (not sure what subset, if a subset)
        -:   29:      BMP non-1bpp, non-RLE
        -:   30:      PSD (composited view only, no extra channels, 8/16 bit-per-channel)
        -:   31:
        -:   32:      GIF (*comp always reports as 4-channel)
        -:   33:      HDR (radiance rgbE format)
        -:   34:      PIC (Softimage PIC)
        -:   35:      PNM (PPM and PGM binary only)
        -:   36:
        -:   37:      Animated GIF still needs a proper API, but here's one way to do it:
        -:   38:          http://gist.github.com/urraka/685d9a6340b26b830d49
        -:   39:
        -:   40:      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)
        -:   41:      - decode from arbitrary I/O callbacks
        -:   42:      - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)
        -:   43:
        -:   44:   Full documentation under "DOCUMENTATION" below.
        -:   45:
        -:   46:
        -:   47:LICENSE
        -:   48:
        -:   49:  See end of file for license information.
        -:   50:
        -:   51:RECENT REVISION HISTORY:
        -:   52:
        -:   53:      2.27  (2021-07-11) document stbi_info better, 16-bit PNM support, bug fixes
        -:   54:      2.26  (2020-07-13) many minor fixes
        -:   55:      2.25  (2020-02-02) fix warnings
        -:   56:      2.24  (2020-02-02) fix warnings; thread-local failure_reason and flip_vertically
        -:   57:      2.23  (2019-08-11) fix clang static analysis warning
        -:   58:      2.22  (2019-03-04) gif fixes, fix warnings
        -:   59:      2.21  (2019-02-25) fix typo in comment
        -:   60:      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
        -:   61:      2.19  (2018-02-11) fix warning
        -:   62:      2.18  (2018-01-30) fix warnings
        -:   63:      2.17  (2018-01-29) bugfix, 1-bit BMP, 16-bitness query, fix warnings
        -:   64:      2.16  (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes
        -:   65:      2.15  (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC
        -:   66:      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
        -:   67:      2.13  (2016-12-04) experimental 16-bit API, only for PNG so far; fixes
        -:   68:      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
        -:   69:      2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64
        -:   70:                         RGB-format JPEG; remove white matting in PSD;
        -:   71:                         allocate large structures on the stack;
        -:   72:                         correct channel count for PNG & BMP
        -:   73:      2.10  (2016-01-22) avoid warning introduced in 2.09
        -:   74:      2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED
        -:   75:
        -:   76:   See end of file for full revision history.
        -:   77:
        -:   78:
        -:   79: ============================    Contributors    =========================
        -:   80:
        -:   81: Image formats                          Extensions, features
        -:   82:    Sean Barrett (jpeg, png, bmp)          Jetro Lauha (stbi_info)
        -:   83:    Nicolas Schulz (hdr, psd)              Martin "SpartanJ" Golini (stbi_info)
        -:   84:    Jonathan Dummer (tga)                  James "moose2000" Brown (iPhone PNG)
        -:   85:    Jean-Marc Lienher (gif)                Ben "Disch" Wenger (io callbacks)
        -:   86:    Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)
        -:   87:    Thatcher Ulrich (psd)                  Nicolas Guillemot (vertical flip)
        -:   88:    Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)
        -:   89:    github:urraka (animated gif)           Junggon Kim (PNM comments)
        -:   90:    Christopher Forseth (animated gif)     Daniel Gibson (16-bit TGA)
        -:   91:                                           socks-the-fox (16-bit PNG)
        -:   92:                                           Jeremy Sawicki (handle all ImageNet JPGs)
        -:   93: Optimizations & bugfixes                  Mikhail Morozov (1-bit BMP)
        -:   94:    Fabian "ryg" Giesen                    Anael Seghezzi (is-16-bit query)
        -:   95:    Arseny Kapoulkine                      Simon Breuss (16-bit PNM)
        -:   96:    John-Mark Allen
        -:   97:    Carmelo J Fdez-Aguera
        -:   98:
        -:   99: Bug & warning fixes
        -:  100:    Marc LeBlanc            David Woo          Guillaume George     Martins Mozeiko
        -:  101:    Christpher Lloyd        Jerry Jansson      Joseph Thomson       Blazej Dariusz Roszkowski
        -:  102:    Phil Jordan                                Dave Moore           Roy Eltham
        -:  103:    Hayaki Saito            Nathan Reed        Won Chun
        -:  104:    Luke Graham             Johan Duparc       Nick Verigakis       the Horde3D community
        -:  105:    Thomas Ruf              Ronny Chevalier                         github:rlyeh
        -:  106:    Janez Zemva             John Bartholomew   Michal Cichon        github:romigrou
        -:  107:    Jonathan Blow           Ken Hamada         Tero Hanninen        github:svdijk
        -:  108:    Eugene Golushkov        Laurent Gomila     Cort Stratton        github:snagar
        -:  109:    Aruelien Pocheville     Sergio Gonzalez    Thibault Reuille     github:Zelex
        -:  110:    Cass Everitt            Ryamond Barbiero                        github:grim210
        -:  111:    Paul Du Bois            Engin Manap        Aldo Culquicondor    github:sammyhw
        -:  112:    Philipp Wiesemann       Dale Weiler        Oriol Ferrer Mesia   github:phprus
        -:  113:    Josh Tobin                                 Matthew Gregan       github:poppolopoppo
        -:  114:    Julian Raschke          Gregory Mullen     Christian Floisand   github:darealshinji
        -:  115:    Baldur Karlsson         Kevin Schmidt      JR Smith             github:Michaelangel007
        -:  116:                            Brad Weinberger    Matvey Cherevko      github:mosra
        -:  117:    Luca Sas                Alexander Veselov  Zack Middleton       [reserved]
        -:  118:    Ryan C. Gordon          [reserved]                              [reserved]
        -:  119:                     DO NOT ADD YOUR NAME HERE
        -:  120:
        -:  121:                     Jacko Dirks
        -:  122:
        -:  123:  To add your name to the credits, pick a random blank space in the middle and fill it.
        -:  124:  80% of merge conflicts on stb PRs are due to people adding their name at the end
        -:  125:  of the credits.
        -:  126:*/
        -:  127:
        -:  128:#ifndef STBI_INCLUDE_STB_IMAGE_H
        -:  129:#define STBI_INCLUDE_STB_IMAGE_H
        -:  130:
        -:  131:// DOCUMENTATION
        -:  132://
        -:  133:// Limitations:
        -:  134://    - no 12-bit-per-channel JPEG
        -:  135://    - no JPEGs with arithmetic coding
        -:  136://    - GIF always returns *comp=4
        -:  137://
        -:  138:// Basic usage (see HDR discussion below for HDR usage):
        -:  139://    int x,y,n;
        -:  140://    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
        -:  141://    // ... process data if not NULL ...
        -:  142://    // ... x = width, y = height, n = # 8-bit components per pixel ...
        -:  143://    // ... replace '0' with '1'..'4' to force that many components per pixel
        -:  144://    // ... but 'n' will always be the number that it would have been if you said 0
        -:  145://    stbi_image_free(data)
        -:  146://
        -:  147:// Standard parameters:
        -:  148://    int *x                 -- outputs image width in pixels
        -:  149://    int *y                 -- outputs image height in pixels
        -:  150://    int *channels_in_file  -- outputs # of image components in image file
        -:  151://    int desired_channels   -- if non-zero, # of image components requested in result
        -:  152://
        -:  153:// The return value from an image loader is an 'unsigned char *' which points
        -:  154:// to the pixel data, or NULL on an allocation failure or if the image is
        -:  155:// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,
        -:  156:// with each pixel consisting of N interleaved 8-bit components; the first
        -:  157:// pixel pointed to is top-left-most in the image. There is no padding between
        -:  158:// image scanlines or between pixels, regardless of format. The number of
        -:  159:// components N is 'desired_channels' if desired_channels is non-zero, or
        -:  160:// *channels_in_file otherwise. If desired_channels is non-zero,
        -:  161:// *channels_in_file has the number of components that _would_ have been
        -:  162:// output otherwise. E.g. if you set desired_channels to 4, you will always
        -:  163:// get RGBA output, but you can check *channels_in_file to see if it's trivially
        -:  164:// opaque because e.g. there were only 3 channels in the source image.
        -:  165://
        -:  166:// An output image with N components has the following components interleaved
        -:  167:// in this order in each pixel:
        -:  168://
        -:  169://     N=#comp     components
        -:  170://       1           grey
        -:  171://       2           grey, alpha
        -:  172://       3           red, green, blue
        -:  173://       4           red, green, blue, alpha
        -:  174://
        -:  175:// If image loading fails for any reason, the return value will be NULL,
        -:  176:// and *x, *y, *channels_in_file will be unchanged. The function
        -:  177:// stbi_failure_reason() can be queried for an extremely brief, end-user
        -:  178:// unfriendly explanation of why the load failed. Define STBI_NO_FAILURE_STRINGS
        -:  179:// to avoid compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
        -:  180:// more user-friendly ones.
        -:  181://
        -:  182:// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
        -:  183://
        -:  184:// To query the width, height and component count of an image without having to
        -:  185:// decode the full file, you can use the stbi_info family of functions:
        -:  186://
        -:  187://   int x,y,n,ok;
        -:  188://   ok = stbi_info(filename, &x, &y, &n);
        -:  189://   // returns ok=1 and sets x, y, n if image is a supported format,
        -:  190://   // 0 otherwise.
        -:  191://
        -:  192:// Note that stb_image pervasively uses ints in its public API for sizes,
        -:  193:// including sizes of memory buffers. This is now part of the API and thus
        -:  194:// hard to change without causing breakage. As a result, the various image
        -:  195:// loaders all have certain limits on image size; these differ somewhat
        -:  196:// by format but generally boil down to either just under 2GB or just under
        -:  197:// 1GB. When the decoded image would be larger than this, stb_image decoding
        -:  198:// will fail.
        -:  199://
        -:  200:// Additionally, stb_image will reject image files that have any of their
        -:  201:// dimensions set to a larger value than the configurable STBI_MAX_DIMENSIONS,
        -:  202:// which defaults to 2**24 = 16777216 pixels. Due to the above memory limit,
        -:  203:// the only way to have an image with such dimensions load correctly
        -:  204:// is for it to have a rather extreme aspect ratio. Either way, the
        -:  205:// assumption here is that such larger images are likely to be malformed
        -:  206:// or malicious. If you do need to load an image with individual dimensions
        -:  207:// larger than that, and it still fits in the overall size limit, you can
        -:  208:// #define STBI_MAX_DIMENSIONS on your own to be something larger.
        -:  209://
        -:  210:// ===========================================================================
        -:  211://
        -:  212:// UNICODE:
        -:  213://
        -:  214://   If compiling for Windows and you wish to use Unicode filenames, compile
        -:  215://   with
        -:  216://       #define STBI_WINDOWS_UTF8
        -:  217://   and pass utf8-encoded filenames. Call stbi_convert_wchar_to_utf8 to convert
        -:  218://   Windows wchar_t filenames to utf8.
        -:  219://
        -:  220:// ===========================================================================
        -:  221://
        -:  222:// Philosophy
        -:  223://
        -:  224:// stb libraries are designed with the following priorities:
        -:  225://
        -:  226://    1. easy to use
        -:  227://    2. easy to maintain
        -:  228://    3. good performance
        -:  229://
        -:  230:// Sometimes I let "good performance" creep up in priority over "easy to maintain",
        -:  231:// and for best performance I may provide less-easy-to-use APIs that give higher
        -:  232:// performance, in addition to the easy-to-use ones. Nevertheless, it's important
        -:  233:// to keep in mind that from the standpoint of you, a client of this library,
        -:  234:// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.
        -:  235://
        -:  236:// Some secondary priorities arise directly from the first two, some of which
        -:  237:// provide more explicit reasons why performance can't be emphasized.
        -:  238://
        -:  239://    - Portable ("ease of use")
        -:  240://    - Small source code footprint ("easy to maintain")
        -:  241://    - No dependencies ("ease of use")
        -:  242://
        -:  243:// ===========================================================================
        -:  244://
        -:  245:// I/O callbacks
        -:  246://
        -:  247:// I/O callbacks allow you to read from arbitrary sources, like packaged
        -:  248:// files or some other source. Data read from callbacks are processed
        -:  249:// through a small internal buffer (currently 128 bytes) to try to reduce
        -:  250:// overhead.
        -:  251://
        -:  252:// The three functions you must define are "read" (reads some bytes of data),
        -:  253:// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).
        -:  254://
        -:  255:// ===========================================================================
        -:  256://
        -:  257:// SIMD support
        -:  258://
        -:  259:// The JPEG decoder will try to automatically use SIMD kernels on x86 when
        -:  260:// supported by the compiler. For ARM Neon support, you must explicitly
        -:  261:// request it.
        -:  262://
        -:  263:// (The old do-it-yourself SIMD API is no longer supported in the current
        -:  264:// code.)
        -:  265://
        -:  266:// On x86, SSE2 will automatically be used when available based on a run-time
        -:  267:// test; if not, the generic C versions are used as a fall-back. On ARM targets,
        -:  268:// the typical path is to have separate builds for NEON and non-NEON devices
        -:  269:// (at least this is true for iOS and Android). Therefore, the NEON support is
        -:  270:// toggled by a build flag: define STBI_NEON to get NEON loops.
        -:  271://
        -:  272:// If for some reason you do not want to use any of SIMD code, or if
        -:  273:// you have issues compiling it, you can disable it entirely by
        -:  274:// defining STBI_NO_SIMD.
        -:  275://
        -:  276:// ===========================================================================
        -:  277://
        -:  278:// HDR image support   (disable by defining STBI_NO_HDR)
        -:  279://
        -:  280:// stb_image supports loading HDR images in general, and currently the Radiance
        -:  281:// .HDR file format specifically. You can still load any file through the existing
        -:  282:// interface; if you attempt to load an HDR file, it will be automatically remapped
        -:  283:// to LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
        -:  284:// both of these constants can be reconfigured through this interface:
        -:  285://
        -:  286://     stbi_hdr_to_ldr_gamma(2.2f);
        -:  287://     stbi_hdr_to_ldr_scale(1.0f);
        -:  288://
        -:  289:// (note, do not use _inverse_ constants; stbi_image will invert them
        -:  290:// appropriately).
        -:  291://
        -:  292:// Additionally, there is a new, parallel interface for loading files as
        -:  293:// (linear) floats to preserve the full dynamic range:
        -:  294://
        -:  295://    float *data = stbi_loadf(filename, &x, &y, &n, 0);
        -:  296://
        -:  297:// If you load LDR images through this interface, those images will
        -:  298:// be promoted to floating point values, run through the inverse of
        -:  299:// constants corresponding to the above:
        -:  300://
        -:  301://     stbi_ldr_to_hdr_scale(1.0f);
        -:  302://     stbi_ldr_to_hdr_gamma(2.2f);
        -:  303://
        -:  304:// Finally, given a filename (or an open file or memory block--see header
        -:  305:// file for details) containing image data, you can query for the "most
        -:  306:// appropriate" interface to use (that is, whether the image is HDR or
        -:  307:// not), using:
        -:  308://
        -:  309://     stbi_is_hdr(char *filename);
        -:  310://
        -:  311:// ===========================================================================
        -:  312://
        -:  313:// iPhone PNG support:
        -:  314://
        -:  315:// We optionally support converting iPhone-formatted PNGs (which store
        -:  316:// premultiplied BGRA) back to RGB, even though they're internally encoded
        -:  317:// differently. To enable this conversion, call
        -:  318:// stbi_convert_iphone_png_to_rgb(1).
        -:  319://
        -:  320:// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
        -:  321:// pixel to remove any premultiplied alpha *only* if the image file explicitly
        -:  322:// says there's premultiplied data (currently only happens in iPhone images,
        -:  323:// and only if iPhone convert-to-rgb processing is on).
        -:  324://
        -:  325:// ===========================================================================
        -:  326://
        -:  327:// ADDITIONAL CONFIGURATION
        -:  328://
        -:  329://  - You can suppress implementation of any of the decoders to reduce
        -:  330://    your code footprint by #defining one or more of the following
        -:  331://    symbols before creating the implementation.
        -:  332://
        -:  333://        STBI_NO_JPEG
        -:  334://        STBI_NO_PNG
        -:  335://        STBI_NO_BMP
        -:  336://        STBI_NO_PSD
        -:  337://        STBI_NO_TGA
        -:  338://        STBI_NO_GIF
        -:  339://        STBI_NO_HDR
        -:  340://        STBI_NO_PIC
        -:  341://        STBI_NO_PNM   (.ppm and .pgm)
        -:  342://
        -:  343://  - You can request *only* certain decoders and suppress all other ones
        -:  344://    (this will be more forward-compatible, as addition of new decoders
        -:  345://    doesn't require you to disable them explicitly):
        -:  346://
        -:  347://        STBI_ONLY_JPEG
        -:  348://        STBI_ONLY_PNG
        -:  349://        STBI_ONLY_BMP
        -:  350://        STBI_ONLY_PSD
        -:  351://        STBI_ONLY_TGA
        -:  352://        STBI_ONLY_GIF
        -:  353://        STBI_ONLY_HDR
        -:  354://        STBI_ONLY_PIC
        -:  355://        STBI_ONLY_PNM   (.ppm and .pgm)
        -:  356://
        -:  357://   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still
        -:  358://     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB
        -:  359://
        -:  360://  - If you define STBI_MAX_DIMENSIONS, stb_image will reject images greater
        -:  361://    than that size (in either width or height) without further processing.
        -:  362://    This is to let programs in the wild set an upper bound to prevent
        -:  363://    denial-of-service attacks on untrusted data, as one could generate a
        -:  364://    valid image of gigantic dimensions and force stb_image to allocate a
        -:  365://    huge block of memory and spend disproportionate time decoding it. By
        -:  366://    default this is set to (1 << 24), which is 16777216, but that's still
        -:  367://    very big.
        -:  368:
        -:  369:#ifndef STBI_NO_STDIO
        -:  370:#include <stdio.h>
        -:  371:#endif // STBI_NO_STDIO
        -:  372:
        -:  373:#define STBI_VERSION 1
        -:  374:
        -:  375:enum
        -:  376:{
        -:  377:    STBI_default = 0, // only used for desired_channels
        -:  378:
        -:  379:    STBI_grey       = 1,
        -:  380:    STBI_grey_alpha = 2,
        -:  381:    STBI_rgb        = 3,
        -:  382:    STBI_rgb_alpha  = 4
        -:  383:};
        -:  384:
        -:  385:#include <stdlib.h>
        -:  386:typedef unsigned char stbi_uc;
        -:  387:typedef unsigned short stbi_us;
        -:  388:
        -:  389:#ifdef __cplusplus
        -:  390:extern "C" {
        -:  391:#endif
        -:  392:
        -:  393:#ifndef STBIDEF
        -:  394:#ifdef STB_IMAGE_STATIC
        -:  395:#define STBIDEF static
        -:  396:#else
        -:  397:#define STBIDEF extern
        -:  398:#endif
        -:  399:#endif
        -:  400:
        -:  401://////////////////////////////////////////////////////////////////////////////
        -:  402://
        -:  403:// PRIMARY API - works on images of any type
        -:  404://
        -:  405:
        -:  406://
        -:  407:// load image by filename, open file, or memory buffer
        -:  408://
        -:  409:
        -:  410:typedef struct
        -:  411:{
        -:  412:    int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
        -:  413:    void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative
        -:  414:    int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data
        -:  415:} stbi_io_callbacks;
        -:  416:
        -:  417:////////////////////////////////////
        -:  418://
        -:  419:// 8-bits-per-channel interface
        -:  420://
        -:  421:
        -:  422:STBIDEF stbi_uc *stbi_load_from_memory   (stbi_uc           const *buffer, int len   , int *x, int *y, int *channels_in_file, int desired_channels);
        -:  423:STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk  , void *user, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  424:
        -:  425:#ifndef STBI_NO_STDIO
        -:  426:STBIDEF stbi_uc *stbi_load            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  427:STBIDEF stbi_uc *stbi_load_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  428:// for stbi_load_from_file, file pointer is left pointing immediately after image
        -:  429:#endif
        -:  430:
        -:  431:#ifndef STBI_NO_GIF
        -:  432:STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
        -:  433:#endif
        -:  434:
        -:  435:#ifdef STBI_WINDOWS_UTF8
        -:  436:STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input);
        -:  437:#endif
        -:  438:
        -:  439:////////////////////////////////////
        -:  440://
        -:  441:// 16-bits-per-channel interface
        -:  442://
        -:  443:
        -:  444:STBIDEF stbi_us *stbi_load_16_from_memory   (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  445:STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  446:
        -:  447:#ifndef STBI_NO_STDIO
        -:  448:STBIDEF stbi_us *stbi_load_16          (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  449:STBIDEF stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  450:#endif
        -:  451:
        -:  452:////////////////////////////////////
        -:  453://
        -:  454:// float-per-channel interface
        -:  455://
        -:  456:#ifndef STBI_NO_LINEAR
        -:  457:STBIDEF float *stbi_loadf_from_memory     (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  458:STBIDEF float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y,  int *channels_in_file, int desired_channels);
        -:  459:
        -:  460:#ifndef STBI_NO_STDIO
        -:  461:STBIDEF float *stbi_loadf            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  462:STBIDEF float *stbi_loadf_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
        -:  463:#endif
        -:  464:#endif
        -:  465:
        -:  466:#ifndef STBI_NO_HDR
        -:  467:STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);
        -:  468:STBIDEF void   stbi_hdr_to_ldr_scale(float scale);
        -:  469:#endif // STBI_NO_HDR
        -:  470:
        -:  471:#ifndef STBI_NO_LINEAR
        -:  472:STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);
        -:  473:STBIDEF void   stbi_ldr_to_hdr_scale(float scale);
        -:  474:#endif // STBI_NO_LINEAR
        -:  475:
        -:  476:// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR
        -:  477:STBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
        -:  478:STBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
        -:  479:#ifndef STBI_NO_STDIO
        -:  480:STBIDEF int      stbi_is_hdr          (char const *filename);
        -:  481:STBIDEF int      stbi_is_hdr_from_file(FILE *f);
        -:  482:#endif // STBI_NO_STDIO
        -:  483:
        -:  484:
        -:  485:// get a VERY brief reason for failure
        -:  486:// on most compilers (and ALL modern mainstream compilers) this is threadsafe
        -:  487:STBIDEF const char *stbi_failure_reason  (void);
        -:  488:
        -:  489:// free the loaded image -- this is just free()
        -:  490:STBIDEF void     stbi_image_free      (void *retval_from_stbi_load);
        -:  491:
        -:  492:// get image dimensions & components without fully decoding
        -:  493:STBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
        -:  494:STBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);
        -:  495:STBIDEF int      stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len);
        -:  496:STBIDEF int      stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *clbk, void *user);
        -:  497:
        -:  498:#ifndef STBI_NO_STDIO
        -:  499:STBIDEF int      stbi_info               (char const *filename,     int *x, int *y, int *comp);
        -:  500:STBIDEF int      stbi_info_from_file     (FILE *f,                  int *x, int *y, int *comp);
        -:  501:STBIDEF int      stbi_is_16_bit          (char const *filename);
        -:  502:STBIDEF int      stbi_is_16_bit_from_file(FILE *f);
        -:  503:#endif
        -:  504:
        -:  505:
        -:  506:
        -:  507:// for image formats that explicitly notate that they have premultiplied alpha,
        -:  508:// we just return the colors as stored in the file. set this flag to force
        -:  509:// unpremultiplication. results are undefined if the unpremultiply overflow.
        -:  510:STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);
        -:  511:
        -:  512:// indicate whether we should process iphone images back to canonical format,
        -:  513:// or just pass them through "as-is"
        -:  514:STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);
        -:  515:
        -:  516:// flip the image vertically, so the first pixel in the output array is the bottom left
        -:  517:STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);
        -:  518:
        -:  519:// as above, but only applies to images loaded on the thread that calls the function
        -:  520:// this function is only available if your compiler supports thread-local variables;
        -:  521:// calling it will fail to link if your compiler doesn't
        -:  522:STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply);
        -:  523:STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert);
        -:  524:STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip);
        -:  525:
        -:  526:// ZLIB client - used by PNG, available for other purposes
        -:  527:
        -:  528:STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
        -:  529:STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);
        -:  530:STBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
        -:  531:STBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);
        -:  532:
        -:  533:STBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
        -:  534:STBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);
        -:  535:
        -:  536:
        -:  537:#ifdef __cplusplus
        -:  538:}
        -:  539:#endif
        -:  540:
        -:  541://
        -:  542://
        -:  543:////   end header file   /////////////////////////////////////////////////////
        -:  544:#endif // STBI_INCLUDE_STB_IMAGE_H
        -:  545:
        -:  546:#ifdef STB_IMAGE_IMPLEMENTATION
        -:  547:
        -:  548:#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \
        -:  549:  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \
        -:  550:  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \
        -:  551:  || defined(STBI_ONLY_ZLIB)
        -:  552:   #ifndef STBI_ONLY_JPEG
        -:  553:   #define STBI_NO_JPEG
        -:  554:   #endif
        -:  555:   #ifndef STBI_ONLY_PNG
        -:  556:   #define STBI_NO_PNG
        -:  557:   #endif
        -:  558:   #ifndef STBI_ONLY_BMP
        -:  559:   #define STBI_NO_BMP
        -:  560:   #endif
        -:  561:   #ifndef STBI_ONLY_PSD
        -:  562:   #define STBI_NO_PSD
        -:  563:   #endif
        -:  564:   #ifndef STBI_ONLY_TGA
        -:  565:   #define STBI_NO_TGA
        -:  566:   #endif
        -:  567:   #ifndef STBI_ONLY_GIF
        -:  568:   #define STBI_NO_GIF
        -:  569:   #endif
        -:  570:   #ifndef STBI_ONLY_HDR
        -:  571:   #define STBI_NO_HDR
        -:  572:   #endif
        -:  573:   #ifndef STBI_ONLY_PIC
        -:  574:   #define STBI_NO_PIC
        -:  575:   #endif
        -:  576:   #ifndef STBI_ONLY_PNM
        -:  577:   #define STBI_NO_PNM
        -:  578:   #endif
        -:  579:#endif
        -:  580:
        -:  581:#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)
        -:  582:#define STBI_NO_ZLIB
        -:  583:#endif
        -:  584:
        -:  585:
        -:  586:#include <stdarg.h>
        -:  587:#include <stddef.h> // ptrdiff_t on osx
        -:  588:#include <stdlib.h>
        -:  589:#include <string.h>
        -:  590:#include <limits.h>
        -:  591:
        -:  592:#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
        -:  593:#include <math.h>  // ldexp, pow
        -:  594:#endif
        -:  595:
        -:  596:#ifndef STBI_NO_STDIO
        -:  597:#include <stdio.h>
        -:  598:#endif
        -:  599:
        -:  600:#ifndef STBI_ASSERT
        -:  601:#include <assert.h>
        -:  602:#define STBI_ASSERT(x) assert(x)
        -:  603:#endif
        -:  604:
        -:  605:#ifdef __cplusplus
        -:  606:#define STBI_EXTERN extern "C"
        -:  607:#else
        -:  608:#define STBI_EXTERN extern
        -:  609:#endif
        -:  610:
        -:  611:
        -:  612:#ifndef _MSC_VER
        -:  613:   #ifdef __cplusplus
        -:  614:   #define stbi_inline inline
        -:  615:   #else
        -:  616:   #define stbi_inline
        -:  617:   #endif
        -:  618:#else
        -:  619:   #define stbi_inline __forceinline
        -:  620:#endif
        -:  621:
        -:  622:#ifndef STBI_NO_THREAD_LOCALS
        -:  623:   #if defined(__cplusplus) &&  __cplusplus >= 201103L
        -:  624:      #define STBI_THREAD_LOCAL       thread_local
        -:  625:   #elif defined(__GNUC__) && __GNUC__ < 5
        -:  626:      #define STBI_THREAD_LOCAL       __thread
        -:  627:   #elif defined(_MSC_VER)
        -:  628:      #define STBI_THREAD_LOCAL       __declspec(thread)
        -:  629:   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_THREADS__)
        -:  630:      #define STBI_THREAD_LOCAL       _Thread_local
        -:  631:   #endif
        -:  632:
        -:  633:   #ifndef STBI_THREAD_LOCAL
        -:  634:      #if defined(__GNUC__)
        -:  635:        #define STBI_THREAD_LOCAL       __thread
        -:  636:      #endif
        -:  637:   #endif
        -:  638:#endif
        -:  639:
        -:  640:#ifdef _MSC_VER
        -:  641:typedef unsigned short stbi__uint16;
        -:  642:typedef   signed short stbi__int16;
        -:  643:typedef unsigned int   stbi__uint32;
        -:  644:typedef   signed int   stbi__int32;
        -:  645:#else
        -:  646:#include <stdint.h>
        -:  647:typedef uint16_t stbi__uint16;
        -:  648:typedef int16_t  stbi__int16;
        -:  649:typedef uint32_t stbi__uint32;
        -:  650:typedef int32_t  stbi__int32;
        -:  651:#endif
        -:  652:
        -:  653:// should produce compiler error if size is wrong
        -:  654:typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];
        -:  655:
        -:  656:#ifdef _MSC_VER
        -:  657:#define STBI_NOTUSED(v)  (void)(v)
        -:  658:#else
        -:  659:#define STBI_NOTUSED(v)  (void)sizeof(v)
        -:  660:#endif
        -:  661:
        -:  662:#ifdef _MSC_VER
        -:  663:#define STBI_HAS_LROTL
        -:  664:#endif
        -:  665:
        -:  666:#ifdef STBI_HAS_LROTL
        -:  667:   #define stbi_lrot(x,y)  _lrotl(x,y)
        -:  668:#else
        -:  669:   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (-(y) & 31)))
        -:  670:#endif
        -:  671:
        -:  672:#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))
        -:  673:// ok
        -:  674:#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)
        -:  675:// ok
        -:  676:#else
        -:  677:#error "Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED)."
        -:  678:#endif
        -:  679:
        -:  680:#ifndef STBI_MALLOC
        -:  681:#define STBI_MALLOC(sz)           malloc(sz)
        -:  682:#define STBI_REALLOC(p,newsz)     realloc(p,newsz)
        -:  683:#define STBI_FREE(p)              free(p)
        -:  684:#endif
        -:  685:
        -:  686:#ifndef STBI_REALLOC_SIZED
        -:  687:#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)
        -:  688:#endif
        -:  689:
        -:  690:// x86/x64 detection
        -:  691:#if defined(__x86_64__) || defined(_M_X64)
        -:  692:#define STBI__X64_TARGET
        -:  693:#elif defined(__i386) || defined(_M_IX86)
        -:  694:#define STBI__X86_TARGET
        -:  695:#endif
        -:  696:
        -:  697:#if defined(__GNUC__) && defined(STBI__X86_TARGET) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)
        -:  698:// gcc doesn't support sse2 intrinsics unless you compile with -msse2,
        -:  699:// which in turn means it gets to use SSE2 everywhere. This is unfortunate,
        -:  700:// but previous attempts to provide the SSE2 functions with runtime
        -:  701:// detection caused numerous issues. The way architecture extensions are
        -:  702:// exposed in GCC/Clang is, sadly, not really suited for one-file libs.
        -:  703:// New behavior: if compiled with -msse2, we use SSE2 without any
        -:  704:// detection; if not, we don't use it at all.
        -:  705:#define STBI_NO_SIMD
        -:  706:#endif
        -:  707:
        -:  708:#if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)
        -:  709:// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET
        -:  710://
        -:  711:// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the
        -:  712:// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.
        -:  713:// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not
        -:  714:// simultaneously enabling "-mstackrealign".
        -:  715://
        -:  716:// See https://github.com/nothings/stb/issues/81 for more information.
        -:  717://
        -:  718:// So default to no SSE2 on 32-bit MinGW. If you've read this far and added
        -:  719:// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.
        -:  720:#define STBI_NO_SIMD
        -:  721:#endif
        -:  722:
        -:  723:#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))
        -:  724:#define STBI_SSE2
        -:  725:#include <emmintrin.h>
        -:  726:
        -:  727:#ifdef _MSC_VER
        -:  728:
        -:  729:#if _MSC_VER >= 1400  // not VC6
        -:  730:#include <intrin.h> // __cpuid
        -:  731:static int stbi__cpuid3(void)
        -:  732:{
        -:  733:   int info[4];
        -:  734:   __cpuid(info,1);
        -:  735:   return info[3];
        -:  736:}
        -:  737:#else
        -:  738:static int stbi__cpuid3(void)
        -:  739:{
        -:  740:   int res;
        -:  741:   __asm {
        -:  742:      mov  eax,1
        -:  743:      cpuid
        -:  744:      mov  res,edx
        -:  745:   }
        -:  746:   return res;
        -:  747:}
        -:  748:#endif
        -:  749:
        -:  750:#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name
        -:  751:
        -:  752:#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
        -:  753:static int stbi__sse2_available(void)
        -:  754:{
        -:  755:   int info3 = stbi__cpuid3();
        -:  756:   return ((info3 >> 26) & 1) != 0;
        -:  757:}
        -:  758:#endif
        -:  759:
        -:  760:#else // assume GCC-style if not VC++
        -:  761:#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
        -:  762:
        -:  763:#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
        -:  764:static int stbi__sse2_available(void)
        -:  765:{
        -:  766:   // If we're even attempting to compile this on GCC/Clang, that means
        -:  767:   // -msse2 is on, which means the compiler is allowed to use SSE2
        -:  768:   // instructions at will, and so are we.
        -:  769:   return 1;
        -:  770:}
        -:  771:#endif
        -:  772:
        -:  773:#endif
        -:  774:#endif
        -:  775:
        -:  776:// ARM NEON
        -:  777:#if defined(STBI_NO_SIMD) && defined(STBI_NEON)
        -:  778:#undef STBI_NEON
        -:  779:#endif
        -:  780:
        -:  781:#ifdef STBI_NEON
        -:  782:#include <arm_neon.h>
        -:  783:#ifdef _MSC_VER
        -:  784:#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name
        -:  785:#else
        -:  786:#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
        -:  787:#endif
        -:  788:#endif
        -:  789:
        -:  790:#ifndef STBI_SIMD_ALIGN
        -:  791:#define STBI_SIMD_ALIGN(type, name) type name
        -:  792:#endif
        -:  793:
        -:  794:#ifndef STBI_MAX_DIMENSIONS
        -:  795:#define STBI_MAX_DIMENSIONS (1 << 24)
        -:  796:#endif
        -:  797:
        -:  798:///////////////////////////////////////////////
        -:  799://
        -:  800://  stbi__context struct and start_xxx functions
        -:  801:
        -:  802:// stbi__context structure is our basic context used by all images, so it
        -:  803:// contains all the IO context, plus some basic image information
        -:  804:typedef struct
        -:  805:{
        -:  806:   stbi__uint32 img_x, img_y;
        -:  807:   int img_n, img_out_n;
        -:  808:
        -:  809:   stbi_io_callbacks io;
        -:  810:   void *io_user_data;
        -:  811:
        -:  812:   int read_from_callbacks;
        -:  813:   int buflen;
        -:  814:   stbi_uc buffer_start[128];
        -:  815:   int callback_already_read;
        -:  816:
        -:  817:   stbi_uc *img_buffer, *img_buffer_end;
        -:  818:   stbi_uc *img_buffer_original, *img_buffer_original_end;
        -:  819:} stbi__context;
        -:  820:
        -:  821:
        -:  822:static void stbi__refill_buffer(stbi__context *s);
        -:  823:
        -:  824:// initialize a memory-decode context
        -:  825:static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
        -:  826:{
    #####:  827:   s->io.read = NULL;
    #####:  828:   s->read_from_callbacks = 0;
    #####:  829:   s->callback_already_read = 0;
    #####:  830:   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
    #####:  831:   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
        -:  832:}
        -:  833:
        -:  834:// initialize a callback-based context
        -:  835:static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
        -:  836:{
       1*:  837:   s->io = *c;
       1*:  838:   s->io_user_data = user;
       1*:  839:   s->buflen = sizeof(s->buffer_start);
       1*:  840:   s->read_from_callbacks = 1;
       1*:  841:   s->callback_already_read = 0;
       1*:  842:   s->img_buffer = s->img_buffer_original = s->buffer_start;
    #####:  843:   stbi__refill_buffer(s);
call    0 never executed
call    1 never executed
call    2 never executed
       1*:  844:   s->img_buffer_original_end = s->img_buffer_end;
        -:  845:}
        -:  846:
        -:  847:#ifndef STBI_NO_STDIO
        -:  848:
function _ZL16stbi__stdio_readPvPci called 218 returned 100% blocks executed 30%
      218:  849:static int stbi__stdio_read(void *user, char *data, int size)
        -:  850:{
      218:  851:   return (int) fread(data,1,size,(FILE*) user);
      218:  851-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 218
        -:  852:}
        -:  853:
function _ZL16stbi__stdio_skipPvi called 3 returned 100% blocks executed 100%
        3:  854:static void stbi__stdio_skip(void *user, int n)
        -:  855:{
        -:  856:   int ch;
        3:  857:   fseek((FILE*) user, n, SEEK_CUR);
        3:  857-block  0
call    0 returned 3
        3:  858:   ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */
call    0 returned 3
        3:  859:   if (ch != EOF) {
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  860:      ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */
        3:  860-block  0
call    0 returned 3
        -:  861:   }
        3:  862:}
        -:  863:
function _ZL15stbi__stdio_eofPv called 0 returned 0% blocks executed 0%
    #####:  864:static int stbi__stdio_eof(void *user)
        -:  865:{
    #####:  866:   return feof((FILE*) user) || ferror((FILE *) user);
    %%%%%:  866-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%:  866-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  867:}
        -:  868:
        -:  869:static stbi_io_callbacks stbi__stdio_callbacks =
        -:  870:{
        -:  871:   stbi__stdio_read,
        -:  872:   stbi__stdio_skip,
        -:  873:   stbi__stdio_eof,
        -:  874:};
        -:  875:
        -:  876:static void stbi__start_file(stbi__context *s, FILE *f)
        -:  877:{
        -:  878:   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
        -:  879:}
        -:  880:
        -:  881://static void stop_file(stbi__context *s) { }
        -:  882:
        -:  883:#endif // !STBI_NO_STDIO
        -:  884:
        -:  885:static void stbi__rewind(stbi__context *s)
        -:  886:{
        -:  887:   // conceptually rewind SHOULD rewind to the beginning of the stream,
        -:  888:   // but we just rewind to the beginning of the initial buffer, because
        -:  889:   // we only use it after doing 'test', which only ever looks at at most 92 bytes
       1*:  890:   s->img_buffer = s->img_buffer_original;
       1*:  891:   s->img_buffer_end = s->img_buffer_original_end;
    #####:  892:}
        -:  893:
        -:  894:enum
        -:  895:{
        -:  896:   STBI_ORDER_RGB,
        -:  897:   STBI_ORDER_BGR
        -:  898:};
        -:  899:
        -:  900:typedef struct
        -:  901:{
        -:  902:   int bits_per_channel;
        -:  903:   int num_channels;
        -:  904:   int channel_order;
        -:  905:} stbi__result_info;
        -:  906:
        -:  907:#ifndef STBI_NO_JPEG
        -:  908:static int      stbi__jpeg_test(stbi__context *s);
        -:  909:static void    *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  910:static int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);
        -:  911:#endif
        -:  912:
        -:  913:#ifndef STBI_NO_PNG
        -:  914:static int      stbi__png_test(stbi__context *s);
        -:  915:static void    *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  916:static int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);
        -:  917:static int      stbi__png_is16(stbi__context *s);
        -:  918:#endif
        -:  919:
        -:  920:#ifndef STBI_NO_BMP
        -:  921:static int      stbi__bmp_test(stbi__context *s);
        -:  922:static void    *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  923:static int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);
        -:  924:#endif
        -:  925:
        -:  926:#ifndef STBI_NO_TGA
        -:  927:static int      stbi__tga_test(stbi__context *s);
        -:  928:static void    *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  929:static int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);
        -:  930:#endif
        -:  931:
        -:  932:#ifndef STBI_NO_PSD
        -:  933:static int      stbi__psd_test(stbi__context *s);
        -:  934:static void    *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc);
        -:  935:static int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);
        -:  936:static int      stbi__psd_is16(stbi__context *s);
        -:  937:#endif
        -:  938:
        -:  939:#ifndef STBI_NO_HDR
        -:  940:static int      stbi__hdr_test(stbi__context *s);
        -:  941:static float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  942:static int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);
        -:  943:#endif
        -:  944:
        -:  945:#ifndef STBI_NO_PIC
        -:  946:static int      stbi__pic_test(stbi__context *s);
        -:  947:static void    *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  948:static int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);
        -:  949:#endif
        -:  950:
        -:  951:#ifndef STBI_NO_GIF
        -:  952:static int      stbi__gif_test(stbi__context *s);
        -:  953:static void    *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  954:static void    *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
        -:  955:static int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);
        -:  956:#endif
        -:  957:
        -:  958:#ifndef STBI_NO_PNM
        -:  959:static int      stbi__pnm_test(stbi__context *s);
        -:  960:static void    *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
        -:  961:static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);
        -:  962:static int      stbi__pnm_is16(stbi__context *s);
        -:  963:#endif
        -:  964:
        -:  965:static
        -:  966:#ifdef STBI_THREAD_LOCAL
        -:  967:STBI_THREAD_LOCAL
        -:  968:#endif
        -:  969:const char *stbi__g_failure_reason;
        -:  970:
function stbi_failure_reason called 0 returned 0% blocks executed 0%
    #####:  971:STBIDEF const char *stbi_failure_reason(void)
        -:  972:{
    #####:  973:   return stbi__g_failure_reason;
        -:  974:}
        -:  975:
        -:  976:#ifndef STBI_NO_FAILURE_STRINGS
        -:  977:static int stbi__err(const char *str)
        -:  978:{
        -:  979:   stbi__g_failure_reason = str;
        -:  980:   return 0;
        -:  981:}
        -:  982:#endif
        -:  983:
        -:  984:static void *stbi__malloc(size_t size)
        -:  985:{
       2*:  986:    return STBI_MALLOC(size);
        -:  987:}
        -:  988:
        -:  989:// stb_image uses ints pervasively, including for offset calculations.
        -:  990:// therefore the largest decoded image size we can support with the
        -:  991:// current code, even on 64-bit targets, is INT_MAX. this is not a
        -:  992:// significant limitation for the intended use case.
        -:  993://
        -:  994:// we do, however, need to make sure our size calculations don't
        -:  995:// overflow. hence a few helper functions for size calculations that
        -:  996:// multiply integers together, making sure that they're non-negative
        -:  997:// and no overflow occurs.
        -:  998:
        -:  999:// return 1 if the sum is valid, 0 on overflow.
        -: 1000:// negative terms are considered invalid.
        -: 1001:static int stbi__addsizes_valid(int a, int b)
        -: 1002:{
       2*: 1003:   if (b < 0) return 0;
        -: 1004:   // now 0 <= b <= INT_MAX, hence also
        -: 1005:   // 0 <= INT_MAX - b <= INTMAX.
        -: 1006:   // And "a + b <= INT_MAX" (which might overflow) is the
        -: 1007:   // same as a <= INT_MAX - b (no overflow)
       2*: 1008:   return a <= INT_MAX - b;
        -: 1009:}
        -: 1010:
        -: 1011:// returns 1 if the product is valid, 0 on overflow.
        -: 1012:// negative factors are considered invalid.
        -: 1013:static int stbi__mul2sizes_valid(int a, int b)
        -: 1014:{
    #####: 1015:   if (a < 0 || b < 0) return 0;
    %%%%%: 1015-block  0
branch  0 never executed
branch  1 never executed
       4*: 1016:   if (b == 0) return 1; // mul-by-0 is always safe
    %%%%%: 1016-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1016-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1016-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1016-block  3
branch  6 never executed
branch  7 never executed
    %%%%%: 1016-block  4
branch  8 never executed
branch  9 never executed
        2: 1016-block  5
branch 10 taken 2 (fallthrough)
branch 11 taken 0
        2: 1016-block  6
branch 12 taken 2 (fallthrough)
branch 13 taken 0
        -: 1017:   // portable way to check for no overflows in a*b
       4*: 1018:   return a <= INT_MAX/b;
        -: 1019:}
        -: 1020:
        -: 1021:#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
        -: 1022:// returns 1 if "a*b + add" has no negative terms/factors and doesn't overflow
        -: 1023:static int stbi__mad2sizes_valid(int a, int b, int add)
        -: 1024:{
    #####: 1025:   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
    %%%%%: 1025-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1025-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1025-block  2
branch  4 never executed
branch  5 never executed
        -: 1026:}
        -: 1027:#endif
        -: 1028:
        -: 1029:// returns 1 if "a*b*c + add" has no negative terms/factors and doesn't overflow
function _ZL21stbi__mad3sizes_validiiii called 2 returned 100% blocks executed 90%
        2: 1030:static int stbi__mad3sizes_valid(int a, int b, int c, int add)
        2: 1030-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        -: 1031:{
       6*: 1032:   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
    %%%%%: 1032-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1032-block  1
branch  2 never executed
branch  3 never executed
        2: 1032-block  2
branch  4 taken 2 (fallthrough)
branch  5 taken 0
        2: 1032-block  3
branch  6 taken 2 (fallthrough)
branch  7 taken 0
        2: 1032-block  4
branch  8 taken 2 (fallthrough)
branch  9 taken 0
        2: 1032-block  5
branch 10 taken 0 (fallthrough)
branch 11 taken 2
       2*: 1033:      stbi__addsizes_valid(a*b*c, add);
        2: 1033-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        -: 1034:}
        -: 1035:
        -: 1036:// returns 1 if "a*b*c*d + add" has no negative terms/factors and doesn't overflow
        -: 1037:#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
function _ZL21stbi__mad4sizes_validiiiii called 0 returned 0% blocks executed 0%
    #####: 1038:static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
    %%%%%: 1038-block  0
branch  0 never executed
branch  1 never executed
        -: 1039:{
    #####: 1040:   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
    %%%%%: 1040-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1040-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1040-block  2
branch  4 never executed
branch  5 never executed
    #####: 1041:      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
    %%%%%: 1041-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1041-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1041-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1041-block  3
branch  6 never executed
branch  7 never executed
        -: 1042:}
        -: 1043:#endif
        -: 1044:
        -: 1045:#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
        -: 1046:// mallocs with size overflow checking
function _ZL17stbi__malloc_mad2iii called 0 returned 0% blocks executed 0%
    #####: 1047:static void *stbi__malloc_mad2(int a, int b, int add)
    %%%%%: 1047-block  0
branch  0 never executed
branch  1 never executed
        -: 1048:{
        -: 1049:   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;
    #####: 1050:   return stbi__malloc(a*b + add);
    %%%%%: 1050-block  0
        -: 1051:}
        -: 1052:#endif
        -: 1053:
function _ZL17stbi__malloc_mad3iiii called 1 returned 100% blocks executed 100%
        1: 1054:static void *stbi__malloc_mad3(int a, int b, int c, int add)
        -: 1055:{
        1: 1056:   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
        1: 1056-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1057:   return stbi__malloc(a*b*c + add);
        1: 1057-block  0
        -: 1058:}
        -: 1059:
        -: 1060:#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
function _ZL17stbi__malloc_mad4iiiii called 0 returned 0% blocks executed 0%
    #####: 1061:static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
        -: 1062:{
    #####: 1063:   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
    %%%%%: 1063-block  0
branch  0 never executed
branch  1 never executed
    #####: 1064:   return stbi__malloc(a*b*c*d + add);
    %%%%%: 1064-block  0
        -: 1065:}
        -: 1066:#endif
        -: 1067:
        -: 1068:// stbi__err - error
        -: 1069:// stbi__errpf - error returning pointer to float
        -: 1070:// stbi__errpuc - error returning pointer to unsigned char
        -: 1071:
        -: 1072:#ifdef STBI_NO_FAILURE_STRINGS
        -: 1073:   #define stbi__err(x,y)  0
        -: 1074:#elif defined(STBI_FAILURE_USERMSG)
        -: 1075:   #define stbi__err(x,y)  stbi__err(y)
        -: 1076:#else
        -: 1077:   #define stbi__err(x,y)  stbi__err(x)
        -: 1078:#endif
        -: 1079:
        -: 1080:#define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
        -: 1081:#define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))
        -: 1082:
function stbi_image_free called 0 returned 0% blocks executed 0%
    #####: 1083:STBIDEF void stbi_image_free(void *retval_from_stbi_load)
        -: 1084:{
       1*: 1085:   STBI_FREE(retval_from_stbi_load);
    #####: 1086:}
        -: 1087:
        -: 1088:#ifndef STBI_NO_LINEAR
        -: 1089:static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
        -: 1090:#endif
        -: 1091:
        -: 1092:#ifndef STBI_NO_HDR
        -: 1093:static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
        -: 1094:#endif
        -: 1095:
        -: 1096:static int stbi__vertically_flip_on_load_global = 0;
        -: 1097:
function stbi_set_flip_vertically_on_load called 0 returned 0% blocks executed 0%
    #####: 1098:STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
        -: 1099:{
    #####: 1100:   stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
    #####: 1101:}
        -: 1102:
        -: 1103:#ifndef STBI_THREAD_LOCAL
        -: 1104:#define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global
        -: 1105:#else
        -: 1106:static STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;
        -: 1107:
function stbi_set_flip_vertically_on_load_thread called 0 returned 0% blocks executed 0%
    #####: 1108:STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
        -: 1109:{
    #####: 1110:   stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
    #####: 1111:   stbi__vertically_flip_on_load_set = 1;
    #####: 1112:}
        -: 1113:
        -: 1114:#define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \
        -: 1115:                                         ? stbi__vertically_flip_on_load_local  \
        -: 1116:                                         : stbi__vertically_flip_on_load_global)
        -: 1117:#endif // STBI_THREAD_LOCAL
        -: 1118:
function _ZL15stbi__load_mainP13stbi__contextPiS1_S1_iP17stbi__result_infoi called 1 returned 100% blocks executed 16%
        1: 1119:static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
        1: 1119-block  0
call    0 returned 1
        -: 1120:{
        -: 1121:   memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
        1: 1122:   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
        -: 1123:   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
        -: 1124:   ri->num_channels = 0;
        -: 1125:
        -: 1126:   // test the formats with a very explicit header first (at least a FOURCC
        -: 1127:   // or distinctive magic number first)
        -: 1128:   #ifndef STBI_NO_PNG
        2: 1129:   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
        1: 1129-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        -: 1130:   #endif
        -: 1131:   #ifndef STBI_NO_BMP
    #####: 1132:   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
branch  0 never executed
branch  1 never executed
    %%%%%: 1132-block  0
call    2 never executed
        -: 1133:   #endif
        -: 1134:   #ifndef STBI_NO_GIF
    #####: 1135:   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
branch  0 never executed
branch  1 never executed
    %%%%%: 1135-block  0
call    2 never executed
        -: 1136:   #endif
        -: 1137:   #ifndef STBI_NO_PSD
    #####: 1138:   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
branch  0 never executed
branch  1 never executed
    %%%%%: 1138-block  0
call    2 never executed
        -: 1139:   #else
        -: 1140:   STBI_NOTUSED(bpc);
        -: 1141:   #endif
        -: 1142:   #ifndef STBI_NO_PIC
    #####: 1143:   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
branch  0 never executed
branch  1 never executed
    %%%%%: 1143-block  0
call    2 never executed
        -: 1144:   #endif
        -: 1145:
        -: 1146:   // then the formats that can end up attempting to load with just 1 or 2
        -: 1147:   // bytes matching expectations; these are prone to false positives, so
        -: 1148:   // try them later
        -: 1149:   #ifndef STBI_NO_JPEG
    #####: 1150:   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
    %%%%%: 1150-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%: 1150-block  1
call    3 never executed
        -: 1151:   #endif
        -: 1152:   #ifndef STBI_NO_PNM
    #####: 1153:   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
    %%%%%: 1153-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%: 1153-block  1
call    3 never executed
        -: 1154:   #endif
        -: 1155:
        -: 1156:   #ifndef STBI_NO_HDR
    #####: 1157:   if (stbi__hdr_test(s)) {
    %%%%%: 1157-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1158:      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
    %%%%%: 1158-block  0
call    0 never executed
    #####: 1159:      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
branch  0 never executed
branch  1 never executed
    %%%%%: 1159-block  0
    %%%%%: 1159-block  1
call    2 never executed
        -: 1160:   }
        -: 1161:   #endif
        -: 1162:
        -: 1163:   #ifndef STBI_NO_TGA
        -: 1164:   // test tga last because it's a crappy test!
    #####: 1165:   if (stbi__tga_test(s))
    %%%%%: 1165-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1166:      return stbi__tga_load(s,x,y,comp,req_comp, ri);
    %%%%%: 1166-block  0
call    0 never executed
        -: 1167:   #endif
        -: 1168:
        -: 1169:   return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
        -: 1170:}
        -: 1171:
function _ZL21stbi__convert_16_to_8Ptiii called 0 returned 0% blocks executed 0%
    #####: 1172:static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
        -: 1173:{
        -: 1174:   int i;
    #####: 1175:   int img_len = w * h * channels;
        -: 1176:   stbi_uc *reduced;
        -: 1177:
    #####: 1178:   reduced = (stbi_uc *) stbi__malloc(img_len);
    #####: 1179:   if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 1179-block  0
branch  0 never executed
branch  1 never executed
        -: 1180:
    #####: 1181:   for (i = 0; i < img_len; ++i)
    %%%%%: 1181-block  0
branch  0 never executed
branch  1 never executed
    #####: 1182:      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling
    %%%%%: 1182-block  0
        -: 1183:
    #####: 1184:   STBI_FREE(orig);
    #####: 1185:   return reduced;
    %%%%%: 1185-block  0
        -: 1186:}
        -: 1187:
function _ZL21stbi__convert_8_to_16Phiii called 0 returned 0% blocks executed 0%
    #####: 1188:static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
        -: 1189:{
        -: 1190:   int i;
    #####: 1191:   int img_len = w * h * channels;
        -: 1192:   stbi__uint16 *enlarged;
        -: 1193:
    #####: 1194:   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
    #####: 1195:   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 1195-block  0
branch  0 never executed
branch  1 never executed
        -: 1196:
    #####: 1197:   for (i = 0; i < img_len; ++i)
    %%%%%: 1197-block  0
branch  0 never executed
branch  1 never executed
    #####: 1198:      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff
    %%%%%: 1198-block  0
        -: 1199:
    #####: 1200:   STBI_FREE(orig);
    #####: 1201:   return enlarged;
    %%%%%: 1201-block  0
        -: 1202:}
        -: 1203:
function _ZL19stbi__vertical_flipPviii called 0 returned 0% blocks executed 0%
    #####: 1204:static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
        -: 1205:{
        -: 1206:   int row;
    #####: 1207:   size_t bytes_per_row = (size_t)w * bytes_per_pixel;
    %%%%%: 1207-block  0
        -: 1208:   stbi_uc temp[2048];
        -: 1209:   stbi_uc *bytes = (stbi_uc *)image;
        -: 1210:
    #####: 1211:   for (row = 0; row < (h>>1); row++) {
    %%%%%: 1211-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1211-block  1
    #####: 1212:      stbi_uc *row0 = bytes + row*bytes_per_row;
    #####: 1213:      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
    %%%%%: 1213-block  0
        -: 1214:      // swap row0 with row1
        -: 1215:      size_t bytes_left = bytes_per_row;
    #####: 1216:      while (bytes_left) {
    %%%%%: 1216-block  0
branch  0 never executed
branch  1 never executed
    #####: 1217:         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
    %%%%%: 1217-block  0
        -: 1218:         memcpy(temp, row0, bytes_copy);
        -: 1219:         memcpy(row0, row1, bytes_copy);
        -: 1220:         memcpy(row1, temp, bytes_copy);
    #####: 1221:         row0 += bytes_copy;
    #####: 1222:         row1 += bytes_copy;
    #####: 1223:         bytes_left -= bytes_copy;
    %%%%%: 1223-block  0
        -: 1224:      }
        -: 1225:   }
    #####: 1226:}
        -: 1227:
        -: 1228:#ifndef STBI_NO_GIF
        -: 1229:static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
        -: 1230:{
        -: 1231:   int slice;
    #####: 1232:   int slice_size = w * h * bytes_per_pixel;
        -: 1233:
        -: 1234:   stbi_uc *bytes = (stbi_uc *)image;
    #####: 1235:   for (slice = 0; slice < z; ++slice) {
    %%%%%: 1235-block  0
branch  0 never executed
branch  1 never executed
    #####: 1236:      stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
    %%%%%: 1236-block  0
call    0 never executed
    #####: 1237:      bytes += slice_size;
        -: 1238:   }
        -: 1239:}
        -: 1240:#endif
        -: 1241:
function _ZL31stbi__load_and_postprocess_8bitP13stbi__contextPiS1_S1_i called 1 returned 100% blocks executed 47%
        1: 1242:static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
        -: 1243:{
        -: 1244:   stbi__result_info ri;
        1: 1245:   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);
        1: 1245-block  0
call    0 returned 1
        -: 1246:
        1: 1247:   if (result == NULL)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 1248:      return NULL;
        -: 1249:
        -: 1250:   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
       1*: 1251:   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
        1: 1251-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 1251-block  1
call    2 never executed
        -: 1252:
        1: 1253:   if (ri.bits_per_channel != 8) {
        1: 1253-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 1254:      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
    %%%%%: 1254-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1254-block  1
    %%%%%: 1254-block  2
call    2 never executed
    #####: 1255:      ri.bits_per_channel = 8;
        -: 1256:   }
        -: 1257:
        -: 1258:   // @TODO: move stbi__convert_format to here
        -: 1259:
       1*: 1260:   if (stbi__vertically_flip_on_load) {
        1: 1260-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 1260-block  1
        1: 1260-block  2
        1: 1260-block  3
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####: 1261:      int channels = req_comp ? req_comp : *comp;
    %%%%%: 1261-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1261-block  1
    #####: 1262:      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
    %%%%%: 1262-block  0
call    0 never executed
        -: 1263:   }
        -: 1264:
        -: 1265:   return (unsigned char *) result;
        -: 1266:}
        -: 1267:
function _ZL32stbi__load_and_postprocess_16bitP13stbi__contextPiS1_S1_i called 0 returned 0% blocks executed 0%
    #####: 1268:static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
        -: 1269:{
        -: 1270:   stbi__result_info ri;
    #####: 1271:   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);
    %%%%%: 1271-block  0
call    0 never executed
        -: 1272:
    #####: 1273:   if (result == NULL)
branch  0 never executed
branch  1 never executed
        -: 1274:      return NULL;
        -: 1275:
        -: 1276:   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
    #####: 1277:   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
    %%%%%: 1277-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1277-block  1
call    2 never executed
        -: 1278:
    #####: 1279:   if (ri.bits_per_channel != 16) {
    %%%%%: 1279-block  0
branch  0 never executed
branch  1 never executed
    #####: 1280:      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
    %%%%%: 1280-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1280-block  1
    %%%%%: 1280-block  2
call    2 never executed
    #####: 1281:      ri.bits_per_channel = 16;
        -: 1282:   }
        -: 1283:
        -: 1284:   // @TODO: move stbi__convert_format16 to here
        -: 1285:   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision
        -: 1286:
    #####: 1287:   if (stbi__vertically_flip_on_load) {
    %%%%%: 1287-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1287-block  1
    %%%%%: 1287-block  2
    %%%%%: 1287-block  3
branch  2 never executed
branch  3 never executed
    #####: 1288:      int channels = req_comp ? req_comp : *comp;
    %%%%%: 1288-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1288-block  1
    #####: 1289:      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
    %%%%%: 1289-block  0
call    0 never executed
        -: 1290:   }
        -: 1291:
        -: 1292:   return (stbi__uint16 *) result;
        -: 1293:}
        -: 1294:
        -: 1295:#if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)
function _ZL23stbi__float_postprocessPfPiS0_S0_i called 0 returned 0% blocks executed 0%
    #####: 1296:static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
        -: 1297:{
    #####: 1298:   if (stbi__vertically_flip_on_load && result != NULL) {
    %%%%%: 1298-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1298-block  1
    %%%%%: 1298-block  2
    %%%%%: 1298-block  3
branch  2 never executed
branch  3 never executed
    %%%%%: 1298-block  4
branch  4 never executed
branch  5 never executed
    #####: 1299:      int channels = req_comp ? req_comp : *comp;
    %%%%%: 1299-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1299-block  1
    #####: 1300:      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
    %%%%%: 1300-block  0
call    0 never executed
        -: 1301:   }
    #####: 1302:}
        -: 1303:#endif
        -: 1304:
        -: 1305:#ifndef STBI_NO_STDIO
        -: 1306:
        -: 1307:#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
        -: 1308:STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
        -: 1309:STBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);
        -: 1310:#endif
        -: 1311:
        -: 1312:#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
        -: 1313:STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
        -: 1314:{
        -: 1315:	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
        -: 1316:}
        -: 1317:#endif
        -: 1318:
        -: 1319:static FILE *stbi__fopen(char const *filename, char const *mode)
        -: 1320:{
        -: 1321:   FILE *f;
        -: 1322:#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
        -: 1323:   wchar_t wMode[64];
        -: 1324:   wchar_t wFilename[1024];
        -: 1325:	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
        -: 1326:      return 0;
        -: 1327:
        -: 1328:	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
        -: 1329:      return 0;
        -: 1330:
        -: 1331:#if defined(_MSC_VER) && _MSC_VER >= 1400
        -: 1332:	if (0 != _wfopen_s(&f, wFilename, wMode))
        -: 1333:		f = 0;
        -: 1334:#else
        -: 1335:   f = _wfopen(wFilename, wMode);
        -: 1336:#endif
        -: 1337:
        -: 1338:#elif defined(_MSC_VER) && _MSC_VER >= 1400
        -: 1339:   if (0 != fopen_s(&f, filename, mode))
        -: 1340:      f=0;
        -: 1341:#else
       1*: 1342:   f = fopen(filename, mode);
        -: 1343:#endif
        -: 1344:   return f;
        -: 1345:}
        -: 1346:
        -: 1347:
function stbi_load called 1 returned 100% blocks executed 100%
        1: 1348:STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
        1: 1348-block  0
call    0 returned 1
        -: 1349:{
        -: 1350:   FILE *f = stbi__fopen(filename, "rb");
        -: 1351:   unsigned char *result;
        1: 1352:   if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1353:   result = stbi_load_from_file(f,x,y,comp,req_comp);
        1: 1353-block  0
call    0 returned 1
        1: 1354:   fclose(f);
call    0 returned 1
        1: 1355:   return result;
        -: 1356:}
        -: 1357:
function stbi_load_from_file called 1 returned 100% blocks executed 100%
        1: 1358:STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
        1: 1358-block  0
call    0 returned 1
        -: 1359:{
        -: 1360:   unsigned char *result;
        -: 1361:   stbi__context s;
        -: 1362:   stbi__start_file(&s,f);
        1: 1363:   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
call    0 returned 1
        1: 1364:   if (result) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 1365:      // need to 'unget' all the characters in the IO buffer
        1: 1366:      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
        1: 1366-block  0
call    0 returned 1
        -: 1367:   }
        1: 1368:   return result;
        -: 1369:}
        -: 1370:
function stbi_load_from_file_16 called 0 returned 0% blocks executed 0%
    #####: 1371:STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
    %%%%%: 1371-block  0
call    0 never executed
        -: 1372:{
        -: 1373:   stbi__uint16 *result;
        -: 1374:   stbi__context s;
        -: 1375:   stbi__start_file(&s,f);
    #####: 1376:   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
call    0 never executed
    #####: 1377:   if (result) {
branch  0 never executed
branch  1 never executed
        -: 1378:      // need to 'unget' all the characters in the IO buffer
    #####: 1379:      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
    %%%%%: 1379-block  0
call    0 never executed
        -: 1380:   }
    #####: 1381:   return result;
        -: 1382:}
        -: 1383:
function stbi_load_16 called 0 returned 0% blocks executed 0%
    #####: 1384:STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
    %%%%%: 1384-block  0
call    0 never executed
        -: 1385:{
        -: 1386:   FILE *f = stbi__fopen(filename, "rb");
        -: 1387:   stbi__uint16 *result;
    #####: 1388:   if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");
branch  0 never executed
branch  1 never executed
    #####: 1389:   result = stbi_load_from_file_16(f,x,y,comp,req_comp);
    %%%%%: 1389-block  0
call    0 never executed
    #####: 1390:   fclose(f);
call    0 never executed
    #####: 1391:   return result;
        -: 1392:}
        -: 1393:
        -: 1394:
        -: 1395:#endif //!STBI_NO_STDIO
        -: 1396:
function stbi_load_16_from_memory called 0 returned 0% blocks executed 0%
    #####: 1397:STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
        -: 1398:{
        -: 1399:   stbi__context s;
        -: 1400:   stbi__start_mem(&s,buffer,len);
    #####: 1401:   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
    %%%%%: 1401-block  0
call    0 never executed
        -: 1402:}
        -: 1403:
function stbi_load_16_from_callbacks called 0 returned 0% blocks executed 0%
    #####: 1404:STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
    %%%%%: 1404-block  0
call    0 never executed
        -: 1405:{
        -: 1406:   stbi__context s;
        -: 1407:   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
    #####: 1408:   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
call    0 never executed
        -: 1409:}
        -: 1410:
function stbi_load_from_memory called 0 returned 0% blocks executed 0%
    #####: 1411:STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
        -: 1412:{
        -: 1413:   stbi__context s;
        -: 1414:   stbi__start_mem(&s,buffer,len);
    #####: 1415:   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
    %%%%%: 1415-block  0
call    0 never executed
        -: 1416:}
        -: 1417:
function stbi_load_from_callbacks called 0 returned 0% blocks executed 0%
    #####: 1418:STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
    %%%%%: 1418-block  0
call    0 never executed
        -: 1419:{
        -: 1420:   stbi__context s;
        -: 1421:   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
    #####: 1422:   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
call    0 never executed
        -: 1423:}
        -: 1424:
        -: 1425:#ifndef STBI_NO_GIF
function stbi_load_gif_from_memory called 0 returned 0% blocks executed 0%
    #####: 1426:STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
        -: 1427:{
        -: 1428:   unsigned char *result;
        -: 1429:   stbi__context s;
        -: 1430:   stbi__start_mem(&s,buffer,len);
        -: 1431:
    #####: 1432:   result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
    %%%%%: 1432-block  0
call    0 never executed
    #####: 1433:   if (stbi__vertically_flip_on_load) {
branch  0 never executed
branch  1 never executed
    %%%%%: 1433-block  0
    %%%%%: 1433-block  1
    %%%%%: 1433-block  2
branch  2 never executed
branch  3 never executed
    #####: 1434:      stbi__vertical_flip_slices( result, *x, *y, *z, *comp );
    %%%%%: 1434-block  0
        -: 1435:   }
        -: 1436:
    #####: 1437:   return result;
        -: 1438:}
        -: 1439:#endif
        -: 1440:
        -: 1441:#ifndef STBI_NO_LINEAR
function _ZL16stbi__loadf_mainP13stbi__contextPiS1_S1_i called 0 returned 0% blocks executed 0%
    #####: 1442:static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
        -: 1443:{
        -: 1444:   unsigned char *data;
        -: 1445:   #ifndef STBI_NO_HDR
    #####: 1446:   if (stbi__hdr_test(s)) {
    %%%%%: 1446-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1447:      stbi__result_info ri;
    #####: 1448:      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
    %%%%%: 1448-block  0
call    0 never executed
    #####: 1449:      if (hdr_data)
branch  0 never executed
branch  1 never executed
    #####: 1450:         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
    %%%%%: 1450-block  0
call    0 never executed
        -: 1451:      return hdr_data;
        -: 1452:   }
        -: 1453:   #endif
    #####: 1454:   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
    %%%%%: 1454-block  0
call    0 never executed
    #####: 1455:   if (data)
branch  0 never executed
branch  1 never executed
    #####: 1456:      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
    %%%%%: 1456-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1456-block  1
    %%%%%: 1456-block  2
call    2 never executed
        -: 1457:   return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
        -: 1458:}
        -: 1459:
function stbi_loadf_from_memory called 0 returned 0% blocks executed 0%
    #####: 1460:STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
        -: 1461:{
        -: 1462:   stbi__context s;
        -: 1463:   stbi__start_mem(&s,buffer,len);
    #####: 1464:   return stbi__loadf_main(&s,x,y,comp,req_comp);
    %%%%%: 1464-block  0
call    0 never executed
        -: 1465:}
        -: 1466:
function stbi_loadf_from_callbacks called 0 returned 0% blocks executed 0%
    #####: 1467:STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
    %%%%%: 1467-block  0
call    0 never executed
        -: 1468:{
        -: 1469:   stbi__context s;
        -: 1470:   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
    #####: 1471:   return stbi__loadf_main(&s,x,y,comp,req_comp);
call    0 never executed
        -: 1472:}
        -: 1473:
        -: 1474:#ifndef STBI_NO_STDIO
function stbi_loadf called 0 returned 0% blocks executed 0%
    #####: 1475:STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
    %%%%%: 1475-block  0
call    0 never executed
        -: 1476:{
        -: 1477:   float *result;
        -: 1478:   FILE *f = stbi__fopen(filename, "rb");
    #####: 1479:   if (!f) return stbi__errpf("can't fopen", "Unable to open file");
branch  0 never executed
branch  1 never executed
    #####: 1480:   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
    %%%%%: 1480-block  0
call    0 never executed
    #####: 1481:   fclose(f);
call    0 never executed
    #####: 1482:   return result;
        -: 1483:}
        -: 1484:
function stbi_loadf_from_file called 0 returned 0% blocks executed 0%
    #####: 1485:STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
    %%%%%: 1485-block  0
call    0 never executed
        -: 1486:{
        -: 1487:   stbi__context s;
        -: 1488:   stbi__start_file(&s,f);
    #####: 1489:   return stbi__loadf_main(&s,x,y,comp,req_comp);
call    0 never executed
        -: 1490:}
        -: 1491:#endif // !STBI_NO_STDIO
        -: 1492:
        -: 1493:#endif // !STBI_NO_LINEAR
        -: 1494:
        -: 1495:// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
        -: 1496:// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
        -: 1497:// reports false!
        -: 1498:
function stbi_is_hdr_from_memory called 0 returned 0% blocks executed 0%
    #####: 1499:STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
        -: 1500:{
        -: 1501:   #ifndef STBI_NO_HDR
        -: 1502:   stbi__context s;
        -: 1503:   stbi__start_mem(&s,buffer,len);
    #####: 1504:   return stbi__hdr_test(&s);
    %%%%%: 1504-block  0
call    0 never executed
        -: 1505:   #else
        -: 1506:   STBI_NOTUSED(buffer);
        -: 1507:   STBI_NOTUSED(len);
        -: 1508:   return 0;
        -: 1509:   #endif
        -: 1510:}
        -: 1511:
        -: 1512:#ifndef STBI_NO_STDIO
function stbi_is_hdr called 0 returned 0% blocks executed 0%
    #####: 1513:STBIDEF int      stbi_is_hdr          (char const *filename)
    %%%%%: 1513-block  0
call    0 never executed
        -: 1514:{
        -: 1515:   FILE *f = stbi__fopen(filename, "rb");
        -: 1516:   int result=0;
    #####: 1517:   if (f) {
branch  0 never executed
branch  1 never executed
    #####: 1518:      result = stbi_is_hdr_from_file(f);
    %%%%%: 1518-block  0
call    0 never executed
    #####: 1519:      fclose(f);
call    0 never executed
        -: 1520:   }
    #####: 1521:   return result;
        -: 1522:}
        -: 1523:
function stbi_is_hdr_from_file called 0 returned 0% blocks executed 0%
    #####: 1524:STBIDEF int stbi_is_hdr_from_file(FILE *f)
        -: 1525:{
        -: 1526:   #ifndef STBI_NO_HDR
    #####: 1527:   long pos = ftell(f);
    %%%%%: 1527-block  0
call    0 never executed
        -: 1528:   int res;
        -: 1529:   stbi__context s;
        -: 1530:   stbi__start_file(&s,f);
    #####: 1531:   res = stbi__hdr_test(&s);
call    0 never executed
    #####: 1532:   fseek(f, pos, SEEK_SET);
call    0 never executed
    #####: 1533:   return res;
        -: 1534:   #else
        -: 1535:   STBI_NOTUSED(f);
        -: 1536:   return 0;
        -: 1537:   #endif
        -: 1538:}
        -: 1539:#endif // !STBI_NO_STDIO
        -: 1540:
function stbi_is_hdr_from_callbacks called 0 returned 0% blocks executed 0%
    #####: 1541:STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
    %%%%%: 1541-block  0
call    0 never executed
        -: 1542:{
        -: 1543:   #ifndef STBI_NO_HDR
        -: 1544:   stbi__context s;
        -: 1545:   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
    #####: 1546:   return stbi__hdr_test(&s);
call    0 never executed
        -: 1547:   #else
        -: 1548:   STBI_NOTUSED(clbk);
        -: 1549:   STBI_NOTUSED(user);
        -: 1550:   return 0;
        -: 1551:   #endif
        -: 1552:}
        -: 1553:
        -: 1554:#ifndef STBI_NO_LINEAR
        -: 1555:static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;
        -: 1556:
function stbi_ldr_to_hdr_gamma called 0 returned 0% blocks executed 0%
    #####: 1557:STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
function stbi_ldr_to_hdr_scale called 0 returned 0% blocks executed 0%
    #####: 1558:STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
        -: 1559:#endif
        -: 1560:
        -: 1561:static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;
        -: 1562:
function stbi_hdr_to_ldr_gamma called 0 returned 0% blocks executed 0%
    #####: 1563:STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
function stbi_hdr_to_ldr_scale called 0 returned 0% blocks executed 0%
    #####: 1564:STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }
        -: 1565:
        -: 1566:
        -: 1567://////////////////////////////////////////////////////////////////////////////
        -: 1568://
        -: 1569:// Common code used by all image loaders
        -: 1570://
        -: 1571:
        -: 1572:enum
        -: 1573:{
        -: 1574:   STBI__SCAN_load=0,
        -: 1575:   STBI__SCAN_type,
        -: 1576:   STBI__SCAN_header
        -: 1577:};
        -: 1578:
function _ZL19stbi__refill_bufferP13stbi__context called 111 returned 100% blocks executed 80%
      111: 1579:static void stbi__refill_buffer(stbi__context *s)
        -: 1580:{
      111: 1581:   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
      111: 1581-block  0
call    0 returned 111
      111: 1582:   s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);
      111: 1583:   if (n == 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 111
        -: 1584:      // at end of file, treat same as if from memory, but need to handle case
        -: 1585:      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
    #####: 1586:      s->read_from_callbacks = 0;
    #####: 1587:      s->img_buffer = s->buffer_start;
    #####: 1588:      s->img_buffer_end = s->buffer_start+1;
    #####: 1589:      *s->img_buffer = 0;
    %%%%%: 1589-block  0
        -: 1590:   } else {
      111: 1591:      s->img_buffer = s->buffer_start;
      111: 1592:      s->img_buffer_end = s->buffer_start + n;
      111: 1592-block  0
        -: 1593:   }
      111: 1594:}
        -: 1595:
function _ZL10stbi__get8P13stbi__context called 1409 returned 100% blocks executed 100%
     1409: 1596:stbi_inline static stbi_uc stbi__get8(stbi__context *s)
        -: 1597:{
     1409: 1598:   if (s->img_buffer < s->img_buffer_end)
     1409: 1598-block  0
branch  0 taken 1299 (fallthrough)
branch  1 taken 110
     1299: 1599:      return *s->img_buffer++;
     1299: 1599-block  0
      110: 1600:   if (s->read_from_callbacks) {
      110: 1600-block  0
branch  0 taken 110 (fallthrough)
branch  1 taken 0
      110: 1601:      stbi__refill_buffer(s);
      110: 1601-block  0
call    0 returned 110
      110: 1602:      return *s->img_buffer++;
        -: 1603:   }
        -: 1604:   return 0;
        -: 1605:}
        -: 1606:
        -: 1607:#if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
        -: 1608:// nothing
        -: 1609:#else
        -: 1610:stbi_inline static int stbi__at_eof(stbi__context *s)
        -: 1611:{
    #####: 1612:   if (s->io.read) {
    %%%%%: 1612-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1612-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1612-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1612-block  3
branch  6 never executed
branch  7 never executed
    %%%%%: 1612-block  4
branch  8 never executed
branch  9 never executed
    %%%%%: 1612-block  5
branch 10 never executed
branch 11 never executed
    %%%%%: 1612-block  6
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    %%%%%: 1612-block  7
branch 16 never executed
branch 17 never executed
    #####: 1613:      if (!(s->io.eof)(s->io_user_data)) return 0;
    %%%%%: 1613-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%: 1613-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    %%%%%: 1613-block  2
call    6 never executed
branch  7 never executed
branch  8 never executed
    %%%%%: 1613-block  3
call    9 never executed
branch 10 never executed
branch 11 never executed
    %%%%%: 1613-block  4
call   12 never executed
branch 13 never executed
branch 14 never executed
    %%%%%: 1613-block  5
call   15 never executed
branch 16 never executed
branch 17 never executed
    %%%%%: 1613-block  6
call   18 never executed
branch 19 never executed
branch 20 never executed
    %%%%%: 1613-block  7
call   21 never executed
branch 22 never executed
branch 23 never executed
    %%%%%: 1613-block  8
call   24 never executed
branch 25 never executed
branch 26 never executed
    %%%%%: 1613-block  9
call   27 never executed
branch 28 never executed
branch 29 never executed
    %%%%%: 1613-block 10
call   30 never executed
branch 31 never executed
branch 32 never executed
    %%%%%: 1613-block 11
call   33 never executed
branch 34 never executed
branch 35 never executed
    %%%%%: 1613-block 12
call   36 never executed
branch 37 never executed
branch 38 never executed
    %%%%%: 1613-block 13
call   39 never executed
branch 40 never executed
branch 41 never executed
    %%%%%: 1613-block 14
call   42 never executed
branch 43 never executed
branch 44 never executed
        -: 1614:      // if feof() is true, check if buffer = end
        -: 1615:      // special case: we've only got the special 0 character at the end
    #####: 1616:      if (s->read_from_callbacks == 0) return 1;
    %%%%%: 1616-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1616-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1616-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1616-block  3
branch  6 never executed
branch  7 never executed
    %%%%%: 1616-block  4
branch  8 never executed
branch  9 never executed
    %%%%%: 1616-block  5
branch 10 never executed
branch 11 never executed
    %%%%%: 1616-block  6
branch 12 never executed
branch 13 never executed
    %%%%%: 1616-block  7
branch 14 never executed
branch 15 never executed
    %%%%%: 1616-block  8
branch 16 never executed
branch 17 never executed
    %%%%%: 1616-block  9
branch 18 never executed
branch 19 never executed
    %%%%%: 1616-block 10
branch 20 never executed
branch 21 never executed
    %%%%%: 1616-block 11
branch 22 never executed
branch 23 never executed
    %%%%%: 1616-block 12
branch 24 never executed
branch 25 never executed
    %%%%%: 1616-block 13
branch 26 never executed
branch 27 never executed
    %%%%%: 1616-block 14
branch 28 never executed
branch 29 never executed
        -: 1617:   }
        -: 1618:
    #####: 1619:   return s->img_buffer >= s->img_buffer_end;
        -: 1620:}
        -: 1621:#endif
        -: 1622:
        -: 1623:#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
        -: 1624:// nothing
        -: 1625:#else
function _ZL10stbi__skipP13stbi__contexti called 6 returned 100% blocks executed 89%
        6: 1626:static void stbi__skip(stbi__context *s, int n)
        -: 1627:{
        6: 1628:   if (n == 0) return;  // already there!
        6: 1628-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 0
        6: 1629:   if (n < 0) {
        6: 1629-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 6
    #####: 1630:      s->img_buffer = s->img_buffer_end;
    #####: 1631:      return;
    %%%%%: 1631-block  0
        -: 1632:   }
       6*: 1633:   if (s->io.read) {
    %%%%%: 1633-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1633-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1633-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1633-block  3
branch  6 never executed
branch  7 never executed
    %%%%%: 1633-block  4
branch  8 never executed
branch  9 never executed
    %%%%%: 1633-block  5
branch 10 never executed
branch 11 never executed
    %%%%%: 1633-block  6
branch 12 never executed
branch 13 never executed
    %%%%%: 1633-block  7
branch 14 never executed
branch 15 never executed
    %%%%%: 1633-block  8
branch 16 never executed
branch 17 never executed
    %%%%%: 1633-block  9
branch 18 never executed
branch 19 never executed
    %%%%%: 1633-block 10
branch 20 never executed
branch 21 never executed
    %%%%%: 1633-block 11
branch 22 never executed
branch 23 never executed
        6: 1633-block 12
branch 24 taken 6 (fallthrough)
branch 25 taken 0
       6*: 1634:      int blen = (int) (s->img_buffer_end - s->img_buffer);
       6*: 1635:      if (blen < n) {
    %%%%%: 1635-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1635-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 1635-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 1635-block  3
branch  6 never executed
branch  7 never executed
    %%%%%: 1635-block  4
branch  8 never executed
branch  9 never executed
    %%%%%: 1635-block  5
branch 10 never executed
branch 11 never executed
    %%%%%: 1635-block  6
branch 12 never executed
branch 13 never executed
    %%%%%: 1635-block  7
branch 14 never executed
branch 15 never executed
    %%%%%: 1635-block  8
branch 16 never executed
branch 17 never executed
    %%%%%: 1635-block  9
branch 18 never executed
branch 19 never executed
    %%%%%: 1635-block 10
branch 20 never executed
branch 21 never executed
    %%%%%: 1635-block 11
branch 22 never executed
branch 23 never executed
        6: 1635-block 12
branch 24 taken 3 (fallthrough)
branch 25 taken 3
       3*: 1636:         s->img_buffer = s->img_buffer_end;
       3*: 1637:         (s->io.skip)(s->io_user_data, n - blen);
    %%%%%: 1637-block  0
call    0 never executed
    %%%%%: 1637-block  1
call    1 never executed
    %%%%%: 1637-block  2
call    2 never executed
    %%%%%: 1637-block  3
call    3 never executed
    %%%%%: 1637-block  4
call    4 never executed
    %%%%%: 1637-block  5
call    5 never executed
    %%%%%: 1637-block  6
call    6 never executed
    %%%%%: 1637-block  7
call    7 never executed
    %%%%%: 1637-block  8
call    8 never executed
    %%%%%: 1637-block  9
call    9 never executed
    %%%%%: 1637-block 10
call   10 never executed
    %%%%%: 1637-block 11
call   11 never executed
        3: 1637-block 12
call   12 returned 3
       3*: 1638:         return;
        -: 1639:      }
        -: 1640:   }
       3*: 1641:   s->img_buffer += n;
    %%%%%: 1641-block  0
    %%%%%: 1641-block  1
    %%%%%: 1641-block  2
    %%%%%: 1641-block  3
    %%%%%: 1641-block  4
    %%%%%: 1641-block  5
    %%%%%: 1641-block  6
    %%%%%: 1641-block  7
    %%%%%: 1641-block  8
    %%%%%: 1641-block  9
    %%%%%: 1641-block 10
    %%%%%: 1641-block 11
        3: 1641-block 12
        -: 1642:}
        -: 1643:#endif
        -: 1644:
        -: 1645:#if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
        -: 1646:// nothing
        -: 1647:#else
function _ZL10stbi__getnP13stbi__contextPhi called 107 returned 100% blocks executed 71%
      107: 1648:static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
        -: 1649:{
      107: 1650:   if (s->io.read) {
      107: 1650-block  0
branch  0 taken 107 (fallthrough)
branch  1 taken 0
      107: 1651:      int blen = (int) (s->img_buffer_end - s->img_buffer);
      107: 1652:      if (blen < n) {
      107: 1652-block  0
branch  0 taken 107 (fallthrough)
branch  1 taken 0
        -: 1653:         int res, count;
        -: 1654:
      107: 1655:         memcpy(buffer, s->img_buffer, blen);
      107: 1655-block  0
call    0 returned 107
        -: 1656:
      107: 1657:         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
      107: 1657-block  0
call    0 returned 107
      107: 1658:         res = (count == (n-blen));
      107: 1659:         s->img_buffer = s->img_buffer_end;
      107: 1660:         return res;
        -: 1661:      }
        -: 1662:   }
        -: 1663:
    #####: 1664:   if (s->img_buffer+n <= s->img_buffer_end) {
    %%%%%: 1664-block  0
branch  0 never executed
branch  1 never executed
        -: 1665:      memcpy(buffer, s->img_buffer, n);
    #####: 1666:      s->img_buffer += n;
    #####: 1667:      return 1;
    %%%%%: 1667-block  0
        -: 1668:   } else
        -: 1669:      return 0;
        -: 1670:}
        -: 1671:#endif
        -: 1672:
        -: 1673:#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
        -: 1674:// nothing
        -: 1675:#else
function _ZL13stbi__get16beP13stbi__context called 694 returned 100% blocks executed 100%
      694: 1676:static int stbi__get16be(stbi__context *s)
        -: 1677:{
      694: 1678:   int z = stbi__get8(s);
      694: 1678-block  0
call    0 returned 694
      694: 1679:   return (z << 8) + stbi__get8(s);
call    0 returned 694
        -: 1680:}
        -: 1681:#endif
        -: 1682:
        -: 1683:#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
        -: 1684:// nothing
        -: 1685:#else
function _ZL13stbi__get32beP13stbi__context called 347 returned 100% blocks executed 100%
      347: 1686:static stbi__uint32 stbi__get32be(stbi__context *s)
        -: 1687:{
      347: 1688:   stbi__uint32 z = stbi__get16be(s);
      347: 1688-block  0
call    0 returned 347
      347: 1689:   return (z << 16) + stbi__get16be(s);
call    0 returned 347
        -: 1690:}
        -: 1691:#endif
        -: 1692:
        -: 1693:#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
        -: 1694:// nothing
        -: 1695:#else
function _ZL13stbi__get16leP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 1696:static int stbi__get16le(stbi__context *s)
        -: 1697:{
    #####: 1698:   int z = stbi__get8(s);
    %%%%%: 1698-block  0
call    0 never executed
    #####: 1699:   return z + (stbi__get8(s) << 8);
call    0 never executed
        -: 1700:}
        -: 1701:#endif
        -: 1702:
        -: 1703:#ifndef STBI_NO_BMP
function _ZL13stbi__get32leP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 1704:static stbi__uint32 stbi__get32le(stbi__context *s)
        -: 1705:{
    #####: 1706:   stbi__uint32 z = stbi__get16le(s);
    %%%%%: 1706-block  0
call    0 never executed
    #####: 1707:   z += (stbi__uint32)stbi__get16le(s) << 16;
call    0 never executed
    #####: 1708:   return z;
        -: 1709:}
        -: 1710:#endif
        -: 1711:
        -: 1712:#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
        -: 1713:
        -: 1714:#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
        -: 1715:// nothing
        -: 1716:#else
        -: 1717://////////////////////////////////////////////////////////////////////////////
        -: 1718://
        -: 1719://  generic converter from built-in img_n to req_comp
        -: 1720://    individual types do this automatically as much as possible (e.g. jpeg
        -: 1721://    does all cases internally since it needs to colorspace convert anyway,
        -: 1722://    and it never has alpha, so very few cases ). png can automatically
        -: 1723://    interleave an alpha=255 channel, but falls back to this for other cases
        -: 1724://
        -: 1725://  assume data buffer is malloced, so malloc a new one and free that one
        -: 1726://  only failure mode is malloc failing
        -: 1727:
        -: 1728:static stbi_uc stbi__compute_y(int r, int g, int b)
        -: 1729:{
    #####: 1730:   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
        -: 1731:}
        -: 1732:#endif
        -: 1733:
        -: 1734:#if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
        -: 1735:// nothing
        -: 1736:#else
function _ZL20stbi__convert_formatPhiijj called 0 returned 0% blocks executed 0%
    #####: 1737:static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
        -: 1738:{
        -: 1739:   int i,j;
        -: 1740:   unsigned char *good;
        -: 1741:
    #####: 1742:   if (req_comp == img_n) return data;
    %%%%%: 1742-block  0
branch  0 never executed
branch  1 never executed
    #####: 1743:   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
    %%%%%: 1743-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1743-block  1
call    2 never executed
        -: 1744:
    #####: 1745:   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
    %%%%%: 1745-block  0
call    0 never executed
    #####: 1746:   if (good == NULL) {
branch  0 never executed
branch  1 never executed
    #####: 1747:      STBI_FREE(data);
    #####: 1748:      return stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 1748-block  0
        -: 1749:   }
        -: 1750:
    #####: 1751:   for (j=0; j < (int) y; ++j) {
    %%%%%: 1751-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1751-block  1
    #####: 1752:      unsigned char *src  = data + j * x * img_n   ;
    #####: 1753:      unsigned char *dest = good + j * x * req_comp;
        -: 1754:
        -: 1755:      #define STBI__COMBO(a,b)  ((a)*8+(b))
        -: 1756:      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
        -: 1757:      // convert source image with img_n components to one with req_comp components;
        -: 1758:      // avoid switch per pixel, so use switch per scanline and massive macros
    #####: 1759:      switch (STBI__COMBO(img_n, req_comp)) {
    %%%%%: 1759-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
    #####: 1760:         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
    %%%%%: 1760-block  0
    %%%%%: 1760-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1760-block  2
    #####: 1761:         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
    %%%%%: 1761-block  0
    %%%%%: 1761-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1761-block  2
    #####: 1762:         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
    %%%%%: 1762-block  0
    %%%%%: 1762-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1762-block  2
    #####: 1763:         STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
    %%%%%: 1763-block  0
    %%%%%: 1763-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1763-block  2
    #####: 1764:         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
    %%%%%: 1764-block  0
    %%%%%: 1764-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1764-block  2
    #####: 1765:         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
    %%%%%: 1765-block  0
    %%%%%: 1765-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1765-block  2
    #####: 1766:         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
    %%%%%: 1766-block  0
    %%%%%: 1766-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1766-block  2
    #####: 1767:         STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
    %%%%%: 1767-block  0
    %%%%%: 1767-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1767-block  2
    #####: 1768:         STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
    %%%%%: 1768-block  0
    %%%%%: 1768-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1768-block  2
    #####: 1769:         STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
    %%%%%: 1769-block  0
    %%%%%: 1769-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1769-block  2
    #####: 1770:         STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
    %%%%%: 1770-block  0
    %%%%%: 1770-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1770-block  2
    #####: 1771:         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
    %%%%%: 1771-block  0
    %%%%%: 1771-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1771-block  2
    #####: 1772:         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
    %%%%%: 1772-block  0
call    0 never executed
        -: 1773:      }
        -: 1774:      #undef STBI__CASE
        -: 1775:   }
        -: 1776:
    #####: 1777:   STBI_FREE(data);
    #####: 1778:   return good;
    %%%%%: 1778-block  0
        -: 1779:}
        -: 1780:#endif
        -: 1781:
        -: 1782:#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
        -: 1783:// nothing
        -: 1784:#else
        -: 1785:static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
        -: 1786:{
    #####: 1787:   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
        -: 1788:}
        -: 1789:#endif
        -: 1790:
        -: 1791:#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
        -: 1792:// nothing
        -: 1793:#else
function _ZL22stbi__convert_format16Ptiijj called 0 returned 0% blocks executed 0%
    #####: 1794:static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
        -: 1795:{
        -: 1796:   int i,j;
        -: 1797:   stbi__uint16 *good;
        -: 1798:
    #####: 1799:   if (req_comp == img_n) return data;
    %%%%%: 1799-block  0
branch  0 never executed
branch  1 never executed
    #####: 1800:   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
    %%%%%: 1800-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1800-block  1
call    2 never executed
        -: 1801:
    #####: 1802:   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
    #####: 1803:   if (good == NULL) {
    %%%%%: 1803-block  0
branch  0 never executed
branch  1 never executed
    #####: 1804:      STBI_FREE(data);
    #####: 1805:      return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 1805-block  0
        -: 1806:   }
        -: 1807:
    #####: 1808:   for (j=0; j < (int) y; ++j) {
    %%%%%: 1808-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1808-block  1
    #####: 1809:      stbi__uint16 *src  = data + j * x * img_n   ;
    #####: 1810:      stbi__uint16 *dest = good + j * x * req_comp;
        -: 1811:
        -: 1812:      #define STBI__COMBO(a,b)  ((a)*8+(b))
        -: 1813:      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
        -: 1814:      // convert source image with img_n components to one with req_comp components;
        -: 1815:      // avoid switch per pixel, so use switch per scanline and massive macros
    #####: 1816:      switch (STBI__COMBO(img_n, req_comp)) {
    %%%%%: 1816-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
    #####: 1817:         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
    %%%%%: 1817-block  0
    %%%%%: 1817-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1817-block  2
    #####: 1818:         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
    %%%%%: 1818-block  0
    %%%%%: 1818-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1818-block  2
    #####: 1819:         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
    %%%%%: 1819-block  0
    %%%%%: 1819-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1819-block  2
    #####: 1820:         STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
    %%%%%: 1820-block  0
    %%%%%: 1820-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1820-block  2
    #####: 1821:         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
    %%%%%: 1821-block  0
    %%%%%: 1821-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1821-block  2
    #####: 1822:         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
    %%%%%: 1822-block  0
    %%%%%: 1822-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1822-block  2
    #####: 1823:         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
    %%%%%: 1823-block  0
    %%%%%: 1823-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1823-block  2
    #####: 1824:         STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
    %%%%%: 1824-block  0
    %%%%%: 1824-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1824-block  2
    #####: 1825:         STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
    %%%%%: 1825-block  0
    %%%%%: 1825-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1825-block  2
    #####: 1826:         STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
    %%%%%: 1826-block  0
    %%%%%: 1826-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1826-block  2
    #####: 1827:         STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
    %%%%%: 1827-block  0
    %%%%%: 1827-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1827-block  2
    #####: 1828:         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
    %%%%%: 1828-block  0
    %%%%%: 1828-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 1828-block  2
    #####: 1829:         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
    %%%%%: 1829-block  0
call    0 never executed
        -: 1830:      }
        -: 1831:      #undef STBI__CASE
        -: 1832:   }
        -: 1833:
    #####: 1834:   STBI_FREE(data);
    #####: 1835:   return good;
    %%%%%: 1835-block  0
        -: 1836:}
        -: 1837:#endif
        -: 1838:
        -: 1839:#ifndef STBI_NO_LINEAR
function _ZL16stbi__ldr_to_hdrPhiii called 0 returned 0% blocks executed 0%
    #####: 1840:static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
        -: 1841:{
        -: 1842:   int i,k,n;
        -: 1843:   float *output;
    #####: 1844:   if (!data) return NULL;
    %%%%%: 1844-block  0
branch  0 never executed
branch  1 never executed
    #####: 1845:   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
    %%%%%: 1845-block  0
call    0 never executed
    #####: 1846:   if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
branch  0 never executed
branch  1 never executed
    %%%%%: 1846-block  0
        -: 1847:   // compute number of non-alpha components
    #####: 1848:   if (comp & 1) n = comp; else n = comp-1;
    %%%%%: 1848-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1848-block  1
    #####: 1849:   for (i=0; i < x*y; ++i) {
    %%%%%: 1849-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1849-block  1
    #####: 1850:      for (k=0; k < n; ++k) {
    %%%%%: 1850-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1850-block  1
    #####: 1851:         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
    %%%%%: 1851-block  0
        -: 1852:      }
        -: 1853:   }
    #####: 1854:   if (n < comp) {
    %%%%%: 1854-block  0
branch  0 never executed
branch  1 never executed
    #####: 1855:      for (i=0; i < x*y; ++i) {
    %%%%%: 1855-block  0
branch  0 never executed
branch  1 never executed
    #####: 1856:         output[i*comp + n] = data[i*comp + n]/255.0f;
    %%%%%: 1856-block  0
        -: 1857:      }
        -: 1858:   }
    #####: 1859:   STBI_FREE(data);
    #####: 1860:   return output;
    %%%%%: 1860-block  0
        -: 1861:}
        -: 1862:#endif
        -: 1863:
        -: 1864:#ifndef STBI_NO_HDR
        -: 1865:#define stbi__float2int(x)   ((int) (x))
function _ZL16stbi__hdr_to_ldrPfiii called 0 returned 0% blocks executed 0%
    #####: 1866:static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
        -: 1867:{
        -: 1868:   int i,k,n;
        -: 1869:   stbi_uc *output;
    #####: 1870:   if (!data) return NULL;
    %%%%%: 1870-block  0
branch  0 never executed
branch  1 never executed
    #####: 1871:   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
    %%%%%: 1871-block  0
call    0 never executed
    #####: 1872:   if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
branch  0 never executed
branch  1 never executed
    %%%%%: 1872-block  0
        -: 1873:   // compute number of non-alpha components
    #####: 1874:   if (comp & 1) n = comp; else n = comp-1;
    %%%%%: 1874-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1874-block  1
    #####: 1875:   for (i=0; i < x*y; ++i) {
    %%%%%: 1875-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1875-block  1
    #####: 1876:      for (k=0; k < n; ++k) {
    %%%%%: 1876-block  0
branch  0 never executed
branch  1 never executed
    #####: 1877:         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
    %%%%%: 1877-block  0
branch  0 never executed
branch  1 never executed
    #####: 1878:         if (z < 0) z = 0;
    %%%%%: 1878-block  0
branch  0 never executed
branch  1 never executed
    #####: 1879:         if (z > 255) z = 255;
    %%%%%: 1879-block  0
branch  0 never executed
branch  1 never executed
    #####: 1880:         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
    %%%%%: 1880-block  0
        -: 1881:      }
    #####: 1882:      if (k < comp) {
    %%%%%: 1882-block  0
branch  0 never executed
branch  1 never executed
    #####: 1883:         float z = data[i*comp+k] * 255 + 0.5f;
    #####: 1884:         if (z < 0) z = 0;
    %%%%%: 1884-block  0
branch  0 never executed
branch  1 never executed
    #####: 1885:         if (z > 255) z = 255;
    %%%%%: 1885-block  0
branch  0 never executed
branch  1 never executed
    #####: 1886:         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
    %%%%%: 1886-block  0
        -: 1887:      }
        -: 1888:   }
    #####: 1889:   STBI_FREE(data);
    #####: 1890:   return output;
    %%%%%: 1890-block  0
        -: 1891:}
        -: 1892:#endif
        -: 1893:
        -: 1894://////////////////////////////////////////////////////////////////////////////
        -: 1895://
        -: 1896://  "baseline" JPEG/JFIF decoder
        -: 1897://
        -: 1898://    simple implementation
        -: 1899://      - doesn't support delayed output of y-dimension
        -: 1900://      - simple interface (only one output format: 8-bit interleaved RGB)
        -: 1901://      - doesn't try to recover corrupt jpegs
        -: 1902://      - doesn't allow partial loading, loading multiple at once
        -: 1903://      - still fast on x86 (copying globals into locals doesn't help x86)
        -: 1904://      - allocates lots of intermediate memory (full size of all components)
        -: 1905://        - non-interleaved case requires this anyway
        -: 1906://        - allows good upsampling (see next)
        -: 1907://    high-quality
        -: 1908://      - upsampled channels are bilinearly interpolated, even across blocks
        -: 1909://      - quality integer IDCT derived from IJG's 'slow'
        -: 1910://    performance
        -: 1911://      - fast huffman; reasonable integer IDCT
        -: 1912://      - some SIMD kernels for common paths on targets with SSE2/NEON
        -: 1913://      - uses a lot of intermediate memory, could cache poorly
        -: 1914:
        -: 1915:#ifndef STBI_NO_JPEG
        -: 1916:
        -: 1917:// huffman decoding acceleration
        -: 1918:#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
        -: 1919:
        -: 1920:typedef struct
        -: 1921:{
        -: 1922:   stbi_uc  fast[1 << FAST_BITS];
        -: 1923:   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
        -: 1924:   stbi__uint16 code[256];
        -: 1925:   stbi_uc  values[256];
        -: 1926:   stbi_uc  size[257];
        -: 1927:   unsigned int maxcode[18];
        -: 1928:   int    delta[17];   // old 'firstsymbol' - old 'firstcode'
        -: 1929:} stbi__huffman;
        -: 1930:
        -: 1931:typedef struct
        -: 1932:{
        -: 1933:   stbi__context *s;
        -: 1934:   stbi__huffman huff_dc[4];
        -: 1935:   stbi__huffman huff_ac[4];
        -: 1936:   stbi__uint16 dequant[4][64];
        -: 1937:   stbi__int16 fast_ac[4][1 << FAST_BITS];
        -: 1938:
        -: 1939:// sizes for components, interleaved MCUs
        -: 1940:   int img_h_max, img_v_max;
        -: 1941:   int img_mcu_x, img_mcu_y;
        -: 1942:   int img_mcu_w, img_mcu_h;
        -: 1943:
        -: 1944:// definition of jpeg image component
        -: 1945:   struct
        -: 1946:   {
        -: 1947:      int id;
        -: 1948:      int h,v;
        -: 1949:      int tq;
        -: 1950:      int hd,ha;
        -: 1951:      int dc_pred;
        -: 1952:
        -: 1953:      int x,y,w2,h2;
        -: 1954:      stbi_uc *data;
        -: 1955:      void *raw_data, *raw_coeff;
        -: 1956:      stbi_uc *linebuf;
        -: 1957:      short   *coeff;   // progressive only
        -: 1958:      int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
        -: 1959:   } img_comp[4];
        -: 1960:
        -: 1961:   stbi__uint32   code_buffer; // jpeg entropy-coded buffer
        -: 1962:   int            code_bits;   // number of valid bits
        -: 1963:   unsigned char  marker;      // marker seen while filling entropy buffer
        -: 1964:   int            nomore;      // flag if we saw a marker so must stop
        -: 1965:
        -: 1966:   int            progressive;
        -: 1967:   int            spec_start;
        -: 1968:   int            spec_end;
        -: 1969:   int            succ_high;
        -: 1970:   int            succ_low;
        -: 1971:   int            eob_run;
        -: 1972:   int            jfif;
        -: 1973:   int            app14_color_transform; // Adobe APP14 tag
        -: 1974:   int            rgb;
        -: 1975:
        -: 1976:   int scan_n, order[4];
        -: 1977:   int restart_interval, todo;
        -: 1978:
        -: 1979:// kernels
        -: 1980:   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
        -: 1981:   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
        -: 1982:   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
        -: 1983:} stbi__jpeg;
        -: 1984:
function _ZL19stbi__build_huffmanP13stbi__huffmanPi called 0 returned 0% blocks executed 0%
    #####: 1985:static int stbi__build_huffman(stbi__huffman *h, int *count)
    %%%%%: 1985-block  0
        -: 1986:{
        -: 1987:   int i,j,k=0;
        -: 1988:   unsigned int code;
        -: 1989:   // build size list for each symbol (from JPEG spec)
    #####: 1990:   for (i=0; i < 16; ++i)
    %%%%%: 1990-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 1990-block  1
    #####: 1991:      for (j=0; j < count[i]; ++j)
    %%%%%: 1991-block  0
branch  0 never executed
branch  1 never executed
    #####: 1992:         h->size[k++] = (stbi_uc) (i+1);
    %%%%%: 1992-block  0
    #####: 1993:   h->size[k] = 0;
    %%%%%: 1993-block  0
        -: 1994:
        -: 1995:   // compute actual symbols (from jpeg spec)
        -: 1996:   code = 0;
        -: 1997:   k = 0;
    #####: 1998:   for(j=1; j <= 16; ++j) {
    %%%%%: 1998-block  0
branch  0 never executed
branch  1 never executed
        -: 1999:      // compute delta to add to code to compute symbol id
    #####: 2000:      h->delta[j] = k - code;
    #####: 2001:      if (h->size[k] == j) {
    %%%%%: 2001-block  0
branch  0 never executed
branch  1 never executed
    #####: 2002:         while (h->size[k] == j)
    %%%%%: 2002-block  0
branch  0 never executed
branch  1 never executed
    #####: 2003:            h->code[k++] = (stbi__uint16) (code++);
    %%%%%: 2003-block  0
    #####: 2004:         if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
    %%%%%: 2004-block  0
branch  0 never executed
branch  1 never executed
        -: 2005:      }
        -: 2006:      // compute largest code + 1 for this size, preshifted as needed later
    #####: 2007:      h->maxcode[j] = code << (16-j);
    #####: 2008:      code <<= 1;
    %%%%%: 2008-block  0
        -: 2009:   }
    #####: 2010:   h->maxcode[j] = 0xffffffff;
        -: 2011:
        -: 2012:   // build non-spec acceleration table; 255 is flag for not-accelerated
    #####: 2013:   memset(h->fast, 255, 1 << FAST_BITS);
    %%%%%: 2013-block  0
    #####: 2014:   for (i=0; i < k; ++i) {
    %%%%%: 2014-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2014-block  1
    #####: 2015:      int s = h->size[i];
    #####: 2016:      if (s <= FAST_BITS) {
    %%%%%: 2016-block  0
branch  0 never executed
branch  1 never executed
    #####: 2017:         int c = h->code[i] << (FAST_BITS-s);
    #####: 2018:         int m = 1 << (FAST_BITS-s);
    %%%%%: 2018-block  0
    #####: 2019:         for (j=0; j < m; ++j) {
    %%%%%: 2019-block  0
branch  0 never executed
branch  1 never executed
    #####: 2020:            h->fast[c+j] = (stbi_uc) i;
    %%%%%: 2020-block  0
        -: 2021:         }
        -: 2022:      }
        -: 2023:   }
        -: 2024:   return 1;
        -: 2025:}
        -: 2026:
        -: 2027:// build a table that decodes both magnitude and value of small ACs in
        -: 2028:// one go.
function _ZL19stbi__build_fast_acPsP13stbi__huffman called 0 returned 0% blocks executed 0%
    #####: 2029:static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
    %%%%%: 2029-block  0
        -: 2030:{
        -: 2031:   int i;
    #####: 2032:   for (i=0; i < (1 << FAST_BITS); ++i) {
    %%%%%: 2032-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2032-block  1
    #####: 2033:      stbi_uc fast = h->fast[i];
    #####: 2034:      fast_ac[i] = 0;
    #####: 2035:      if (fast < 255) {
    %%%%%: 2035-block  0
branch  0 never executed
branch  1 never executed
    #####: 2036:         int rs = h->values[fast];
    #####: 2037:         int run = (rs >> 4) & 15;
    #####: 2038:         int magbits = rs & 15;
    #####: 2039:         int len = h->size[fast];
        -: 2040:
    #####: 2041:         if (magbits && len + magbits <= FAST_BITS) {
    %%%%%: 2041-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2041-block  1
branch  2 never executed
branch  3 never executed
        -: 2042:            // magnitude code followed by receive_extend code
    #####: 2043:            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
    #####: 2044:            int m = 1 << (magbits - 1);
    #####: 2045:            if (k < m) k += (~0U << magbits) + 1;
    %%%%%: 2045-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2045-block  1
        -: 2046:            // if the result is small enough, we can fit it in fast_ac table
    #####: 2047:            if (k >= -128 && k <= 127)
    %%%%%: 2047-block  0
branch  0 never executed
branch  1 never executed
    #####: 2048:               fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
    %%%%%: 2048-block  0
        -: 2049:         }
        -: 2050:      }
        -: 2051:   }
    #####: 2052:}
        -: 2053:
function _ZL24stbi__grow_buffer_unsafeP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 2054:static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
    %%%%%: 2054-block  0
        -: 2055:{
        -: 2056:   do {
    #####: 2057:      unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
    %%%%%: 2057-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2057-block  1
call    2 never executed
    #####: 2058:      if (b == 0xff) {
branch  0 never executed
branch  1 never executed
    #####: 2059:         int c = stbi__get8(j->s);
    %%%%%: 2059-block  0
call    0 never executed
    #####: 2060:         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
    %%%%%: 2060-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2060-block  1
call    2 never executed
    #####: 2061:         if (c != 0) {
    %%%%%: 2061-block  0
branch  0 never executed
branch  1 never executed
    #####: 2062:            j->marker = (unsigned char) c;
    #####: 2063:            j->nomore = 1;
    #####: 2064:            return;
    %%%%%: 2064-block  0
        -: 2065:         }
        -: 2066:      }
    #####: 2067:      j->code_buffer |= b << (24 - j->code_bits);
    #####: 2068:      j->code_bits += 8;
    #####: 2069:   } while (j->code_bits <= 24);
    %%%%%: 2069-block  0
branch  0 never executed
branch  1 never executed
        -: 2070:}
        -: 2071:
        -: 2072:// (1 << n) - 1
        -: 2073:static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
        -: 2074:
        -: 2075:// decode a jpeg huffman value from the bitstream
function _ZL22stbi__jpeg_huff_decodeP10stbi__jpegP13stbi__huffman called 0 returned 0% blocks executed 0%
    #####: 2076:stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
        -: 2077:{
        -: 2078:   unsigned int temp;
        -: 2079:   int c,k;
        -: 2080:
    #####: 2081:   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
    %%%%%: 2081-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2081-block  1
call    2 never executed
        -: 2082:
        -: 2083:   // look at the top FAST_BITS and determine what symbol ID it is,
        -: 2084:   // if the code is <= FAST_BITS
    #####: 2085:   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
    #####: 2086:   k = h->fast[c];
    #####: 2087:   if (k < 255) {
    %%%%%: 2087-block  0
branch  0 never executed
branch  1 never executed
    #####: 2088:      int s = h->size[k];
    #####: 2089:      if (s > j->code_bits)
    %%%%%: 2089-block  0
branch  0 never executed
branch  1 never executed
        -: 2090:         return -1;
    #####: 2091:      j->code_buffer <<= s;
    #####: 2092:      j->code_bits -= s;
    #####: 2093:      return h->values[k];
    %%%%%: 2093-block  0
        -: 2094:   }
        -: 2095:
        -: 2096:   // naive test is to shift the code_buffer down so k bits are
        -: 2097:   // valid, then test against maxcode. To speed this up, we've
        -: 2098:   // preshifted maxcode left so that it has (16-k) 0s at the
        -: 2099:   // end; in other words, regardless of the number of bits, it
        -: 2100:   // wants to be compared against something shifted to have 16;
        -: 2101:   // that way we don't need to shift inside the loop.
    #####: 2102:   temp = j->code_buffer >> 16;
    %%%%%: 2102-block  0
    #####: 2103:   for (k=FAST_BITS+1 ; ; ++k)
    %%%%%: 2103-block  0
    #####: 2104:      if (temp < h->maxcode[k])
    %%%%%: 2104-block  0
branch  0 never executed
branch  1 never executed
        -: 2105:         break;
    #####: 2106:   if (k == 17) {
    %%%%%: 2106-block  0
branch  0 never executed
branch  1 never executed
        -: 2107:      // error! code not found
    #####: 2108:      j->code_bits -= 16;
    #####: 2109:      return -1;
    %%%%%: 2109-block  0
        -: 2110:   }
        -: 2111:
    #####: 2112:   if (k > j->code_bits)
    %%%%%: 2112-block  0
branch  0 never executed
branch  1 never executed
        -: 2113:      return -1;
        -: 2114:
        -: 2115:   // convert the huffman code to the symbol id
    #####: 2116:   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
    #####: 2117:   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
    %%%%%: 2117-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2117-block  1
call    2 never executed
        -: 2118:
        -: 2119:   // convert the id to a symbol
    #####: 2120:   j->code_bits -= k;
    #####: 2121:   j->code_buffer <<= k;
    #####: 2122:   return h->values[c];
    %%%%%: 2122-block  0
        -: 2123:}
        -: 2124:
        -: 2125:// bias[n] = (-1<<n) + 1
        -: 2126:static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};
        -: 2127:
        -: 2128:// combined JPEG 'receive' and JPEG 'extend', since baseline
        -: 2129:// always extends everything it receives.
function _ZL20stbi__extend_receiveP10stbi__jpegi called 0 returned 0% blocks executed 0%
    #####: 2130:stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
        -: 2131:{
        -: 2132:   unsigned int k;
        -: 2133:   int sgn;
    #####: 2134:   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
    %%%%%: 2134-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2134-block  1
call    2 never executed
        -: 2135:
    #####: 2136:   sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
    #####: 2137:   k = stbi_lrot(j->code_buffer, n);
    #####: 2138:   j->code_buffer = k & ~stbi__bmask[n];
    #####: 2139:   k &= stbi__bmask[n];
    #####: 2140:   j->code_bits -= n;
    #####: 2141:   return k + (stbi__jbias[n] & (sgn - 1));
        -: 2142:}
        -: 2143:
        -: 2144:// get some unsigned bits
function _ZL19stbi__jpeg_get_bitsP10stbi__jpegi called 0 returned 0% blocks executed 0%
    #####: 2145:stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
        -: 2146:{
        -: 2147:   unsigned int k;
    #####: 2148:   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
    %%%%%: 2148-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2148-block  1
call    2 never executed
    #####: 2149:   k = stbi_lrot(j->code_buffer, n);
    #####: 2150:   j->code_buffer = k & ~stbi__bmask[n];
    #####: 2151:   k &= stbi__bmask[n];
    #####: 2152:   j->code_bits -= n;
    #####: 2153:   return k;
        -: 2154:}
        -: 2155:
        -: 2156:stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
        -: 2157:{
        -: 2158:   unsigned int k;
    #####: 2159:   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
    %%%%%: 2159-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2159-block  1
call    2 never executed
    %%%%%: 2159-block  2
branch  3 never executed
branch  4 never executed
    %%%%%: 2159-block  3
call    5 never executed
    %%%%%: 2159-block  4
branch  6 never executed
branch  7 never executed
    %%%%%: 2159-block  5
call    8 never executed
    %%%%%: 2159-block  6
branch  9 never executed
branch 10 never executed
    %%%%%: 2159-block  7
call   11 never executed
    #####: 2160:   k = j->code_buffer;
    #####: 2161:   j->code_buffer <<= 1;
    #####: 2162:   --j->code_bits;
    #####: 2163:   return k & 0x80000000;
        -: 2164:}
        -: 2165:
        -: 2166:// given a value that's at position X in the zigzag stream,
        -: 2167:// where does it appear in the 8x8 matrix coded as row-major?
        -: 2168:static const stbi_uc stbi__jpeg_dezigzag[64+15] =
        -: 2169:{
        -: 2170:    0,  1,  8, 16,  9,  2,  3, 10,
        -: 2171:   17, 24, 32, 25, 18, 11,  4,  5,
        -: 2172:   12, 19, 26, 33, 40, 48, 41, 34,
        -: 2173:   27, 20, 13,  6,  7, 14, 21, 28,
        -: 2174:   35, 42, 49, 56, 57, 50, 43, 36,
        -: 2175:   29, 22, 15, 23, 30, 37, 44, 51,
        -: 2176:   58, 59, 52, 45, 38, 31, 39, 46,
        -: 2177:   53, 60, 61, 54, 47, 55, 62, 63,
        -: 2178:   // let corrupt input sample past end
        -: 2179:   63, 63, 63, 63, 63, 63, 63, 63,
        -: 2180:   63, 63, 63, 63, 63, 63, 63
        -: 2181:};
        -: 2182:
        -: 2183:// decode one 64-entry block--
function _ZL23stbi__jpeg_decode_blockP10stbi__jpegPsP13stbi__huffmanS3_S1_iPt called 0 returned 0% blocks executed 0%
    #####: 2184:static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
        -: 2185:{
        -: 2186:   int diff,dc,k;
        -: 2187:   int t;
        -: 2188:
    #####: 2189:   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
    %%%%%: 2189-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2189-block  1
call    2 never executed
    #####: 2190:   t = stbi__jpeg_huff_decode(j, hdc);
    %%%%%: 2190-block  0
call    0 never executed
    #####: 2191:   if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");
branch  0 never executed
branch  1 never executed
        -: 2192:
        -: 2193:   // 0 all the ac values now so we can do it 32-bits at a time
        -: 2194:   memset(data,0,64*sizeof(data[0]));
        -: 2195:
    #####: 2196:   diff = t ? stbi__extend_receive(j, t) : 0;
    %%%%%: 2196-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2196-block  1
call    2 never executed
    #####: 2197:   dc = j->img_comp[b].dc_pred + diff;
    #####: 2198:   j->img_comp[b].dc_pred = dc;
    #####: 2199:   data[0] = (short) (dc * dequant[0]);
    %%%%%: 2199-block  0
        -: 2200:
        -: 2201:   // decode AC components, see JPEG spec
        -: 2202:   k = 1;
        -: 2203:   do {
        -: 2204:      unsigned int zig;
        -: 2205:      int c,r,s;
    #####: 2206:      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
    %%%%%: 2206-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2206-block  1
call    2 never executed
    #####: 2207:      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
    #####: 2208:      r = fac[c];
    #####: 2209:      if (r) { // fast-AC path
    %%%%%: 2209-block  0
branch  0 never executed
branch  1 never executed
    #####: 2210:         k += (r >> 4) & 15; // run
    #####: 2211:         s = r & 15; // combined length
    #####: 2212:         j->code_buffer <<= s;
    #####: 2213:         j->code_bits -= s;
        -: 2214:         // decode into unzigzag'd location
    #####: 2215:         zig = stbi__jpeg_dezigzag[k++];
    #####: 2216:         data[zig] = (short) ((r >> 8) * dequant[zig]);
    %%%%%: 2216-block  0
        -: 2217:      } else {
    #####: 2218:         int rs = stbi__jpeg_huff_decode(j, hac);
    %%%%%: 2218-block  0
call    0 never executed
    #####: 2219:         if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
branch  0 never executed
branch  1 never executed
    #####: 2220:         s = rs & 15;
    #####: 2221:         r = rs >> 4;
    #####: 2222:         if (s == 0) {
    %%%%%: 2222-block  0
branch  0 never executed
branch  1 never executed
    #####: 2223:            if (rs != 0xf0) break; // end block
    %%%%%: 2223-block  0
branch  0 never executed
branch  1 never executed
    #####: 2224:            k += 16;
    %%%%%: 2224-block  0
        -: 2225:         } else {
    #####: 2226:            k += r;
        -: 2227:            // decode into unzigzag'd location
    #####: 2228:            zig = stbi__jpeg_dezigzag[k++];
    #####: 2229:            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
    %%%%%: 2229-block  0
call    0 never executed
        -: 2230:         }
        -: 2231:      }
    #####: 2232:   } while (k < 64);
    %%%%%: 2232-block  0
branch  0 never executed
branch  1 never executed
        -: 2233:   return 1;
        -: 2234:}
        -: 2235:
function _ZL31stbi__jpeg_decode_block_prog_dcP10stbi__jpegPsP13stbi__huffmani called 0 returned 0% blocks executed 0%
    #####: 2236:static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
        -: 2237:{
        -: 2238:   int diff,dc;
        -: 2239:   int t;
    #####: 2240:   if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
    %%%%%: 2240-block  0
branch  0 never executed
branch  1 never executed
        -: 2241:
    #####: 2242:   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
    %%%%%: 2242-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2242-block  1
call    2 never executed
        -: 2243:
    #####: 2244:   if (j->succ_high == 0) {
    %%%%%: 2244-block  0
branch  0 never executed
branch  1 never executed
        -: 2245:      // first scan for DC coefficient, must be first
        -: 2246:      memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
    #####: 2247:      t = stbi__jpeg_huff_decode(j, hdc);
    %%%%%: 2247-block  0
call    0 never executed
    #####: 2248:      if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
branch  0 never executed
branch  1 never executed
    #####: 2249:      diff = t ? stbi__extend_receive(j, t) : 0;
    %%%%%: 2249-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2249-block  1
call    2 never executed
        -: 2250:
    #####: 2251:      dc = j->img_comp[b].dc_pred + diff;
    #####: 2252:      j->img_comp[b].dc_pred = dc;
    #####: 2253:      data[0] = (short) (dc * (1 << j->succ_low));
    %%%%%: 2253-block  0
        -: 2254:   } else {
        -: 2255:      // refinement scan for DC coefficient
    #####: 2256:      if (stbi__jpeg_get_bit(j))
    %%%%%: 2256-block  0
branch  0 never executed
branch  1 never executed
    #####: 2257:         data[0] += (short) (1 << j->succ_low);
    %%%%%: 2257-block  0
        -: 2258:   }
        -: 2259:   return 1;
        -: 2260:}
        -: 2261:
        -: 2262:// @OPTIMIZE: store non-zigzagged during the decode passes,
        -: 2263:// and only de-zigzag when dequantizing
function _ZL31stbi__jpeg_decode_block_prog_acP10stbi__jpegPsP13stbi__huffmanS1_ called 0 returned 0% blocks executed 0%
    #####: 2264:static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
        -: 2265:{
        -: 2266:   int k;
    #####: 2267:   if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
    %%%%%: 2267-block  0
branch  0 never executed
branch  1 never executed
        -: 2268:
    #####: 2269:   if (j->succ_high == 0) {
    %%%%%: 2269-block  0
branch  0 never executed
branch  1 never executed
    #####: 2270:      int shift = j->succ_low;
        -: 2271:
    #####: 2272:      if (j->eob_run) {
    %%%%%: 2272-block  0
branch  0 never executed
branch  1 never executed
    #####: 2273:         --j->eob_run;
    #####: 2274:         return 1;
    %%%%%: 2274-block  0
        -: 2275:      }
        -: 2276:
        -: 2277:      k = j->spec_start;
        -: 2278:      do {
        -: 2279:         unsigned int zig;
        -: 2280:         int c,r,s;
    #####: 2281:         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
    %%%%%: 2281-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2281-block  1
call    2 never executed
    #####: 2282:         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
    #####: 2283:         r = fac[c];
    #####: 2284:         if (r) { // fast-AC path
    %%%%%: 2284-block  0
branch  0 never executed
branch  1 never executed
    #####: 2285:            k += (r >> 4) & 15; // run
    #####: 2286:            s = r & 15; // combined length
    #####: 2287:            j->code_buffer <<= s;
    #####: 2288:            j->code_bits -= s;
    #####: 2289:            zig = stbi__jpeg_dezigzag[k++];
    #####: 2290:            data[zig] = (short) ((r >> 8) * (1 << shift));
    %%%%%: 2290-block  0
        -: 2291:         } else {
    #####: 2292:            int rs = stbi__jpeg_huff_decode(j, hac);
    %%%%%: 2292-block  0
call    0 never executed
    #####: 2293:            if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
branch  0 never executed
branch  1 never executed
    #####: 2294:            s = rs & 15;
    #####: 2295:            r = rs >> 4;
    #####: 2296:            if (s == 0) {
    %%%%%: 2296-block  0
branch  0 never executed
branch  1 never executed
    #####: 2297:               if (r < 15) {
    %%%%%: 2297-block  0
branch  0 never executed
branch  1 never executed
    #####: 2298:                  j->eob_run = (1 << r);
    #####: 2299:                  if (r)
    %%%%%: 2299-block  0
branch  0 never executed
branch  1 never executed
    #####: 2300:                     j->eob_run += stbi__jpeg_get_bits(j, r);
    %%%%%: 2300-block  0
call    0 never executed
    #####: 2301:                  --j->eob_run;
    #####: 2302:                  break;
    %%%%%: 2302-block  0
        -: 2303:               }
    #####: 2304:               k += 16;
    %%%%%: 2304-block  0
        -: 2305:            } else {
    #####: 2306:               k += r;
    #####: 2307:               zig = stbi__jpeg_dezigzag[k++];
    #####: 2308:               data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
    %%%%%: 2308-block  0
call    0 never executed
        -: 2309:            }
        -: 2310:         }
    #####: 2311:      } while (k <= j->spec_end);
    %%%%%: 2311-block  0
branch  0 never executed
branch  1 never executed
        -: 2312:   } else {
        -: 2313:      // refinement scan for these AC coefficients
        -: 2314:
    #####: 2315:      short bit = (short) (1 << j->succ_low);
        -: 2316:
    #####: 2317:      if (j->eob_run) {
    %%%%%: 2317-block  0
branch  0 never executed
branch  1 never executed
    #####: 2318:         --j->eob_run;
    %%%%%: 2318-block  0
    #####: 2319:         for (k = j->spec_start; k <= j->spec_end; ++k) {
    %%%%%: 2319-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2319-block  1
    #####: 2320:            short *p = &data[stbi__jpeg_dezigzag[k]];
    #####: 2321:            if (*p != 0)
    %%%%%: 2321-block  0
branch  0 never executed
branch  1 never executed
    #####: 2322:               if (stbi__jpeg_get_bit(j))
    %%%%%: 2322-block  0
branch  0 never executed
branch  1 never executed
    #####: 2323:                  if ((*p & bit)==0) {
    %%%%%: 2323-block  0
branch  0 never executed
branch  1 never executed
    #####: 2324:                     if (*p > 0)
    %%%%%: 2324-block  0
branch  0 never executed
branch  1 never executed
    #####: 2325:                        *p += bit;
    %%%%%: 2325-block  0
        -: 2326:                     else
    #####: 2327:                        *p -= bit;
    %%%%%: 2327-block  0
        -: 2328:                  }
        -: 2329:         }
        -: 2330:      } else {
        -: 2331:         k = j->spec_start;
        -: 2332:         do {
        -: 2333:            int r,s;
    #####: 2334:            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
    %%%%%: 2334-block  0
call    0 never executed
    #####: 2335:            if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
branch  0 never executed
branch  1 never executed
    #####: 2336:            s = rs & 15;
    #####: 2337:            r = rs >> 4;
    #####: 2338:            if (s == 0) {
    %%%%%: 2338-block  0
branch  0 never executed
branch  1 never executed
    #####: 2339:               if (r < 15) {
    %%%%%: 2339-block  0
branch  0 never executed
branch  1 never executed
    #####: 2340:                  j->eob_run = (1 << r) - 1;
    #####: 2341:                  if (r)
    %%%%%: 2341-block  0
branch  0 never executed
branch  1 never executed
    #####: 2342:                     j->eob_run += stbi__jpeg_get_bits(j, r);
    %%%%%: 2342-block  0
call    0 never executed
        -: 2343:                  r = 64; // force end of block
        -: 2344:               } else {
        -: 2345:                  // r=15 s=0 should write 16 0s, so we just do
        -: 2346:                  // a run of 15 0s and then write s (which is 0),
        -: 2347:                  // so we don't have to do anything special here
        -: 2348:               }
        -: 2349:            } else {
    #####: 2350:               if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
    %%%%%: 2350-block  0
branch  0 never executed
branch  1 never executed
        -: 2351:               // sign bit
    #####: 2352:               if (stbi__jpeg_get_bit(j))
    %%%%%: 2352-block  0
branch  0 never executed
branch  1 never executed
    #####: 2353:                  s = bit;
    %%%%%: 2353-block  0
        -: 2354:               else
    #####: 2355:                  s = -bit;
    %%%%%: 2355-block  0
        -: 2356:            }
        -: 2357:
        -: 2358:            // advance by r
    #####: 2359:            while (k <= j->spec_end) {
    %%%%%: 2359-block  0
branch  0 never executed
branch  1 never executed
    #####: 2360:               short *p = &data[stbi__jpeg_dezigzag[k++]];
    #####: 2361:               if (*p != 0) {
    %%%%%: 2361-block  0
branch  0 never executed
branch  1 never executed
    #####: 2362:                  if (stbi__jpeg_get_bit(j))
    %%%%%: 2362-block  0
branch  0 never executed
branch  1 never executed
    #####: 2363:                     if ((*p & bit)==0) {
    %%%%%: 2363-block  0
branch  0 never executed
branch  1 never executed
    #####: 2364:                        if (*p > 0)
    %%%%%: 2364-block  0
branch  0 never executed
branch  1 never executed
    #####: 2365:                           *p += bit;
    %%%%%: 2365-block  0
        -: 2366:                        else
    #####: 2367:                           *p -= bit;
    %%%%%: 2367-block  0
        -: 2368:                     }
        -: 2369:               } else {
    #####: 2370:                  if (r == 0) {
    %%%%%: 2370-block  0
branch  0 never executed
branch  1 never executed
    #####: 2371:                     *p = (short) s;
    #####: 2372:                     break;
    %%%%%: 2372-block  0
        -: 2373:                  }
    #####: 2374:                  --r;
    %%%%%: 2374-block  0
        -: 2375:               }
        -: 2376:            }
    #####: 2377:         } while (k <= j->spec_end);
    %%%%%: 2377-block  0
branch  0 never executed
branch  1 never executed
        -: 2378:      }
        -: 2379:   }
        -: 2380:   return 1;
        -: 2381:}
        -: 2382:
        -: 2383:// take a -128..127 value and stbi__clamp it and convert to 0..255
        -: 2384:stbi_inline static stbi_uc stbi__clamp(int x)
        -: 2385:{
        -: 2386:   // trick to use a single test to catch both cases
        -: 2387:   if ((unsigned int) x > 255) {
        -: 2388:      if (x < 0) return 0;
        -: 2389:      if (x > 255) return 255;
        -: 2390:   }
        -: 2391:   return (stbi_uc) x;
        -: 2392:}
        -: 2393:
        -: 2394:#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
        -: 2395:#define stbi__fsh(x)  ((x) * 4096)
        -: 2396:
        -: 2397:// derived from jidctint -- DCT_ISLOW
        -: 2398:#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
        -: 2399:   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
        -: 2400:   p2 = s2;                                    \
        -: 2401:   p3 = s6;                                    \
        -: 2402:   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
        -: 2403:   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
        -: 2404:   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
        -: 2405:   p2 = s0;                                    \
        -: 2406:   p3 = s4;                                    \
        -: 2407:   t0 = stbi__fsh(p2+p3);                      \
        -: 2408:   t1 = stbi__fsh(p2-p3);                      \
        -: 2409:   x0 = t0+t3;                                 \
        -: 2410:   x3 = t0-t3;                                 \
        -: 2411:   x1 = t1+t2;                                 \
        -: 2412:   x2 = t1-t2;                                 \
        -: 2413:   t0 = s7;                                    \
        -: 2414:   t1 = s5;                                    \
        -: 2415:   t2 = s3;                                    \
        -: 2416:   t3 = s1;                                    \
        -: 2417:   p3 = t0+t2;                                 \
        -: 2418:   p4 = t1+t3;                                 \
        -: 2419:   p1 = t0+t3;                                 \
        -: 2420:   p2 = t1+t2;                                 \
        -: 2421:   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
        -: 2422:   t0 = t0*stbi__f2f( 0.298631336f);           \
        -: 2423:   t1 = t1*stbi__f2f( 2.053119869f);           \
        -: 2424:   t2 = t2*stbi__f2f( 3.072711026f);           \
        -: 2425:   t3 = t3*stbi__f2f( 1.501321110f);           \
        -: 2426:   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
        -: 2427:   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
        -: 2428:   p3 = p3*stbi__f2f(-1.961570560f);           \
        -: 2429:   p4 = p4*stbi__f2f(-0.390180644f);           \
        -: 2430:   t3 += p1+p4;                                \
        -: 2431:   t2 += p2+p3;                                \
        -: 2432:   t1 += p2+p4;                                \
        -: 2433:   t0 += p1+p3;
        -: 2434:
        -: 2435:static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
        -: 2436:{
        -: 2437:   int i,val[64],*v=val;
        -: 2438:   stbi_uc *o;
        -: 2439:   short *d = data;
        -: 2440:
        -: 2441:   // columns
        -: 2442:   for (i=0; i < 8; ++i,++d, ++v) {
        -: 2443:      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
        -: 2444:      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
        -: 2445:           && d[40]==0 && d[48]==0 && d[56]==0) {
        -: 2446:         //    no shortcut                 0     seconds
        -: 2447:         //    (1|2|3|4|5|6|7)==0          0     seconds
        -: 2448:         //    all separate               -0.047 seconds
        -: 2449:         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
        -: 2450:         int dcterm = d[0]*4;
        -: 2451:         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
        -: 2452:      } else {
        -: 2453:         STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
        -: 2454:         // constants scaled things up by 1<<12; let's bring them back
        -: 2455:         // down, but keep 2 extra bits of precision
        -: 2456:         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
        -: 2457:         v[ 0] = (x0+t3) >> 10;
        -: 2458:         v[56] = (x0-t3) >> 10;
        -: 2459:         v[ 8] = (x1+t2) >> 10;
        -: 2460:         v[48] = (x1-t2) >> 10;
        -: 2461:         v[16] = (x2+t1) >> 10;
        -: 2462:         v[40] = (x2-t1) >> 10;
        -: 2463:         v[24] = (x3+t0) >> 10;
        -: 2464:         v[32] = (x3-t0) >> 10;
        -: 2465:      }
        -: 2466:   }
        -: 2467:
        -: 2468:   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
        -: 2469:      // no fast case since the first 1D IDCT spread components out
        -: 2470:      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
        -: 2471:      // constants scaled things up by 1<<12, plus we had 1<<2 from first
        -: 2472:      // loop, plus horizontal and vertical each scale by sqrt(8) so together
        -: 2473:      // we've got an extra 1<<3, so 1<<17 total we need to remove.
        -: 2474:      // so we want to round that, which means adding 0.5 * 1<<17,
        -: 2475:      // aka 65536. Also, we'll end up with -128 to 127 that we want
        -: 2476:      // to encode as 0..255 by adding 128, so we'll add that before the shift
        -: 2477:      x0 += 65536 + (128<<17);
        -: 2478:      x1 += 65536 + (128<<17);
        -: 2479:      x2 += 65536 + (128<<17);
        -: 2480:      x3 += 65536 + (128<<17);
        -: 2481:      // tried computing the shifts into temps, or'ing the temps to see
        -: 2482:      // if any were out of range, but that was slower
        -: 2483:      o[0] = stbi__clamp((x0+t3) >> 17);
        -: 2484:      o[7] = stbi__clamp((x0-t3) >> 17);
        -: 2485:      o[1] = stbi__clamp((x1+t2) >> 17);
        -: 2486:      o[6] = stbi__clamp((x1-t2) >> 17);
        -: 2487:      o[2] = stbi__clamp((x2+t1) >> 17);
        -: 2488:      o[5] = stbi__clamp((x2-t1) >> 17);
        -: 2489:      o[3] = stbi__clamp((x3+t0) >> 17);
        -: 2490:      o[4] = stbi__clamp((x3-t0) >> 17);
        -: 2491:   }
        -: 2492:}
        -: 2493:
        -: 2494:#ifdef STBI_SSE2
        -: 2495:// sse2 integer IDCT. not the fastest possible implementation but it
        -: 2496:// produces bit-identical results to the generic C version so it's
        -: 2497:// fully "transparent".
function _ZL15stbi__idct_simdPhiPs called 0 returned 0% blocks executed 0%
    #####: 2498:static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
    %%%%%: 2498-block  0
call    0 never executed
        -: 2499:{
        -: 2500:   // This is constructed to match our regular (generic) integer IDCT exactly.
        -: 2501:   __m128i row0, row1, row2, row3, row4, row5, row6, row7;
        -: 2502:   __m128i tmp;
        -: 2503:
        -: 2504:   // dot product constant: even elems=x, odd elems=y
        -: 2505:   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
        -: 2506:
        -: 2507:   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
        -: 2508:   // out(1) = c1[even]*x + c1[odd]*y
        -: 2509:   #define dct_rot(out0,out1, x,y,c0,c1) \
        -: 2510:      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
        -: 2511:      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
        -: 2512:      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
        -: 2513:      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
        -: 2514:      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
        -: 2515:      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
        -: 2516:
        -: 2517:   // out = in << 12  (in 16-bit, out 32-bit)
        -: 2518:   #define dct_widen(out, in) \
        -: 2519:      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
        -: 2520:      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
        -: 2521:
        -: 2522:   // wide add
        -: 2523:   #define dct_wadd(out, a, b) \
        -: 2524:      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
        -: 2525:      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
        -: 2526:
        -: 2527:   // wide sub
        -: 2528:   #define dct_wsub(out, a, b) \
        -: 2529:      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
        -: 2530:      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
        -: 2531:
        -: 2532:   // butterfly a/b, add bias, then shift by "s" and pack
        -: 2533:   #define dct_bfly32o(out0, out1, a,b,bias,s) \
        -: 2534:      { \
        -: 2535:         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
        -: 2536:         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
        -: 2537:         dct_wadd(sum, abiased, b); \
        -: 2538:         dct_wsub(dif, abiased, b); \
        -: 2539:         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
        -: 2540:         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
        -: 2541:      }
        -: 2542:
        -: 2543:   // 8-bit interleave step (for transposes)
        -: 2544:   #define dct_interleave8(a, b) \
        -: 2545:      tmp = a; \
        -: 2546:      a = _mm_unpacklo_epi8(a, b); \
        -: 2547:      b = _mm_unpackhi_epi8(tmp, b)
        -: 2548:
        -: 2549:   // 16-bit interleave step (for transposes)
        -: 2550:   #define dct_interleave16(a, b) \
        -: 2551:      tmp = a; \
        -: 2552:      a = _mm_unpacklo_epi16(a, b); \
        -: 2553:      b = _mm_unpackhi_epi16(tmp, b)
        -: 2554:
        -: 2555:   #define dct_pass(bias,shift) \
        -: 2556:      { \
        -: 2557:         /* even part */ \
        -: 2558:         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
        -: 2559:         __m128i sum04 = _mm_add_epi16(row0, row4); \
        -: 2560:         __m128i dif04 = _mm_sub_epi16(row0, row4); \
        -: 2561:         dct_widen(t0e, sum04); \
        -: 2562:         dct_widen(t1e, dif04); \
        -: 2563:         dct_wadd(x0, t0e, t3e); \
        -: 2564:         dct_wsub(x3, t0e, t3e); \
        -: 2565:         dct_wadd(x1, t1e, t2e); \
        -: 2566:         dct_wsub(x2, t1e, t2e); \
        -: 2567:         /* odd part */ \
        -: 2568:         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
        -: 2569:         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
        -: 2570:         __m128i sum17 = _mm_add_epi16(row1, row7); \
        -: 2571:         __m128i sum35 = _mm_add_epi16(row3, row5); \
        -: 2572:         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
        -: 2573:         dct_wadd(x4, y0o, y4o); \
        -: 2574:         dct_wadd(x5, y1o, y5o); \
        -: 2575:         dct_wadd(x6, y2o, y5o); \
        -: 2576:         dct_wadd(x7, y3o, y4o); \
        -: 2577:         dct_bfly32o(row0,row7, x0,x7,bias,shift); \
        -: 2578:         dct_bfly32o(row1,row6, x1,x6,bias,shift); \
        -: 2579:         dct_bfly32o(row2,row5, x2,x5,bias,shift); \
        -: 2580:         dct_bfly32o(row3,row4, x3,x4,bias,shift); \
        -: 2581:      }
        -: 2582:
        -: 2583:   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
        -: 2584:   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
        -: 2585:   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
        -: 2586:   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
        -: 2587:   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
        -: 2588:   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
        -: 2589:   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
        -: 2590:   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
        -: 2591:
        -: 2592:   // rounding biases in column/row passes, see stbi__idct_block for explanation.
        -: 2593:   __m128i bias_0 = _mm_set1_epi32(512);
        -: 2594:   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
        -: 2595:
        -: 2596:   // load
        -: 2597:   row0 = _mm_load_si128((const __m128i *) (data + 0*8));
        -: 2598:   row1 = _mm_load_si128((const __m128i *) (data + 1*8));
        -: 2599:   row2 = _mm_load_si128((const __m128i *) (data + 2*8));
        -: 2600:   row3 = _mm_load_si128((const __m128i *) (data + 3*8));
        -: 2601:   row4 = _mm_load_si128((const __m128i *) (data + 4*8));
        -: 2602:   row5 = _mm_load_si128((const __m128i *) (data + 5*8));
        -: 2603:   row6 = _mm_load_si128((const __m128i *) (data + 6*8));
        -: 2604:   row7 = _mm_load_si128((const __m128i *) (data + 7*8));
        -: 2605:
        -: 2606:   // column pass
        -: 2607:   dct_pass(bias_0, 10);
        -: 2608:
        -: 2609:   {
        -: 2610:      // 16bit 8x8 transpose pass 1
        -: 2611:      dct_interleave16(row0, row4);
        -: 2612:      dct_interleave16(row1, row5);
        -: 2613:      dct_interleave16(row2, row6);
        -: 2614:      dct_interleave16(row3, row7);
        -: 2615:
        -: 2616:      // transpose pass 2
        -: 2617:      dct_interleave16(row0, row2);
        -: 2618:      dct_interleave16(row1, row3);
        -: 2619:      dct_interleave16(row4, row6);
        -: 2620:      dct_interleave16(row5, row7);
        -: 2621:
        -: 2622:      // transpose pass 3
        -: 2623:      dct_interleave16(row0, row1);
        -: 2624:      dct_interleave16(row2, row3);
        -: 2625:      dct_interleave16(row4, row5);
        -: 2626:      dct_interleave16(row6, row7);
        -: 2627:   }
        -: 2628:
        -: 2629:   // row pass
        -: 2630:   dct_pass(bias_1, 17);
        -: 2631:
        -: 2632:   {
        -: 2633:      // pack
        -: 2634:      __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
        -: 2635:      __m128i p1 = _mm_packus_epi16(row2, row3);
        -: 2636:      __m128i p2 = _mm_packus_epi16(row4, row5);
        -: 2637:      __m128i p3 = _mm_packus_epi16(row6, row7);
        -: 2638:
        -: 2639:      // 8bit 8x8 transpose pass 1
        -: 2640:      dct_interleave8(p0, p2); // a0e0a1e1...
        -: 2641:      dct_interleave8(p1, p3); // c0g0c1g1...
        -: 2642:
        -: 2643:      // transpose pass 2
        -: 2644:      dct_interleave8(p0, p1); // a0c0e0g0...
        -: 2645:      dct_interleave8(p2, p3); // b0d0f0h0...
        -: 2646:
        -: 2647:      // transpose pass 3
        -: 2648:      dct_interleave8(p0, p2); // a0b0c0d0...
        -: 2649:      dct_interleave8(p1, p3); // a4b4c4d4...
        -: 2650:
        -: 2651:      // store
    #####: 2652:      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
call    0 never executed
    #####: 2653:      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
    #####: 2654:      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
call    0 never executed
    #####: 2655:      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
    #####: 2656:      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
call    0 never executed
    #####: 2657:      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
    #####: 2658:      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
call    0 never executed
        -: 2659:      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
        -: 2660:   }
        -: 2661:
        -: 2662:#undef dct_const
        -: 2663:#undef dct_rot
        -: 2664:#undef dct_widen
        -: 2665:#undef dct_wadd
        -: 2666:#undef dct_wsub
        -: 2667:#undef dct_bfly32o
        -: 2668:#undef dct_interleave8
        -: 2669:#undef dct_interleave16
        -: 2670:#undef dct_pass
    #####: 2671:}
        -: 2672:
        -: 2673:#endif // STBI_SSE2
        -: 2674:
        -: 2675:#ifdef STBI_NEON
        -: 2676:
        -: 2677:// NEON integer IDCT. should produce bit-identical
        -: 2678:// results to the generic C version.
        -: 2679:static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
        -: 2680:{
        -: 2681:   int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;
        -: 2682:
        -: 2683:   int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
        -: 2684:   int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
        -: 2685:   int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
        -: 2686:   int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
        -: 2687:   int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
        -: 2688:   int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
        -: 2689:   int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
        -: 2690:   int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
        -: 2691:   int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
        -: 2692:   int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
        -: 2693:   int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
        -: 2694:   int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));
        -: 2695:
        -: 2696:#define dct_long_mul(out, inq, coeff) \
        -: 2697:   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
        -: 2698:   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)
        -: 2699:
        -: 2700:#define dct_long_mac(out, acc, inq, coeff) \
        -: 2701:   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
        -: 2702:   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)
        -: 2703:
        -: 2704:#define dct_widen(out, inq) \
        -: 2705:   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
        -: 2706:   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)
        -: 2707:
        -: 2708:// wide add
        -: 2709:#define dct_wadd(out, a, b) \
        -: 2710:   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
        -: 2711:   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)
        -: 2712:
        -: 2713:// wide sub
        -: 2714:#define dct_wsub(out, a, b) \
        -: 2715:   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
        -: 2716:   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)
        -: 2717:
        -: 2718:// butterfly a/b, then shift using "shiftop" by "s" and pack
        -: 2719:#define dct_bfly32o(out0,out1, a,b,shiftop,s) \
        -: 2720:   { \
        -: 2721:      dct_wadd(sum, a, b); \
        -: 2722:      dct_wsub(dif, a, b); \
        -: 2723:      out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
        -: 2724:      out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
        -: 2725:   }
        -: 2726:
        -: 2727:#define dct_pass(shiftop, shift) \
        -: 2728:   { \
        -: 2729:      /* even part */ \
        -: 2730:      int16x8_t sum26 = vaddq_s16(row2, row6); \
        -: 2731:      dct_long_mul(p1e, sum26, rot0_0); \
        -: 2732:      dct_long_mac(t2e, p1e, row6, rot0_1); \
        -: 2733:      dct_long_mac(t3e, p1e, row2, rot0_2); \
        -: 2734:      int16x8_t sum04 = vaddq_s16(row0, row4); \
        -: 2735:      int16x8_t dif04 = vsubq_s16(row0, row4); \
        -: 2736:      dct_widen(t0e, sum04); \
        -: 2737:      dct_widen(t1e, dif04); \
        -: 2738:      dct_wadd(x0, t0e, t3e); \
        -: 2739:      dct_wsub(x3, t0e, t3e); \
        -: 2740:      dct_wadd(x1, t1e, t2e); \
        -: 2741:      dct_wsub(x2, t1e, t2e); \
        -: 2742:      /* odd part */ \
        -: 2743:      int16x8_t sum15 = vaddq_s16(row1, row5); \
        -: 2744:      int16x8_t sum17 = vaddq_s16(row1, row7); \
        -: 2745:      int16x8_t sum35 = vaddq_s16(row3, row5); \
        -: 2746:      int16x8_t sum37 = vaddq_s16(row3, row7); \
        -: 2747:      int16x8_t sumodd = vaddq_s16(sum17, sum35); \
        -: 2748:      dct_long_mul(p5o, sumodd, rot1_0); \
        -: 2749:      dct_long_mac(p1o, p5o, sum17, rot1_1); \
        -: 2750:      dct_long_mac(p2o, p5o, sum35, rot1_2); \
        -: 2751:      dct_long_mul(p3o, sum37, rot2_0); \
        -: 2752:      dct_long_mul(p4o, sum15, rot2_1); \
        -: 2753:      dct_wadd(sump13o, p1o, p3o); \
        -: 2754:      dct_wadd(sump24o, p2o, p4o); \
        -: 2755:      dct_wadd(sump23o, p2o, p3o); \
        -: 2756:      dct_wadd(sump14o, p1o, p4o); \
        -: 2757:      dct_long_mac(x4, sump13o, row7, rot3_0); \
        -: 2758:      dct_long_mac(x5, sump24o, row5, rot3_1); \
        -: 2759:      dct_long_mac(x6, sump23o, row3, rot3_2); \
        -: 2760:      dct_long_mac(x7, sump14o, row1, rot3_3); \
        -: 2761:      dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
        -: 2762:      dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
        -: 2763:      dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
        -: 2764:      dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
        -: 2765:   }
        -: 2766:
        -: 2767:   // load
        -: 2768:   row0 = vld1q_s16(data + 0*8);
        -: 2769:   row1 = vld1q_s16(data + 1*8);
        -: 2770:   row2 = vld1q_s16(data + 2*8);
        -: 2771:   row3 = vld1q_s16(data + 3*8);
        -: 2772:   row4 = vld1q_s16(data + 4*8);
        -: 2773:   row5 = vld1q_s16(data + 5*8);
        -: 2774:   row6 = vld1q_s16(data + 6*8);
        -: 2775:   row7 = vld1q_s16(data + 7*8);
        -: 2776:
        -: 2777:   // add DC bias
        -: 2778:   row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));
        -: 2779:
        -: 2780:   // column pass
        -: 2781:   dct_pass(vrshrn_n_s32, 10);
        -: 2782:
        -: 2783:   // 16bit 8x8 transpose
        -: 2784:   {
        -: 2785:// these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
        -: 2786:// whether compilers actually get this is another story, sadly.
        -: 2787:#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
        -: 2788:#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
        -: 2789:#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }
        -: 2790:
        -: 2791:      // pass 1
        -: 2792:      dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
        -: 2793:      dct_trn16(row2, row3);
        -: 2794:      dct_trn16(row4, row5);
        -: 2795:      dct_trn16(row6, row7);
        -: 2796:
        -: 2797:      // pass 2
        -: 2798:      dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
        -: 2799:      dct_trn32(row1, row3);
        -: 2800:      dct_trn32(row4, row6);
        -: 2801:      dct_trn32(row5, row7);
        -: 2802:
        -: 2803:      // pass 3
        -: 2804:      dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
        -: 2805:      dct_trn64(row1, row5);
        -: 2806:      dct_trn64(row2, row6);
        -: 2807:      dct_trn64(row3, row7);
        -: 2808:
        -: 2809:#undef dct_trn16
        -: 2810:#undef dct_trn32
        -: 2811:#undef dct_trn64
        -: 2812:   }
        -: 2813:
        -: 2814:   // row pass
        -: 2815:   // vrshrn_n_s32 only supports shifts up to 16, we need
        -: 2816:   // 17. so do a non-rounding shift of 16 first then follow
        -: 2817:   // up with a rounding shift by 1.
        -: 2818:   dct_pass(vshrn_n_s32, 16);
        -: 2819:
        -: 2820:   {
        -: 2821:      // pack and round
        -: 2822:      uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
        -: 2823:      uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
        -: 2824:      uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
        -: 2825:      uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
        -: 2826:      uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
        -: 2827:      uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
        -: 2828:      uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
        -: 2829:      uint8x8_t p7 = vqrshrun_n_s16(row7, 1);
        -: 2830:
        -: 2831:      // again, these can translate into one instruction, but often don't.
        -: 2832:#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
        -: 2833:#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
        -: 2834:#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }
        -: 2835:
        -: 2836:      // sadly can't use interleaved stores here since we only write
        -: 2837:      // 8 bytes to each scan line!
        -: 2838:
        -: 2839:      // 8x8 8-bit transpose pass 1
        -: 2840:      dct_trn8_8(p0, p1);
        -: 2841:      dct_trn8_8(p2, p3);
        -: 2842:      dct_trn8_8(p4, p5);
        -: 2843:      dct_trn8_8(p6, p7);
        -: 2844:
        -: 2845:      // pass 2
        -: 2846:      dct_trn8_16(p0, p2);
        -: 2847:      dct_trn8_16(p1, p3);
        -: 2848:      dct_trn8_16(p4, p6);
        -: 2849:      dct_trn8_16(p5, p7);
        -: 2850:
        -: 2851:      // pass 3
        -: 2852:      dct_trn8_32(p0, p4);
        -: 2853:      dct_trn8_32(p1, p5);
        -: 2854:      dct_trn8_32(p2, p6);
        -: 2855:      dct_trn8_32(p3, p7);
        -: 2856:
        -: 2857:      // store
        -: 2858:      vst1_u8(out, p0); out += out_stride;
        -: 2859:      vst1_u8(out, p1); out += out_stride;
        -: 2860:      vst1_u8(out, p2); out += out_stride;
        -: 2861:      vst1_u8(out, p3); out += out_stride;
        -: 2862:      vst1_u8(out, p4); out += out_stride;
        -: 2863:      vst1_u8(out, p5); out += out_stride;
        -: 2864:      vst1_u8(out, p6); out += out_stride;
        -: 2865:      vst1_u8(out, p7);
        -: 2866:
        -: 2867:#undef dct_trn8_8
        -: 2868:#undef dct_trn8_16
        -: 2869:#undef dct_trn8_32
        -: 2870:   }
        -: 2871:
        -: 2872:#undef dct_long_mul
        -: 2873:#undef dct_long_mac
        -: 2874:#undef dct_widen
        -: 2875:#undef dct_wadd
        -: 2876:#undef dct_wsub
        -: 2877:#undef dct_bfly32o
        -: 2878:#undef dct_pass
        -: 2879:}
        -: 2880:
        -: 2881:#endif // STBI_NEON
        -: 2882:
        -: 2883:#define STBI__MARKER_none  0xff
        -: 2884:// if there's a pending marker from the entropy stream, return that
        -: 2885:// otherwise, fetch from the stream and get a marker. if there's no
        -: 2886:// marker, return 0xff, which is never a valid marker value
function _ZL16stbi__get_markerP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 2887:static stbi_uc stbi__get_marker(stbi__jpeg *j)
        -: 2888:{
        -: 2889:   stbi_uc x;
    #####: 2890:   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
    %%%%%: 2890-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2890-block  1
    #####: 2891:   x = stbi__get8(j->s);
    %%%%%: 2891-block  0
call    0 never executed
    #####: 2892:   if (x != 0xff) return STBI__MARKER_none;
branch  0 never executed
branch  1 never executed
    #####: 2893:   while (x == 0xff)
    %%%%%: 2893-block  0
branch  0 never executed
branch  1 never executed
    #####: 2894:      x = stbi__get8(j->s); // consume repeated 0xff fill bytes
    %%%%%: 2894-block  0
call    0 never executed
        -: 2895:   return x;
        -: 2896:}
        -: 2897:
        -: 2898:// in each scan, we'll have scan_n components, and the order
        -: 2899:// of the components is specified by order[]
        -: 2900:#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
        -: 2901:
        -: 2902:// after a restart interval, stbi__jpeg_reset the entropy decoder and
        -: 2903:// the dc prediction
        -: 2904:static void stbi__jpeg_reset(stbi__jpeg *j)
        -: 2905:{
    #####: 2906:   j->code_bits = 0;
    #####: 2907:   j->code_buffer = 0;
    #####: 2908:   j->nomore = 0;
    #####: 2909:   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
    #####: 2910:   j->marker = STBI__MARKER_none;
    #####: 2911:   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
    %%%%%: 2911-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2911-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 2911-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 2911-block  3
branch  6 never executed
branch  7 never executed
    #####: 2912:   j->eob_run = 0;
        -: 2913:   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
        -: 2914:   // since we don't even allow 1<<30 pixels
    #####: 2915:}
    %%%%%: 2915-block  0
    %%%%%: 2915-block  1
    %%%%%: 2915-block  2
    %%%%%: 2915-block  3
        -: 2916:
function _ZL30stbi__parse_entropy_coded_dataP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 2917:static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
    %%%%%: 2917-block  0
branch  0 never executed
branch  1 never executed
        -: 2918:{
        -: 2919:   stbi__jpeg_reset(z);
    #####: 2920:   if (!z->progressive) {
    %%%%%: 2920-block  0
branch  0 never executed
branch  1 never executed
    #####: 2921:      if (z->scan_n == 1) {
    %%%%%: 2921-block  0
branch  0 never executed
branch  1 never executed
        -: 2922:         int i,j;
        -: 2923:         STBI_SIMD_ALIGN(short, data[64]);
    #####: 2924:         int n = z->order[0];
        -: 2925:         // non-interleaved data, we just need to process one block at a time,
        -: 2926:         // in trivial scanline order
        -: 2927:         // number of blocks to do just depends on how many actual "pixels" this
        -: 2928:         // component has, independent of interleaved MCU blocking and such
    #####: 2929:         int w = (z->img_comp[n].x+7) >> 3;
    #####: 2930:         int h = (z->img_comp[n].y+7) >> 3;
    %%%%%: 2930-block  0
    #####: 2931:         for (j=0; j < h; ++j) {
    %%%%%: 2931-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2931-block  1
    #####: 2932:            for (i=0; i < w; ++i) {
    %%%%%: 2932-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2932-block  1
    #####: 2933:               int ha = z->img_comp[n].ha;
    #####: 2934:               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
    %%%%%: 2934-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2935:               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
    %%%%%: 2935-block  0
call    0 never executed
        -: 2936:               // every data block is an MCU, so countdown the restart interval
    #####: 2937:               if (--z->todo <= 0) {
branch  0 never executed
branch  1 never executed
    #####: 2938:                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
    %%%%%: 2938-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2938-block  1
call    2 never executed
        -: 2939:                  // if it's NOT a restart, then just bail, so we get corrupt data
        -: 2940:                  // rather than no data
    #####: 2941:                  if (!STBI__RESTART(z->marker)) return 1;
    %%%%%: 2941-block  0
branch  0 never executed
branch  1 never executed
        -: 2942:                  stbi__jpeg_reset(z);
        -: 2943:               }
        -: 2944:            }
        -: 2945:         }
        -: 2946:         return 1;
        -: 2947:      } else { // interleaved
        -: 2948:         int i,j,k,x,y;
        -: 2949:         STBI_SIMD_ALIGN(short, data[64]);
    #####: 2950:         for (j=0; j < z->img_mcu_y; ++j) {
    %%%%%: 2950-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2950-block  1
    #####: 2951:            for (i=0; i < z->img_mcu_x; ++i) {
    %%%%%: 2951-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2951-block  1
        -: 2952:               // scan an interleaved mcu... process scan_n components in order
    #####: 2953:               for (k=0; k < z->scan_n; ++k) {
    %%%%%: 2953-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2953-block  1
    #####: 2954:                  int n = z->order[k];
    %%%%%: 2954-block  0
        -: 2955:                  // scan out an mcu's worth of this component; that's just determined
        -: 2956:                  // by the basic H and V specified for the component
    #####: 2957:                  for (y=0; y < z->img_comp[n].v; ++y) {
    %%%%%: 2957-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2957-block  1
    #####: 2958:                     for (x=0; x < z->img_comp[n].h; ++x) {
    %%%%%: 2958-block  0
branch  0 never executed
branch  1 never executed
    #####: 2959:                        int x2 = (i*z->img_comp[n].h + x)*8;
    #####: 2960:                        int y2 = (j*z->img_comp[n].v + y)*8;
    #####: 2961:                        int ha = z->img_comp[n].ha;
    #####: 2962:                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
    %%%%%: 2962-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2963:                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
    %%%%%: 2963-block  0
call    0 never executed
        -: 2964:                     }
        -: 2965:                  }
        -: 2966:               }
        -: 2967:               // after all interleaved components, that's an interleaved MCU,
        -: 2968:               // so now count down the restart interval
    #####: 2969:               if (--z->todo <= 0) {
    %%%%%: 2969-block  0
branch  0 never executed
branch  1 never executed
    #####: 2970:                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
    %%%%%: 2970-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2970-block  1
call    2 never executed
    #####: 2971:                  if (!STBI__RESTART(z->marker)) return 1;
    %%%%%: 2971-block  0
branch  0 never executed
branch  1 never executed
        -: 2972:                  stbi__jpeg_reset(z);
        -: 2973:               }
        -: 2974:            }
        -: 2975:         }
        -: 2976:         return 1;
        -: 2977:      }
        -: 2978:   } else {
    #####: 2979:      if (z->scan_n == 1) {
    %%%%%: 2979-block  0
branch  0 never executed
branch  1 never executed
        -: 2980:         int i,j;
    #####: 2981:         int n = z->order[0];
        -: 2982:         // non-interleaved data, we just need to process one block at a time,
        -: 2983:         // in trivial scanline order
        -: 2984:         // number of blocks to do just depends on how many actual "pixels" this
        -: 2985:         // component has, independent of interleaved MCU blocking and such
    #####: 2986:         int w = (z->img_comp[n].x+7) >> 3;
    #####: 2987:         int h = (z->img_comp[n].y+7) >> 3;
    %%%%%: 2987-block  0
    #####: 2988:         for (j=0; j < h; ++j) {
    %%%%%: 2988-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2988-block  1
    #####: 2989:            for (i=0; i < w; ++i) {
    %%%%%: 2989-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 2989-block  1
    #####: 2990:               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
    #####: 2991:               if (z->spec_start == 0) {
    %%%%%: 2991-block  0
branch  0 never executed
branch  1 never executed
    #####: 2992:                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
    %%%%%: 2992-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2993:                     return 0;
        -: 2994:               } else {
    #####: 2995:                  int ha = z->img_comp[n].ha;
    #####: 2996:                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
    %%%%%: 2996-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2997:                     return 0;
        -: 2998:               }
        -: 2999:               // every data block is an MCU, so countdown the restart interval
    #####: 3000:               if (--z->todo <= 0) {
    %%%%%: 3000-block  0
branch  0 never executed
branch  1 never executed
    #####: 3001:                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
    %%%%%: 3001-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3001-block  1
call    2 never executed
    #####: 3002:                  if (!STBI__RESTART(z->marker)) return 1;
    %%%%%: 3002-block  0
branch  0 never executed
branch  1 never executed
        -: 3003:                  stbi__jpeg_reset(z);
        -: 3004:               }
        -: 3005:            }
        -: 3006:         }
        -: 3007:         return 1;
        -: 3008:      } else { // interleaved
        -: 3009:         int i,j,k,x,y;
    #####: 3010:         for (j=0; j < z->img_mcu_y; ++j) {
    %%%%%: 3010-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3010-block  1
    #####: 3011:            for (i=0; i < z->img_mcu_x; ++i) {
    %%%%%: 3011-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3011-block  1
        -: 3012:               // scan an interleaved mcu... process scan_n components in order
    #####: 3013:               for (k=0; k < z->scan_n; ++k) {
    %%%%%: 3013-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3013-block  1
    #####: 3014:                  int n = z->order[k];
    %%%%%: 3014-block  0
        -: 3015:                  // scan out an mcu's worth of this component; that's just determined
        -: 3016:                  // by the basic H and V specified for the component
    #####: 3017:                  for (y=0; y < z->img_comp[n].v; ++y) {
    %%%%%: 3017-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3017-block  1
    #####: 3018:                     for (x=0; x < z->img_comp[n].h; ++x) {
    %%%%%: 3018-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3018-block  1
    #####: 3019:                        int x2 = (i*z->img_comp[n].h + x);
    #####: 3020:                        int y2 = (j*z->img_comp[n].v + y);
    #####: 3021:                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
    #####: 3022:                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
    %%%%%: 3022-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3023:                           return 0;
        -: 3024:                     }
        -: 3025:                  }
        -: 3026:               }
        -: 3027:               // after all interleaved components, that's an interleaved MCU,
        -: 3028:               // so now count down the restart interval
    #####: 3029:               if (--z->todo <= 0) {
    %%%%%: 3029-block  0
branch  0 never executed
branch  1 never executed
    #####: 3030:                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
    %%%%%: 3030-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3030-block  1
call    2 never executed
    #####: 3031:                  if (!STBI__RESTART(z->marker)) return 1;
    %%%%%: 3031-block  0
branch  0 never executed
branch  1 never executed
        -: 3032:                  stbi__jpeg_reset(z);
        -: 3033:               }
        -: 3034:            }
        -: 3035:         }
        -: 3036:         return 1;
        -: 3037:      }
        -: 3038:   }
        -: 3039:}
        -: 3040:
        -: 3041:static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
        -: 3042:{
        -: 3043:   int i;
    #####: 3044:   for (i=0; i < 64; ++i)
    %%%%%: 3044-block  0
branch  0 never executed
branch  1 never executed
    #####: 3045:      data[i] *= dequant[i];
    %%%%%: 3045-block  0
        -: 3046:}
        -: 3047:
function _ZL17stbi__jpeg_finishP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 3048:static void stbi__jpeg_finish(stbi__jpeg *z)
        -: 3049:{
    #####: 3050:   if (z->progressive) {
    %%%%%: 3050-block  0
branch  0 never executed
branch  1 never executed
        -: 3051:      // dequantize and idct the data
        -: 3052:      int i,j,n;
    #####: 3053:      for (n=0; n < z->s->img_n; ++n) {
    %%%%%: 3053-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3053-block  1
    #####: 3054:         int w = (z->img_comp[n].x+7) >> 3;
    #####: 3055:         int h = (z->img_comp[n].y+7) >> 3;
    %%%%%: 3055-block  0
    #####: 3056:         for (j=0; j < h; ++j) {
    %%%%%: 3056-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3056-block  1
    #####: 3057:            for (i=0; i < w; ++i) {
    %%%%%: 3057-block  0
branch  0 never executed
branch  1 never executed
    #####: 3058:               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
    #####: 3059:               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
    %%%%%: 3059-block  0
    #####: 3060:               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
    %%%%%: 3060-block  0
call    0 never executed
        -: 3061:            }
        -: 3062:         }
        -: 3063:      }
        -: 3064:   }
    #####: 3065:}
        -: 3066:
function _ZL20stbi__process_markerP10stbi__jpegi called 0 returned 0% blocks executed 0%
    #####: 3067:static int stbi__process_marker(stbi__jpeg *z, int m)
        -: 3068:{
        -: 3069:   int L;
    #####: 3070:   switch (m) {
    %%%%%: 3070-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 3071:      case STBI__MARKER_none: // no marker found
        -: 3072:         return stbi__err("expected marker","Corrupt JPEG");
        -: 3073:
    #####: 3074:      case 0xDD: // DRI - specify restart interval
    #####: 3075:         if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
    %%%%%: 3075-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3076:         z->restart_interval = stbi__get16be(z->s);
    %%%%%: 3076-block  0
call    0 never executed
    #####: 3077:         return 1;
        -: 3078:
    #####: 3079:      case 0xDB: // DQT - define quantization table
    #####: 3080:         L = stbi__get16be(z->s)-2;
    %%%%%: 3080-block  0
call    0 never executed
    #####: 3081:         while (L > 0) {
    %%%%%: 3081-block  0
branch  0 never executed
branch  1 never executed
    #####: 3082:            int q = stbi__get8(z->s);
    %%%%%: 3082-block  0
call    0 never executed
    #####: 3083:            int p = q >> 4, sixteen = (p != 0);
    #####: 3084:            int t = q & 15,i;
    #####: 3085:            if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
branch  0 never executed
branch  1 never executed
    #####: 3086:            if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");
    %%%%%: 3086-block  0
branch  0 never executed
branch  1 never executed
        -: 3087:
    #####: 3088:            for (i=0; i < 64; ++i)
    %%%%%: 3088-block  0
branch  0 never executed
branch  1 never executed
    #####: 3089:               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
    %%%%%: 3089-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3089-block  1
call    2 never executed
    %%%%%: 3089-block  2
call    3 never executed
    %%%%%: 3089-block  3
    #####: 3090:            L -= (sixteen ? 129 : 65);
    %%%%%: 3090-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3090-block  1
        -: 3091:         }
    #####: 3092:         return L==0;
    %%%%%: 3092-block  0
        -: 3093:
    #####: 3094:      case 0xC4: // DHT - define huffman table
    #####: 3095:         L = stbi__get16be(z->s)-2;
    %%%%%: 3095-block  0
call    0 never executed
    #####: 3096:         while (L > 0) {
    %%%%%: 3096-block  0
branch  0 never executed
branch  1 never executed
        -: 3097:            stbi_uc *v;
        -: 3098:            int sizes[16],i,n=0;
    #####: 3099:            int q = stbi__get8(z->s);
    %%%%%: 3099-block  0
call    0 never executed
    #####: 3100:            int tc = q >> 4;
    #####: 3101:            int th = q & 15;
    #####: 3102:            if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
branch  0 never executed
branch  1 never executed
    %%%%%: 3102-block  0
    #####: 3103:            for (i=0; i < 16; ++i) {
    %%%%%: 3103-block  0
branch  0 never executed
branch  1 never executed
    #####: 3104:               sizes[i] = stbi__get8(z->s);
    %%%%%: 3104-block  0
call    0 never executed
    #####: 3105:               n += sizes[i];
        -: 3106:            }
    #####: 3107:            L -= 17;
    #####: 3108:            if (tc == 0) {
    %%%%%: 3108-block  0
branch  0 never executed
branch  1 never executed
    #####: 3109:               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
    %%%%%: 3109-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3110:               v = z->huff_dc[th].values;
    %%%%%: 3110-block  0
        -: 3111:            } else {
    #####: 3112:               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
    %%%%%: 3112-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3113:               v = z->huff_ac[th].values;
    %%%%%: 3113-block  0
        -: 3114:            }
    #####: 3115:            for (i=0; i < n; ++i)
    %%%%%: 3115-block  0
branch  0 never executed
branch  1 never executed
    #####: 3116:               v[i] = stbi__get8(z->s);
    %%%%%: 3116-block  0
call    0 never executed
    #####: 3117:            if (tc != 0)
    %%%%%: 3117-block  0
branch  0 never executed
branch  1 never executed
    #####: 3118:               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
    %%%%%: 3118-block  0
call    0 never executed
    #####: 3119:            L -= n;
    %%%%%: 3119-block  0
        -: 3120:         }
    #####: 3121:         return L==0;
    %%%%%: 3121-block  0
        -: 3122:   }
        -: 3123:
        -: 3124:   // check for comment block or APP blocks
    #####: 3125:   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
    %%%%%: 3125-block  0
branch  0 never executed
branch  1 never executed
    #####: 3126:      L = stbi__get16be(z->s);
    %%%%%: 3126-block  0
call    0 never executed
    #####: 3127:      if (L < 2) {
branch  0 never executed
branch  1 never executed
        -: 3128:         if (m == 0xFE)
        -: 3129:            return stbi__err("bad COM len","Corrupt JPEG");
        -: 3130:         else
        -: 3131:            return stbi__err("bad APP len","Corrupt JPEG");
        -: 3132:      }
    #####: 3133:      L -= 2;
        -: 3134:
    #####: 3135:      if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
    %%%%%: 3135-block  0
branch  0 never executed
branch  1 never executed
        -: 3136:         static const unsigned char tag[5] = {'J','F','I','F','\0'};
        -: 3137:         int ok = 1;
        -: 3138:         int i;
    #####: 3139:         for (i=0; i < 5; ++i)
    %%%%%: 3139-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3139-block  1
    #####: 3140:            if (stbi__get8(z->s) != tag[i])
    %%%%%: 3140-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3141:               ok = 0;
    #####: 3142:         L -= 5;
    #####: 3143:         if (ok)
    %%%%%: 3143-block  0
branch  0 never executed
branch  1 never executed
    #####: 3144:            z->jfif = 1;
    %%%%%: 3144-block  0
    #####: 3145:      } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
    %%%%%: 3145-block  0
branch  0 never executed
branch  1 never executed
        -: 3146:         static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
        -: 3147:         int ok = 1;
        -: 3148:         int i;
    #####: 3149:         for (i=0; i < 6; ++i)
    %%%%%: 3149-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3149-block  1
    #####: 3150:            if (stbi__get8(z->s) != tag[i])
    %%%%%: 3150-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3151:               ok = 0;
    #####: 3152:         L -= 6;
    #####: 3153:         if (ok) {
    %%%%%: 3153-block  0
branch  0 never executed
branch  1 never executed
    #####: 3154:            stbi__get8(z->s); // version
    %%%%%: 3154-block  0
call    0 never executed
    #####: 3155:            stbi__get16be(z->s); // flags0
call    0 never executed
    #####: 3156:            stbi__get16be(z->s); // flags1
call    0 never executed
    #####: 3157:            z->app14_color_transform = stbi__get8(z->s); // color transform
call    0 never executed
    #####: 3158:            L -= 6;
        -: 3159:         }
        -: 3160:      }
        -: 3161:
    #####: 3162:      stbi__skip(z->s, L);
    %%%%%: 3162-block  0
call    0 never executed
    #####: 3163:      return 1;
        -: 3164:   }
        -: 3165:
        -: 3166:   return stbi__err("unknown marker","Corrupt JPEG");
        -: 3167:}
        -: 3168:
        -: 3169:// after we see SOS
function _ZL25stbi__process_scan_headerP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 3170:static int stbi__process_scan_header(stbi__jpeg *z)
        -: 3171:{
        -: 3172:   int i;
    #####: 3173:   int Ls = stbi__get16be(z->s);
    %%%%%: 3173-block  0
call    0 never executed
    #####: 3174:   z->scan_n = stbi__get8(z->s);
call    0 never executed
    #####: 3175:   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
branch  0 never executed
branch  1 never executed
    %%%%%: 3175-block  0
branch  2 never executed
branch  3 never executed
    #####: 3176:   if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
    %%%%%: 3176-block  0
branch  0 never executed
branch  1 never executed
    #####: 3177:   for (i=0; i < z->scan_n; ++i) {
    %%%%%: 3177-block  0
branch  0 never executed
branch  1 never executed
    #####: 3178:      int id = stbi__get8(z->s), which;
    %%%%%: 3178-block  0
call    0 never executed
    #####: 3179:      int q = stbi__get8(z->s);
call    0 never executed
    #####: 3180:      for (which = 0; which < z->s->img_n; ++which)
    %%%%%: 3180-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3180-block  1
    #####: 3181:         if (z->img_comp[which].id == id)
    %%%%%: 3181-block  0
branch  0 never executed
branch  1 never executed
        -: 3182:            break;
    #####: 3183:      if (which == z->s->img_n) return 0; // no match
    %%%%%: 3183-block  0
branch  0 never executed
branch  1 never executed
    #####: 3184:      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
    %%%%%: 3184-block  0
branch  0 never executed
branch  1 never executed
    #####: 3185:      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
    %%%%%: 3185-block  0
branch  0 never executed
branch  1 never executed
    #####: 3186:      z->order[i] = which;
    %%%%%: 3186-block  0
        -: 3187:   }
        -: 3188:
        -: 3189:   {
        -: 3190:      int aa;
    #####: 3191:      z->spec_start = stbi__get8(z->s);
    %%%%%: 3191-block  0
call    0 never executed
    #####: 3192:      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
call    0 never executed
    #####: 3193:      aa = stbi__get8(z->s);
call    0 never executed
    #####: 3194:      z->succ_high = (aa >> 4);
    #####: 3195:      z->succ_low  = (aa & 15);
    #####: 3196:      if (z->progressive) {
branch  0 never executed
branch  1 never executed
    #####: 3197:         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
    %%%%%: 3197-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3197-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 3197-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 3197-block  3
branch  6 never executed
branch  7 never executed
    %%%%%: 3197-block  4
branch  8 never executed
branch  9 never executed
    #####: 3198:            return stbi__err("bad SOS", "Corrupt JPEG");
    %%%%%: 3198-block  0
        -: 3199:      } else {
    #####: 3200:         if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
    %%%%%: 3200-block  0
branch  0 never executed
branch  1 never executed
    #####: 3201:         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
    %%%%%: 3201-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3201-block  1
branch  2 never executed
branch  3 never executed
    #####: 3202:         z->spec_end = 63;
    %%%%%: 3202-block  0
        -: 3203:      }
        -: 3204:   }
        -: 3205:
        -: 3206:   return 1;
        -: 3207:}
        -: 3208:
function _ZL26stbi__free_jpeg_componentsP10stbi__jpegii called 0 returned 0% blocks executed 0%
    #####: 3209:static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
    %%%%%: 3209-block  0
        -: 3210:{
        -: 3211:   int i;
    #####: 3212:   for (i=0; i < ncomp; ++i) {
    %%%%%: 3212-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3212-block  1
    #####: 3213:      if (z->img_comp[i].raw_data) {
    %%%%%: 3213-block  0
branch  0 never executed
branch  1 never executed
    #####: 3214:         STBI_FREE(z->img_comp[i].raw_data);
    #####: 3215:         z->img_comp[i].raw_data = NULL;
    #####: 3216:         z->img_comp[i].data = NULL;
    %%%%%: 3216-block  0
        -: 3217:      }
    #####: 3218:      if (z->img_comp[i].raw_coeff) {
    %%%%%: 3218-block  0
branch  0 never executed
branch  1 never executed
    #####: 3219:         STBI_FREE(z->img_comp[i].raw_coeff);
    #####: 3220:         z->img_comp[i].raw_coeff = 0;
    #####: 3221:         z->img_comp[i].coeff = 0;
    %%%%%: 3221-block  0
        -: 3222:      }
    #####: 3223:      if (z->img_comp[i].linebuf) {
    %%%%%: 3223-block  0
branch  0 never executed
branch  1 never executed
    #####: 3224:         STBI_FREE(z->img_comp[i].linebuf);
    #####: 3225:         z->img_comp[i].linebuf = NULL;
    %%%%%: 3225-block  0
        -: 3226:      }
        -: 3227:   }
    #####: 3228:   return why;
        -: 3229:}
        -: 3230:
function _ZL26stbi__process_frame_headerP10stbi__jpegi called 0 returned 0% blocks executed 0%
    #####: 3231:static int stbi__process_frame_header(stbi__jpeg *z, int scan)
        -: 3232:{
    #####: 3233:   stbi__context *s = z->s;
        -: 3234:   int Lf,p,i,q, h_max=1,v_max=1,c;
    #####: 3235:   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
    %%%%%: 3235-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3236:   p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
    %%%%%: 3236-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3237:   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
    %%%%%: 3237-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3238:   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
    %%%%%: 3238-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3239:   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
    %%%%%: 3239-block  0
branch  0 never executed
branch  1 never executed
    #####: 3240:   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
    %%%%%: 3240-block  0
branch  0 never executed
branch  1 never executed
    #####: 3241:   c = stbi__get8(s);
    %%%%%: 3241-block  0
call    0 never executed
    #####: 3242:   if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");
branch  0 never executed
branch  1 never executed
    %%%%%: 3242-block  0
branch  2 never executed
branch  3 never executed
    #####: 3243:   s->img_n = c;
    %%%%%: 3243-block  0
    #####: 3244:   for (i=0; i < c; ++i) {
    %%%%%: 3244-block  0
branch  0 never executed
branch  1 never executed
    #####: 3245:      z->img_comp[i].data = NULL;
    #####: 3246:      z->img_comp[i].linebuf = NULL;
    %%%%%: 3246-block  0
        -: 3247:   }
        -: 3248:
    #####: 3249:   if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");
    %%%%%: 3249-block  0
branch  0 never executed
branch  1 never executed
        -: 3250:
    #####: 3251:   z->rgb = 0;
    %%%%%: 3251-block  0
    #####: 3252:   for (i=0; i < s->img_n; ++i) {
    %%%%%: 3252-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3252-block  1
        -: 3253:      static const unsigned char rgb[3] = { 'R', 'G', 'B' };
    #####: 3254:      z->img_comp[i].id = stbi__get8(s);
    %%%%%: 3254-block  0
call    0 never executed
    #####: 3255:      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
branch  0 never executed
branch  1 never executed
    %%%%%: 3255-block  0
branch  2 never executed
branch  3 never executed
    #####: 3256:         ++z->rgb;
    %%%%%: 3256-block  0
    #####: 3257:      q = stbi__get8(s);
    %%%%%: 3257-block  0
call    0 never executed
    #####: 3258:      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
branch  0 never executed
branch  1 never executed
    %%%%%: 3258-block  0
branch  2 never executed
branch  3 never executed
    #####: 3259:      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
    %%%%%: 3259-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3259-block  1
branch  2 never executed
branch  3 never executed
    #####: 3260:      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
    %%%%%: 3260-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3261:   }
        -: 3262:
    #####: 3263:   if (scan != STBI__SCAN_load) return 1;
    %%%%%: 3263-block  0
branch  0 never executed
branch  1 never executed
        -: 3264:
    #####: 3265:   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");
    %%%%%: 3265-block  0
branch  0 never executed
branch  1 never executed
        -: 3266:
    #####: 3267:   for (i=0; i < s->img_n; ++i) {
    %%%%%: 3267-block  0
branch  0 never executed
branch  1 never executed
    #####: 3268:      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
    #####: 3269:      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
    %%%%%: 3269-block  0
        -: 3270:   }
        -: 3271:
        -: 3272:   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
        -: 3273:   // and I've never seen a non-corrupted JPEG file actually use them
    #####: 3274:   for (i=0; i < s->img_n; ++i) {
    %%%%%: 3274-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3274-block  1
    #####: 3275:      if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");
    %%%%%: 3275-block  0
branch  0 never executed
branch  1 never executed
    #####: 3276:      if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");
    %%%%%: 3276-block  0
branch  0 never executed
branch  1 never executed
        -: 3277:   }
        -: 3278:
        -: 3279:   // compute interleaved mcu info
    #####: 3280:   z->img_h_max = h_max;
    #####: 3281:   z->img_v_max = v_max;
    #####: 3282:   z->img_mcu_w = h_max * 8;
    #####: 3283:   z->img_mcu_h = v_max * 8;
        -: 3284:   // these sizes can't be more than 17 bits
    #####: 3285:   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
    #####: 3286:   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;
    %%%%%: 3286-block  0
        -: 3287:
    #####: 3288:   for (i=0; i < s->img_n; ++i) {
    %%%%%: 3288-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3288-block  1
        -: 3289:      // number of effective pixels (e.g. for non-interleaved MCU)
    #####: 3290:      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
    #####: 3291:      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
        -: 3292:      // to simplify generation, we'll allocate enough memory to decode
        -: 3293:      // the bogus oversized data from using interleaved MCUs and their
        -: 3294:      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
        -: 3295:      // discard the extra data until colorspace conversion
        -: 3296:      //
        -: 3297:      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
        -: 3298:      // so these muls can't overflow with 32-bit ints (which we require)
    #####: 3299:      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
    #####: 3300:      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
    #####: 3301:      z->img_comp[i].coeff = 0;
    #####: 3302:      z->img_comp[i].raw_coeff = 0;
    #####: 3303:      z->img_comp[i].linebuf = NULL;
    #####: 3304:      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
    %%%%%: 3304-block  0
call    0 never executed
    #####: 3305:      if (z->img_comp[i].raw_data == NULL)
branch  0 never executed
branch  1 never executed
    #####: 3306:         return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
    %%%%%: 3306-block  0
call    0 never executed
        -: 3307:      // align blocks for idct using mmx/sse
    #####: 3308:      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
    #####: 3309:      if (z->progressive) {
    %%%%%: 3309-block  0
branch  0 never executed
branch  1 never executed
        -: 3310:         // w2, h2 are multiples of 8 (see above)
    #####: 3311:         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
    #####: 3312:         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
    #####: 3313:         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
    %%%%%: 3313-block  0
call    0 never executed
    #####: 3314:         if (z->img_comp[i].raw_coeff == NULL)
branch  0 never executed
branch  1 never executed
    #####: 3315:            return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
    %%%%%: 3315-block  0
call    0 never executed
    #####: 3316:         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
    %%%%%: 3316-block  0
        -: 3317:      }
        -: 3318:   }
        -: 3319:
        -: 3320:   return 1;
        -: 3321:}
        -: 3322:
        -: 3323:// use comparisons since in some cases we handle more than one case (e.g. SOF)
        -: 3324:#define stbi__DNL(x)         ((x) == 0xdc)
        -: 3325:#define stbi__SOI(x)         ((x) == 0xd8)
        -: 3326:#define stbi__EOI(x)         ((x) == 0xd9)
        -: 3327:#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
        -: 3328:#define stbi__SOS(x)         ((x) == 0xda)
        -: 3329:
        -: 3330:#define stbi__SOF_progressive(x)   ((x) == 0xc2)
        -: 3331:
function _ZL24stbi__decode_jpeg_headerP10stbi__jpegi called 0 returned 0% blocks executed 0%
    #####: 3332:static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
        -: 3333:{
        -: 3334:   int m;
    #####: 3335:   z->jfif = 0;
    #####: 3336:   z->app14_color_transform = -1; // valid values are 0,1,2
    #####: 3337:   z->marker = STBI__MARKER_none; // initialize cached marker to empty
    #####: 3338:   m = stbi__get_marker(z);
    %%%%%: 3338-block  0
call    0 never executed
    #####: 3339:   if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
branch  0 never executed
branch  1 never executed
    #####: 3340:   if (scan == STBI__SCAN_type) return 1;
    %%%%%: 3340-block  0
branch  0 never executed
branch  1 never executed
    #####: 3341:   m = stbi__get_marker(z);
    %%%%%: 3341-block  0
call    0 never executed
    #####: 3342:   while (!stbi__SOF(m)) {
    %%%%%: 3342-block  0
branch  0 never executed
branch  1 never executed
    #####: 3343:      if (!stbi__process_marker(z,m)) return 0;
    %%%%%: 3343-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3344:      m = stbi__get_marker(z);
    %%%%%: 3344-block  0
call    0 never executed
    #####: 3345:      while (m == STBI__MARKER_none) {
    %%%%%: 3345-block  0
branch  0 never executed
branch  1 never executed
        -: 3346:         // some files have extra padding after their blocks, so ok, we'll scan
    #####: 3347:         if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
    %%%%%: 3347-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3347-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 3347-block  2
    #####: 3348:         m = stbi__get_marker(z);
    %%%%%: 3348-block  0
call    0 never executed
        -: 3349:      }
        -: 3350:   }
    #####: 3351:   z->progressive = stbi__SOF_progressive(m);
    #####: 3352:   if (!stbi__process_frame_header(z, scan)) return 0;
    %%%%%: 3352-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%: 3352-block  1
        -: 3353:   return 1;
        -: 3354:}
        -: 3355:
        -: 3356:// decode image to YCbCr format
function _ZL23stbi__decode_jpeg_imageP10stbi__jpeg called 0 returned 0% blocks executed 0%
    #####: 3357:static int stbi__decode_jpeg_image(stbi__jpeg *j)
    %%%%%: 3357-block  0
        -: 3358:{
        -: 3359:   int m;
    #####: 3360:   for (m = 0; m < 4; m++) {
    %%%%%: 3360-block  0
branch  0 never executed
branch  1 never executed
    #####: 3361:      j->img_comp[m].raw_data = NULL;
    #####: 3362:      j->img_comp[m].raw_coeff = NULL;
    %%%%%: 3362-block  0
        -: 3363:   }
    #####: 3364:   j->restart_interval = 0;
    #####: 3365:   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
    %%%%%: 3365-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3366:   m = stbi__get_marker(j);
    %%%%%: 3366-block  0
call    0 never executed
    #####: 3367:   while (!stbi__EOI(m)) {
    %%%%%: 3367-block  0
branch  0 never executed
branch  1 never executed
    #####: 3368:      if (stbi__SOS(m)) {
    %%%%%: 3368-block  0
branch  0 never executed
branch  1 never executed
    #####: 3369:         if (!stbi__process_scan_header(j)) return 0;
    %%%%%: 3369-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3370:         if (!stbi__parse_entropy_coded_data(j)) return 0;
    %%%%%: 3370-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3371:         if (j->marker == STBI__MARKER_none ) {
    %%%%%: 3371-block  0
branch  0 never executed
branch  1 never executed
        -: 3372:            // handle 0s at the end of image data from IP Kamera 9060
    #####: 3373:            while (!stbi__at_eof(j->s)) {
    %%%%%: 3373-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3373-block  1
branch  2 never executed
branch  3 never executed
    #####: 3374:               int x = stbi__get8(j->s);
    %%%%%: 3374-block  0
call    0 never executed
    #####: 3375:               if (x == 255) {
branch  0 never executed
branch  1 never executed
    #####: 3376:                  j->marker = stbi__get8(j->s);
    %%%%%: 3376-block  0
call    0 never executed
    #####: 3377:                  break;
        -: 3378:               }
        -: 3379:            }
        -: 3380:            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
        -: 3381:         }
    #####: 3382:      } else if (stbi__DNL(m)) {
    %%%%%: 3382-block  0
branch  0 never executed
branch  1 never executed
    #####: 3383:         int Ld = stbi__get16be(j->s);
    %%%%%: 3383-block  0
call    0 never executed
    #####: 3384:         stbi__uint32 NL = stbi__get16be(j->s);
call    0 never executed
    #####: 3385:         if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
branch  0 never executed
branch  1 never executed
    #####: 3386:         if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
    %%%%%: 3386-block  0
branch  0 never executed
branch  1 never executed
        -: 3387:      } else {
    #####: 3388:         if (!stbi__process_marker(j, m)) return 0;
    %%%%%: 3388-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3389:      }
    #####: 3390:      m = stbi__get_marker(j);
    %%%%%: 3390-block  0
call    0 never executed
        -: 3391:   }
    #####: 3392:   if (j->progressive)
    %%%%%: 3392-block  0
branch  0 never executed
branch  1 never executed
    #####: 3393:      stbi__jpeg_finish(j);
    %%%%%: 3393-block  0
call    0 never executed
        -: 3394:   return 1;
        -: 3395:}
        -: 3396:
        -: 3397:// static jfif-centered resampling (across block boundaries)
        -: 3398:
        -: 3399:typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
        -: 3400:                                    int w, int hs);
        -: 3401:
        -: 3402:#define stbi__div4(x) ((stbi_uc) ((x) >> 2))
        -: 3403:
function _ZL14resample_row_1PhS_S_ii called 0 returned 0% blocks executed 0%
    #####: 3404:static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
        -: 3405:{
        -: 3406:   STBI_NOTUSED(out);
        -: 3407:   STBI_NOTUSED(in_far);
        -: 3408:   STBI_NOTUSED(w);
        -: 3409:   STBI_NOTUSED(hs);
    #####: 3410:   return in_near;
        -: 3411:}
        -: 3412:
function _ZL22stbi__resample_row_v_2PhS_S_ii called 0 returned 0% blocks executed 0%
    #####: 3413:static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
    %%%%%: 3413-block  0
        -: 3414:{
        -: 3415:   // need to generate two samples vertically for every one in input
        -: 3416:   int i;
        -: 3417:   STBI_NOTUSED(hs);
    #####: 3418:   for (i=0; i < w; ++i)
    %%%%%: 3418-block  0
branch  0 never executed
branch  1 never executed
    #####: 3419:      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
    %%%%%: 3419-block  0
    #####: 3420:   return out;
        -: 3421:}
        -: 3422:
function _ZL22stbi__resample_row_h_2PhS_S_ii called 0 returned 0% blocks executed 0%
    #####: 3423:static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
        -: 3424:{
        -: 3425:   // need to generate two samples horizontally for every one in input
        -: 3426:   int i;
        -: 3427:   stbi_uc *input = in_near;
        -: 3428:
    #####: 3429:   if (w == 1) {
    %%%%%: 3429-block  0
branch  0 never executed
branch  1 never executed
        -: 3430:      // if only one sample, can't do any interpolation
    #####: 3431:      out[0] = out[1] = input[0];
    #####: 3432:      return out;
    %%%%%: 3432-block  0
        -: 3433:   }
        -: 3434:
    #####: 3435:   out[0] = input[0];
    #####: 3436:   out[1] = stbi__div4(input[0]*3 + input[1] + 2);
    %%%%%: 3436-block  0
    #####: 3437:   for (i=1; i < w-1; ++i) {
    %%%%%: 3437-block  0
branch  0 never executed
branch  1 never executed
    #####: 3438:      int n = 3*input[i]+2;
    #####: 3439:      out[i*2+0] = stbi__div4(n+input[i-1]);
    #####: 3440:      out[i*2+1] = stbi__div4(n+input[i+1]);
    %%%%%: 3440-block  0
        -: 3441:   }
    #####: 3442:   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
    #####: 3443:   out[i*2+1] = input[w-1];
        -: 3444:
        -: 3445:   STBI_NOTUSED(in_far);
        -: 3446:   STBI_NOTUSED(hs);
        -: 3447:
    #####: 3448:   return out;
    %%%%%: 3448-block  0
        -: 3449:}
        -: 3450:
        -: 3451:#define stbi__div16(x) ((stbi_uc) ((x) >> 4))
        -: 3452:
        -: 3453:static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
        -: 3454:{
        -: 3455:   // need to generate 2x2 samples for every one in input
        -: 3456:   int i,t0,t1;
        -: 3457:   if (w == 1) {
        -: 3458:      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
        -: 3459:      return out;
        -: 3460:   }
        -: 3461:
        -: 3462:   t1 = 3*in_near[0] + in_far[0];
        -: 3463:   out[0] = stbi__div4(t1+2);
        -: 3464:   for (i=1; i < w; ++i) {
        -: 3465:      t0 = t1;
        -: 3466:      t1 = 3*in_near[i]+in_far[i];
        -: 3467:      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
        -: 3468:      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
        -: 3469:   }
        -: 3470:   out[w*2-1] = stbi__div4(t1+2);
        -: 3471:
        -: 3472:   STBI_NOTUSED(hs);
        -: 3473:
        -: 3474:   return out;
        -: 3475:}
        -: 3476:
        -: 3477:#if defined(STBI_SSE2) || defined(STBI_NEON)
function _ZL28stbi__resample_row_hv_2_simdPhS_S_ii called 0 returned 0% blocks executed 0%
    #####: 3478:static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
        -: 3479:{
        -: 3480:   // need to generate 2x2 samples for every one in input
        -: 3481:   int i=0,t0,t1;
        -: 3482:
    #####: 3483:   if (w == 1) {
    %%%%%: 3483-block  0
branch  0 never executed
branch  1 never executed
    #####: 3484:      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
    #####: 3485:      return out;
    %%%%%: 3485-block  0
        -: 3486:   }
        -: 3487:
    #####: 3488:   t1 = 3*in_near[0] + in_far[0];
    %%%%%: 3488-block  0
        -: 3489:   // process groups of 8 pixels for as long as we can.
        -: 3490:   // note we can't handle the last pixel in a row in this loop
        -: 3491:   // because we need to handle the filter boundary conditions.
    #####: 3492:   for (; i < ((w-1) & ~7); i += 8) {
    %%%%%: 3492-block  0
branch  0 never executed
branch  1 never executed
        -: 3493:#if defined(STBI_SSE2)
        -: 3494:      // load and perform the vertical filtering pass
        -: 3495:      // this uses 3*x + y = 4*x + (y - x)
        -: 3496:      __m128i zero  = _mm_setzero_si128();
    #####: 3497:      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
    %%%%%: 3497-block  0
call    0 never executed
    #####: 3498:      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
    %%%%%: 3498-block  0
call    0 never executed
        -: 3499:      __m128i farw  = _mm_unpacklo_epi8(farb, zero);
        -: 3500:      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
        -: 3501:      __m128i diff  = _mm_sub_epi16(farw, nearw);
        -: 3502:      __m128i nears = _mm_slli_epi16(nearw, 2);
        -: 3503:      __m128i curr  = _mm_add_epi16(nears, diff); // current row
        -: 3504:
        -: 3505:      // horizontal filter works the same based on shifted vers of current
        -: 3506:      // row. "prev" is current row shifted right by 1 pixel; we need to
        -: 3507:      // insert the previous pixel value (from t1).
        -: 3508:      // "next" is current row shifted left by 1 pixel, with first pixel
        -: 3509:      // of next block of 8 pixels added in.
        -: 3510:      __m128i prv0 = _mm_slli_si128(curr, 2);
        -: 3511:      __m128i nxt0 = _mm_srli_si128(curr, 2);
        -: 3512:      __m128i prev = _mm_insert_epi16(prv0, t1, 0);
    #####: 3513:      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);
call    0 never executed
        -: 3514:
        -: 3515:      // horizontal filter, polyphase implementation since it's convenient:
        -: 3516:      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
        -: 3517:      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
        -: 3518:      // note the shared term.
        -: 3519:      __m128i bias  = _mm_set1_epi16(8);
        -: 3520:      __m128i curs = _mm_slli_epi16(curr, 2);
        -: 3521:      __m128i prvd = _mm_sub_epi16(prev, curr);
        -: 3522:      __m128i nxtd = _mm_sub_epi16(next, curr);
        -: 3523:      __m128i curb = _mm_add_epi16(curs, bias);
        -: 3524:      __m128i even = _mm_add_epi16(prvd, curb);
        -: 3525:      __m128i odd  = _mm_add_epi16(nxtd, curb);
        -: 3526:
        -: 3527:      // interleave even and odd pixels, then undo scaling.
        -: 3528:      __m128i int0 = _mm_unpacklo_epi16(even, odd);
        -: 3529:      __m128i int1 = _mm_unpackhi_epi16(even, odd);
        -: 3530:      __m128i de0  = _mm_srli_epi16(int0, 4);
        -: 3531:      __m128i de1  = _mm_srli_epi16(int1, 4);
        -: 3532:
        -: 3533:      // pack and write output
        -: 3534:      __m128i outv = _mm_packus_epi16(de0, de1);
    #####: 3535:      _mm_storeu_si128((__m128i *) (out + i*2), outv);
        -: 3536:#elif defined(STBI_NEON)
        -: 3537:      // load and perform the vertical filtering pass
        -: 3538:      // this uses 3*x + y = 4*x + (y - x)
        -: 3539:      uint8x8_t farb  = vld1_u8(in_far + i);
        -: 3540:      uint8x8_t nearb = vld1_u8(in_near + i);
        -: 3541:      int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
        -: 3542:      int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
        -: 3543:      int16x8_t curr  = vaddq_s16(nears, diff); // current row
        -: 3544:
        -: 3545:      // horizontal filter works the same based on shifted vers of current
        -: 3546:      // row. "prev" is current row shifted right by 1 pixel; we need to
        -: 3547:      // insert the previous pixel value (from t1).
        -: 3548:      // "next" is current row shifted left by 1 pixel, with first pixel
        -: 3549:      // of next block of 8 pixels added in.
        -: 3550:      int16x8_t prv0 = vextq_s16(curr, curr, 7);
        -: 3551:      int16x8_t nxt0 = vextq_s16(curr, curr, 1);
        -: 3552:      int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
        -: 3553:      int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);
        -: 3554:
        -: 3555:      // horizontal filter, polyphase implementation since it's convenient:
        -: 3556:      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
        -: 3557:      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
        -: 3558:      // note the shared term.
        -: 3559:      int16x8_t curs = vshlq_n_s16(curr, 2);
        -: 3560:      int16x8_t prvd = vsubq_s16(prev, curr);
        -: 3561:      int16x8_t nxtd = vsubq_s16(next, curr);
        -: 3562:      int16x8_t even = vaddq_s16(curs, prvd);
        -: 3563:      int16x8_t odd  = vaddq_s16(curs, nxtd);
        -: 3564:
        -: 3565:      // undo scaling and round, then store with even/odd phases interleaved
        -: 3566:      uint8x8x2_t o;
        -: 3567:      o.val[0] = vqrshrun_n_s16(even, 4);
        -: 3568:      o.val[1] = vqrshrun_n_s16(odd,  4);
        -: 3569:      vst2_u8(out + i*2, o);
        -: 3570:#endif
        -: 3571:
        -: 3572:      // "previous" value for next iter
    #####: 3573:      t1 = 3*in_near[i+7] + in_far[i+7];
        -: 3574:   }
        -: 3575:
        -: 3576:   t0 = t1;
    #####: 3577:   t1 = 3*in_near[i] + in_far[i];
    #####: 3578:   out[i*2] = stbi__div16(3*t1 + t0 + 8);
        -: 3579:
    #####: 3580:   for (++i; i < w; ++i) {
    %%%%%: 3580-block  0
    %%%%%: 3580-block  1
branch  0 never executed
branch  1 never executed
        -: 3581:      t0 = t1;
    #####: 3582:      t1 = 3*in_near[i]+in_far[i];
    #####: 3583:      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
    #####: 3584:      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
    %%%%%: 3584-block  0
        -: 3585:   }
    #####: 3586:   out[w*2-1] = stbi__div4(t1+2);
        -: 3587:
        -: 3588:   STBI_NOTUSED(hs);
        -: 3589:
    #####: 3590:   return out;
    %%%%%: 3590-block  0
        -: 3591:}
        -: 3592:#endif
        -: 3593:
function _ZL26stbi__resample_row_genericPhS_S_ii called 0 returned 0% blocks executed 0%
    #####: 3594:static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
    %%%%%: 3594-block  0
        -: 3595:{
        -: 3596:   // resample with nearest-neighbor
        -: 3597:   int i,j;
        -: 3598:   STBI_NOTUSED(in_far);
    #####: 3599:   for (i=0; i < w; ++i)
    %%%%%: 3599-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3599-block  1
    #####: 3600:      for (j=0; j < hs; ++j)
    %%%%%: 3600-block  0
branch  0 never executed
branch  1 never executed
    #####: 3601:         out[i*hs+j] = in_near[i];
    %%%%%: 3601-block  0
    #####: 3602:   return out;
        -: 3603:}
        -: 3604:
        -: 3605:// this is a reduced-precision calculation of YCbCr-to-RGB introduced
        -: 3606:// to make sure the code produces the same results in both SIMD and scalar
        -: 3607:#define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
        -: 3608:static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
        -: 3609:{
        -: 3610:   int i;
        -: 3611:   for (i=0; i < count; ++i) {
        -: 3612:      int y_fixed = (y[i] << 20) + (1<<19); // rounding
        -: 3613:      int r,g,b;
        -: 3614:      int cr = pcr[i] - 128;
        -: 3615:      int cb = pcb[i] - 128;
        -: 3616:      r = y_fixed +  cr* stbi__float2fixed(1.40200f);
        -: 3617:      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
        -: 3618:      b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
        -: 3619:      r >>= 20;
        -: 3620:      g >>= 20;
        -: 3621:      b >>= 20;
        -: 3622:      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
        -: 3623:      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
        -: 3624:      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
        -: 3625:      out[0] = (stbi_uc)r;
        -: 3626:      out[1] = (stbi_uc)g;
        -: 3627:      out[2] = (stbi_uc)b;
        -: 3628:      out[3] = 255;
        -: 3629:      out += step;
        -: 3630:   }
        -: 3631:}
        -: 3632:
        -: 3633:#if defined(STBI_SSE2) || defined(STBI_NEON)
function _ZL23stbi__YCbCr_to_RGB_simdPhPKhS1_S1_ii called 0 returned 0% blocks executed 0%
    #####: 3634:static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
        -: 3635:{
        -: 3636:   int i = 0;
        -: 3637:
        -: 3638:#ifdef STBI_SSE2
        -: 3639:   // step == 3 is pretty ugly on the final interleave, and i'm not convinced
        -: 3640:   // it's useful in practice (you wouldn't use it for textures, for example).
        -: 3641:   // so just accelerate step == 4 case.
    #####: 3642:   if (step == 4) {
    %%%%%: 3642-block  0
branch  0 never executed
branch  1 never executed
        -: 3643:      // this is a fairly straightforward implementation and not super-optimized.
        -: 3644:      __m128i signflip  = _mm_set1_epi8(-0x80);
        -: 3645:      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
        -: 3646:      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
        -: 3647:      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
        -: 3648:      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
        -: 3649:      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
        -: 3650:      __m128i xw = _mm_set1_epi16(255); // alpha channel
        -: 3651:
    #####: 3652:      for (; i+7 < count; i += 8) {
    %%%%%: 3652-block  0
branch  0 never executed
branch  1 never executed
        -: 3653:         // load
    #####: 3654:         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
    %%%%%: 3654-block  0
call    0 never executed
    #####: 3655:         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
    #####: 3656:         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
    %%%%%: 3656-block  0
call    0 never executed
        -: 3657:         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
        -: 3658:         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128
        -: 3659:
        -: 3660:         // unpack to short (and left-shift cr, cb by 8)
        -: 3661:         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
        -: 3662:         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
        -: 3663:         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);
        -: 3664:
        -: 3665:         // color transform
        -: 3666:         __m128i yws = _mm_srli_epi16(yw, 4);
        -: 3667:         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
        -: 3668:         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
        -: 3669:         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
        -: 3670:         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
        -: 3671:         __m128i rws = _mm_add_epi16(cr0, yws);
        -: 3672:         __m128i gwt = _mm_add_epi16(cb0, yws);
        -: 3673:         __m128i bws = _mm_add_epi16(yws, cb1);
        -: 3674:         __m128i gws = _mm_add_epi16(gwt, cr1);
        -: 3675:
        -: 3676:         // descale
        -: 3677:         __m128i rw = _mm_srai_epi16(rws, 4);
        -: 3678:         __m128i bw = _mm_srai_epi16(bws, 4);
        -: 3679:         __m128i gw = _mm_srai_epi16(gws, 4);
        -: 3680:
        -: 3681:         // back to byte, set up for transpose
        -: 3682:         __m128i brb = _mm_packus_epi16(rw, bw);
        -: 3683:         __m128i gxb = _mm_packus_epi16(gw, xw);
        -: 3684:
        -: 3685:         // transpose to interleave channels
        -: 3686:         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
        -: 3687:         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
        -: 3688:         __m128i o0 = _mm_unpacklo_epi16(t0, t1);
        -: 3689:         __m128i o1 = _mm_unpackhi_epi16(t0, t1);
        -: 3690:
        -: 3691:         // store
        -: 3692:         _mm_storeu_si128((__m128i *) (out + 0), o0);
        -: 3693:         _mm_storeu_si128((__m128i *) (out + 16), o1);
    #####: 3694:         out += 32;
        -: 3695:      }
        -: 3696:   }
        -: 3697:#endif
        -: 3698:
        -: 3699:#ifdef STBI_NEON
        -: 3700:   // in this version, step=3 support would be easy to add. but is there demand?
        -: 3701:   if (step == 4) {
        -: 3702:      // this is a fairly straightforward implementation and not super-optimized.
        -: 3703:      uint8x8_t signflip = vdup_n_u8(0x80);
        -: 3704:      int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
        -: 3705:      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
        -: 3706:      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
        -: 3707:      int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));
        -: 3708:
        -: 3709:      for (; i+7 < count; i += 8) {
        -: 3710:         // load
        -: 3711:         uint8x8_t y_bytes  = vld1_u8(y + i);
        -: 3712:         uint8x8_t cr_bytes = vld1_u8(pcr + i);
        -: 3713:         uint8x8_t cb_bytes = vld1_u8(pcb + i);
        -: 3714:         int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
        -: 3715:         int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
        -: 3716:
        -: 3717:         // expand to s16
        -: 3718:         int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
        -: 3719:         int16x8_t crw = vshll_n_s8(cr_biased, 7);
        -: 3720:         int16x8_t cbw = vshll_n_s8(cb_biased, 7);
        -: 3721:
        -: 3722:         // color transform
        -: 3723:         int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
        -: 3724:         int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
        -: 3725:         int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
        -: 3726:         int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
        -: 3727:         int16x8_t rws = vaddq_s16(yws, cr0);
        -: 3728:         int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
        -: 3729:         int16x8_t bws = vaddq_s16(yws, cb1);
        -: 3730:
        -: 3731:         // undo scaling, round, convert to byte
        -: 3732:         uint8x8x4_t o;
        -: 3733:         o.val[0] = vqrshrun_n_s16(rws, 4);
        -: 3734:         o.val[1] = vqrshrun_n_s16(gws, 4);
        -: 3735:         o.val[2] = vqrshrun_n_s16(bws, 4);
        -: 3736:         o.val[3] = vdup_n_u8(255);
        -: 3737:
        -: 3738:         // store, interleaving r/g/b/a
        -: 3739:         vst4_u8(out, o);
        -: 3740:         out += 8*4;
        -: 3741:      }
        -: 3742:   }
        -: 3743:#endif
        -: 3744:
    #####: 3745:   for (; i < count; ++i) {
    %%%%%: 3745-block  0
branch  0 never executed
branch  1 never executed
    #####: 3746:      int y_fixed = (y[i] << 20) + (1<<19); // rounding
        -: 3747:      int r,g,b;
    #####: 3748:      int cr = pcr[i] - 128;
    #####: 3749:      int cb = pcb[i] - 128;
    #####: 3750:      r = y_fixed + cr* stbi__float2fixed(1.40200f);
    #####: 3751:      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
    #####: 3752:      b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
    #####: 3753:      r >>= 20;
    #####: 3754:      g >>= 20;
    #####: 3755:      b >>= 20;
    #####: 3756:      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
    %%%%%: 3756-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3756-block  1
branch  2 never executed
branch  3 never executed
    #####: 3757:      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
    %%%%%: 3757-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3757-block  1
branch  2 never executed
branch  3 never executed
    #####: 3758:      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
    %%%%%: 3758-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3758-block  1
branch  2 never executed
branch  3 never executed
    #####: 3759:      out[0] = (stbi_uc)r;
    #####: 3760:      out[1] = (stbi_uc)g;
    #####: 3761:      out[2] = (stbi_uc)b;
    #####: 3762:      out[3] = 255;
    #####: 3763:      out += step;
    %%%%%: 3763-block  0
        -: 3764:   }
    #####: 3765:}
        -: 3766:#endif
        -: 3767:
        -: 3768:// set up the kernels
        -: 3769:static void stbi__setup_jpeg(stbi__jpeg *j)
        -: 3770:{
        -: 3771:   j->idct_block_kernel = stbi__idct_block;
        -: 3772:   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
        -: 3773:   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;
        -: 3774:
        -: 3775:#ifdef STBI_SSE2
        -: 3776:   if (stbi__sse2_available()) {
    #####: 3777:      j->idct_block_kernel = stbi__idct_simd;
    #####: 3778:      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
    #####: 3779:      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
        -: 3780:   }
        -: 3781:#endif
        -: 3782:
        -: 3783:#ifdef STBI_NEON
        -: 3784:   j->idct_block_kernel = stbi__idct_simd;
        -: 3785:   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
        -: 3786:   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
        -: 3787:#endif
        -: 3788:}
        -: 3789:
        -: 3790:// clean up the temporary component buffers
        -: 3791:static void stbi__cleanup_jpeg(stbi__jpeg *j)
        -: 3792:{
    #####: 3793:   stbi__free_jpeg_components(j, j->s->img_n, 0);
    %%%%%: 3793-block  0
call    0 never executed
    %%%%%: 3793-block  1
call    1 never executed
    %%%%%: 3793-block  2
call    2 never executed
    %%%%%: 3793-block  3
call    3 never executed
    %%%%%: 3793-block  4
call    4 never executed
        -: 3794:}
        -: 3795:
        -: 3796:typedef struct
        -: 3797:{
        -: 3798:   resample_row_func resample;
        -: 3799:   stbi_uc *line0,*line1;
        -: 3800:   int hs,vs;   // expansion factor in each axis
        -: 3801:   int w_lores; // horizontal pixels pre-expansion
        -: 3802:   int ystep;   // how far through vertical expansion we are
        -: 3803:   int ypos;    // which pre-expansion row we're on
        -: 3804:} stbi__resample;
        -: 3805:
        -: 3806:// fast 0..255 * 0..255 => 0..255 rounded multiplication
        -: 3807:static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
        -: 3808:{
    #####: 3809:   unsigned int t = x*y + 128;
    #####: 3810:   return (stbi_uc) ((t + (t >>8)) >> 8);
        -: 3811:}
        -: 3812:
function _ZL15load_jpeg_imageP10stbi__jpegPiS1_S1_i called 0 returned 0% blocks executed 0%
    #####: 3813:static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
        -: 3814:{
        -: 3815:   int n, decode_n, is_rgb;
    #####: 3816:   z->s->img_n = 0; // make stbi__cleanup_jpeg safe
        -: 3817:
        -: 3818:   // validate req_comp
    #####: 3819:   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
    %%%%%: 3819-block  0
branch  0 never executed
branch  1 never executed
        -: 3820:
        -: 3821:   // load a jpeg image from whichever source, but leave in YCbCr format
    #####: 3822:   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }
    %%%%%: 3822-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3823:
        -: 3824:   // determine actual number of components to generate
    #####: 3825:   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;
    %%%%%: 3825-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3825-block  1
branch  2 never executed
branch  3 never executed
        -: 3826:
    #####: 3827:   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));
    %%%%%: 3827-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3827-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 3827-block  2
branch  4 never executed
branch  5 never executed
        -: 3828:
    #####: 3829:   if (z->s->img_n == 3 && n < 3 && !is_rgb)
    %%%%%: 3829-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3829-block  1
branch  2 never executed
branch  3 never executed
        -: 3830:      decode_n = 1;
        -: 3831:   else
        -: 3832:      decode_n = z->s->img_n;
        -: 3833:
        -: 3834:   // nothing to do if no components requested; check this now to avoid
        -: 3835:   // accessing uninitialized coutput[0] later
    #####: 3836:   if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }
    %%%%%: 3836-block  0
branch  0 never executed
branch  1 never executed
        -: 3837:
        -: 3838:   // resample and color-convert
        -: 3839:   {
        -: 3840:      int k;
        -: 3841:      unsigned int i,j;
        -: 3842:      stbi_uc *output;
    #####: 3843:      stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };
    %%%%%: 3843-block  0
        -: 3844:
        -: 3845:      stbi__resample res_comp[4];
        -: 3846:
    #####: 3847:      for (k=0; k < decode_n; ++k) {
    %%%%%: 3847-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3847-block  1
        -: 3848:         stbi__resample *r = &res_comp[k];
        -: 3849:
        -: 3850:         // allocate line buffer big enough for upsampling off the edges
        -: 3851:         // with upsample factor of 4
    #####: 3852:         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
    #####: 3853:         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
    %%%%%: 3853-block  0
branch  0 never executed
branch  1 never executed
        -: 3854:
    #####: 3855:         r->hs      = z->img_h_max / z->img_comp[k].h;
    #####: 3856:         r->vs      = z->img_v_max / z->img_comp[k].v;
    #####: 3857:         r->ystep   = r->vs >> 1;
    #####: 3858:         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
    #####: 3859:         r->ypos    = 0;
    #####: 3860:         r->line0   = r->line1 = z->img_comp[k].data;
        -: 3861:
    #####: 3862:         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
    %%%%%: 3862-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3862-block  1
    #####: 3863:         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
    %%%%%: 3863-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3863-block  1
    #####: 3864:         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
    %%%%%: 3864-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3864-block  1
    #####: 3865:         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
    %%%%%: 3865-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3865-block  1
    #####: 3866:         else                               r->resample = stbi__resample_row_generic;
    %%%%%: 3866-block  0
        -: 3867:      }
        -: 3868:
        -: 3869:      // can't error after this so, this is safe
    #####: 3870:      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
    %%%%%: 3870-block  0
call    0 never executed
    #####: 3871:      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
branch  0 never executed
branch  1 never executed
        -: 3872:
        -: 3873:      // now go ahead and resample
    #####: 3874:      for (j=0; j < z->s->img_y; ++j) {
    %%%%%: 3874-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3874-block  1
    #####: 3875:         stbi_uc *out = output + n * z->s->img_x * j;
    %%%%%: 3875-block  0
    #####: 3876:         for (k=0; k < decode_n; ++k) {
    %%%%%: 3876-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3876-block  1
        -: 3877:            stbi__resample *r = &res_comp[k];
    #####: 3878:            int y_bot = r->ystep >= (r->vs >> 1);
    #####: 3879:            coutput[k] = r->resample(z->img_comp[k].linebuf,
    %%%%%: 3879-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3879-block  1
    %%%%%: 3879-block  2
    %%%%%: 3879-block  3
branch  2 never executed
branch  3 never executed
    %%%%%: 3879-block  4
    %%%%%: 3879-block  5
    %%%%%: 3879-block  6
call    4 never executed
        -: 3880:                                     y_bot ? r->line1 : r->line0,
        -: 3881:                                     y_bot ? r->line0 : r->line1,
        -: 3882:                                     r->w_lores, r->hs);
    #####: 3883:            if (++r->ystep >= r->vs) {
branch  0 never executed
branch  1 never executed
    #####: 3884:               r->ystep = 0;
    #####: 3885:               r->line0 = r->line1;
    #####: 3886:               if (++r->ypos < z->img_comp[k].y)
    %%%%%: 3886-block  0
branch  0 never executed
branch  1 never executed
    #####: 3887:                  r->line1 += z->img_comp[k].w2;
    %%%%%: 3887-block  0
        -: 3888:            }
        -: 3889:         }
    #####: 3890:         if (n >= 3) {
    %%%%%: 3890-block  0
branch  0 never executed
branch  1 never executed
    #####: 3891:            stbi_uc *y = coutput[0];
    #####: 3892:            if (z->s->img_n == 3) {
    %%%%%: 3892-block  0
branch  0 never executed
branch  1 never executed
    #####: 3893:               if (is_rgb) {
    %%%%%: 3893-block  0
branch  0 never executed
branch  1 never executed
    #####: 3894:                  for (i=0; i < z->s->img_x; ++i) {
    %%%%%: 3894-block  0
branch  0 never executed
branch  1 never executed
    #####: 3895:                     out[0] = y[i];
    #####: 3896:                     out[1] = coutput[1][i];
    #####: 3897:                     out[2] = coutput[2][i];
    #####: 3898:                     out[3] = 255;
    #####: 3899:                     out += n;
    %%%%%: 3899-block  0
        -: 3900:                  }
        -: 3901:               } else {
    #####: 3902:                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
    %%%%%: 3902-block  0
call    0 never executed
        -: 3903:               }
    #####: 3904:            } else if (z->s->img_n == 4) {
    %%%%%: 3904-block  0
branch  0 never executed
branch  1 never executed
    #####: 3905:               if (z->app14_color_transform == 0) { // CMYK
    %%%%%: 3905-block  0
branch  0 never executed
branch  1 never executed
    #####: 3906:                  for (i=0; i < z->s->img_x; ++i) {
    %%%%%: 3906-block  0
branch  0 never executed
branch  1 never executed
    #####: 3907:                     stbi_uc m = coutput[3][i];
    #####: 3908:                     out[0] = stbi__blinn_8x8(coutput[0][i], m);
    #####: 3909:                     out[1] = stbi__blinn_8x8(coutput[1][i], m);
    #####: 3910:                     out[2] = stbi__blinn_8x8(coutput[2][i], m);
    #####: 3911:                     out[3] = 255;
    #####: 3912:                     out += n;
    %%%%%: 3912-block  0
        -: 3913:                  }
    #####: 3914:               } else if (z->app14_color_transform == 2) { // YCCK
    %%%%%: 3914-block  0
branch  0 never executed
branch  1 never executed
    #####: 3915:                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
    %%%%%: 3915-block  0
call    0 never executed
    #####: 3916:                  for (i=0; i < z->s->img_x; ++i) {
    %%%%%: 3916-block  0
branch  0 never executed
branch  1 never executed
    #####: 3917:                     stbi_uc m = coutput[3][i];
    #####: 3918:                     out[0] = stbi__blinn_8x8(255 - out[0], m);
    #####: 3919:                     out[1] = stbi__blinn_8x8(255 - out[1], m);
    #####: 3920:                     out[2] = stbi__blinn_8x8(255 - out[2], m);
    #####: 3921:                     out += n;
    %%%%%: 3921-block  0
        -: 3922:                  }
        -: 3923:               } else { // YCbCr + alpha?  Ignore the fourth channel for now
    #####: 3924:                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
    %%%%%: 3924-block  0
call    0 never executed
        -: 3925:               }
        -: 3926:            } else
    #####: 3927:               for (i=0; i < z->s->img_x; ++i) {
    %%%%%: 3927-block  0
branch  0 never executed
branch  1 never executed
    #####: 3928:                  out[0] = out[1] = out[2] = y[i];
    #####: 3929:                  out[3] = 255; // not used if n==3
    #####: 3930:                  out += n;
    %%%%%: 3930-block  0
        -: 3931:               }
        -: 3932:         } else {
    #####: 3933:            if (is_rgb) {
    %%%%%: 3933-block  0
branch  0 never executed
branch  1 never executed
    #####: 3934:               if (n == 1)
    %%%%%: 3934-block  0
branch  0 never executed
branch  1 never executed
    #####: 3935:                  for (i=0; i < z->s->img_x; ++i)
    %%%%%: 3935-block  0
branch  0 never executed
branch  1 never executed
    #####: 3936:                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
    %%%%%: 3936-block  0
        -: 3937:               else {
    #####: 3938:                  for (i=0; i < z->s->img_x; ++i, out += 2) {
    %%%%%: 3938-block  0
branch  0 never executed
branch  1 never executed
    #####: 3939:                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
    #####: 3940:                     out[1] = 255;
    %%%%%: 3940-block  0
        -: 3941:                  }
        -: 3942:               }
    #####: 3943:            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
    %%%%%: 3943-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3943-block  1
branch  2 never executed
branch  3 never executed
    #####: 3944:               for (i=0; i < z->s->img_x; ++i) {
    %%%%%: 3944-block  0
branch  0 never executed
branch  1 never executed
    #####: 3945:                  stbi_uc m = coutput[3][i];
    #####: 3946:                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
    #####: 3947:                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
    #####: 3948:                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
    #####: 3949:                  out[0] = stbi__compute_y(r, g, b);
    #####: 3950:                  out[1] = 255;
    #####: 3951:                  out += n;
    %%%%%: 3951-block  0
        -: 3952:               }
    #####: 3953:            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
    %%%%%: 3953-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3953-block  1
branch  2 never executed
branch  3 never executed
    #####: 3954:               for (i=0; i < z->s->img_x; ++i) {
    %%%%%: 3954-block  0
branch  0 never executed
branch  1 never executed
    #####: 3955:                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
    #####: 3956:                  out[1] = 255;
    #####: 3957:                  out += n;
    %%%%%: 3957-block  0
        -: 3958:               }
        -: 3959:            } else {
    #####: 3960:               stbi_uc *y = coutput[0];
    #####: 3961:               if (n == 1)
    %%%%%: 3961-block  0
branch  0 never executed
branch  1 never executed
    #####: 3962:                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
    %%%%%: 3962-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3962-block  1
        -: 3963:               else
    #####: 3964:                  for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
    %%%%%: 3964-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 3964-block  1
        -: 3965:            }
        -: 3966:         }
        -: 3967:      }
        -: 3968:      stbi__cleanup_jpeg(z);
    #####: 3969:      *out_x = z->s->img_x;
    #####: 3970:      *out_y = z->s->img_y;
    #####: 3971:      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
branch  0 never executed
branch  1 never executed
    %%%%%: 3971-block  0
branch  2 never executed
branch  3 never executed
    %%%%%: 3971-block  1
        -: 3972:      return output;
        -: 3973:   }
        -: 3974:}
        -: 3975:
function _ZL15stbi__jpeg_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 3976:static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 3977:{
        -: 3978:   unsigned char* result;
        -: 3979:   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
    #####: 3980:   if (!j) return stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 3980-block  0
branch  0 never executed
branch  1 never executed
        -: 3981:   STBI_NOTUSED(ri);
    #####: 3982:   j->s = s;
        -: 3983:   stbi__setup_jpeg(j);
    #####: 3984:   result = load_jpeg_image(j, x,y,comp,req_comp);
    %%%%%: 3984-block  0
call    0 never executed
    #####: 3985:   STBI_FREE(j);
    #####: 3986:   return result;
        -: 3987:}
        -: 3988:
function _ZL15stbi__jpeg_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 3989:static int stbi__jpeg_test(stbi__context *s)
        -: 3990:{
        -: 3991:   int r;
        -: 3992:   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
    #####: 3993:   if (!j) return stbi__err("outofmem", "Out of memory");
    %%%%%: 3993-block  0
branch  0 never executed
branch  1 never executed
    #####: 3994:   j->s = s;
        -: 3995:   stbi__setup_jpeg(j);
    #####: 3996:   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
    %%%%%: 3996-block  0
call    0 never executed
        -: 3997:   stbi__rewind(s);
    #####: 3998:   STBI_FREE(j);
    #####: 3999:   return r;
        -: 4000:}
        -: 4001:
function _ZL19stbi__jpeg_info_rawP10stbi__jpegPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 4002:static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
        -: 4003:{
    #####: 4004:   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
    %%%%%: 4004-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4005:      stbi__rewind( j->s );
    #####: 4006:      return 0;
    %%%%%: 4006-block  0
        -: 4007:   }
    #####: 4008:   if (x) *x = j->s->img_x;
    %%%%%: 4008-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4008-block  1
    #####: 4009:   if (y) *y = j->s->img_y;
    %%%%%: 4009-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4009-block  1
    #####: 4010:   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
    %%%%%: 4010-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4010-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 4010-block  2
        -: 4011:   return 1;
        -: 4012:}
        -: 4013:
function _ZL15stbi__jpeg_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 4014:static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
        -: 4015:{
        -: 4016:   int result;
        -: 4017:   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
    #####: 4018:   if (!j) return stbi__err("outofmem", "Out of memory");
    %%%%%: 4018-block  0
branch  0 never executed
branch  1 never executed
    #####: 4019:   j->s = s;
    #####: 4020:   result = stbi__jpeg_info_raw(j, x, y, comp);
    %%%%%: 4020-block  0
call    0 never executed
    #####: 4021:   STBI_FREE(j);
    #####: 4022:   return result;
        -: 4023:}
        -: 4024:#endif
        -: 4025:
        -: 4026:// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
        -: 4027://    simple implementation
        -: 4028://      - all input must be provided in an upfront buffer
        -: 4029://      - all output is written to a single output buffer (can malloc/realloc)
        -: 4030://    performance
        -: 4031://      - fast huffman
        -: 4032:
        -: 4033:#ifndef STBI_NO_ZLIB
        -: 4034:
        -: 4035:// fast-way is faster to check than jpeg huffman, but slow way is slower
        -: 4036:#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
        -: 4037:#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
        -: 4038:#define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet
        -: 4039:
        -: 4040:// zlib-style huffman encoding
        -: 4041:// (jpegs packs from left, zlib from right, so can't share code)
        -: 4042:typedef struct
        -: 4043:{
        -: 4044:   stbi__uint16 fast[1 << STBI__ZFAST_BITS];
        -: 4045:   stbi__uint16 firstcode[16];
        -: 4046:   int maxcode[17];
        -: 4047:   stbi__uint16 firstsymbol[16];
        -: 4048:   stbi_uc  size[STBI__ZNSYMS];
        -: 4049:   stbi__uint16 value[STBI__ZNSYMS];
        -: 4050:} stbi__zhuffman;
        -: 4051:
function _ZL18stbi__bitreverse16i called 99732 returned 100% blocks executed 100%
    99732: 4052:stbi_inline static int stbi__bitreverse16(int n)
        -: 4053:{
    99732: 4054:  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
    99732: 4055:  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
    99732: 4056:  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
    99732: 4057:  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
    99732: 4058:  return n;
        -: 4059:}
        -: 4060:
function _ZL17stbi__bit_reverseii called 4023 returned 100% blocks executed 67%
     4023: 4061:stbi_inline static int stbi__bit_reverse(int v, int bits)
        -: 4062:{
    4023*: 4063:   STBI_ASSERT(bits <= 16);
     4023: 4063-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 4023
    %%%%%: 4063-block  1
call    2 never executed
        -: 4064:   // to bit reverse n bits, reverse 16 and shift
        -: 4065:   // e.g. 11 bits, bit reverse and shift away 5
    99732: 4066:   return stbi__bitreverse16(v) >> (16-bits);
        -: 4067:}
        -: 4068:
function _ZL20stbi__zbuild_huffmanP14stbi__zhuffmanPKhi called 138 returned 100% blocks executed 100%
      138: 4069:static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
      138: 4069-block  0
        -: 4070:{
        -: 4071:   int i,k=0;
        -: 4072:   int code, next_code[16], sizes[17];
        -: 4073:
        -: 4074:   // DEFLATE spec for generating codes
        -: 4075:   memset(sizes, 0, sizeof(sizes));
      138: 4076:   memset(z->fast, 0, sizeof(z->fast));
      138: 4076-block  0
    15548: 4077:   for (i=0; i < num; ++i)
    15548: 4077-block  0
branch  0 taken 15410 (fallthrough)
branch  1 taken 138
    15410: 4078:      ++sizes[sizelist[i]];
    15410: 4078-block  0
      138: 4079:   sizes[0] = 0;
      138: 4079-block  0
     2208: 4080:   for (i=1; i < 16; ++i)
     2208: 4080-block  0
branch  0 taken 2070 (fallthrough)
branch  1 taken 138
     2070: 4080-block  1
     2070: 4081:      if (sizes[i] > (1 << i))
     2070: 4081-block  0
branch  0 taken 2070 (fallthrough)
branch  1 taken 0
        -: 4082:         return stbi__err("bad sizes", "Corrupt PNG");
        -: 4083:   code = 0;
     2208: 4084:   for (i=1; i < 16; ++i) {
     2208: 4084-block  0
branch  0 taken 2070 (fallthrough)
branch  1 taken 138
     2070: 4085:      next_code[i] = code;
     2070: 4086:      z->firstcode[i] = (stbi__uint16) code;
     2070: 4087:      z->firstsymbol[i] = (stbi__uint16) k;
     2070: 4088:      code = (code + sizes[i]);
     2070: 4089:      if (sizes[i])
     2070: 4089-block  0
branch  0 taken 1212 (fallthrough)
branch  1 taken 858
     1212: 4090:         if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
     1212: 4090-block  0
branch  0 taken 1212 (fallthrough)
branch  1 taken 0
     2070: 4091:      z->maxcode[i] = code << (16-i); // preshift for inner loop
     2070: 4092:      code <<= 1;
     2070: 4093:      k += sizes[i];
     2070: 4093-block  0
        -: 4094:   }
      138: 4095:   z->maxcode[16] = 0x10000; // sentinel
      138: 4095-block  0
    15548: 4096:   for (i=0; i < num; ++i) {
    15548: 4096-block  0
branch  0 taken 15410 (fallthrough)
branch  1 taken 138
    15410: 4096-block  1
    15410: 4097:      int s = sizelist[i];
    15410: 4098:      if (s) {
    15410: 4098-block  0
branch  0 taken 14620 (fallthrough)
branch  1 taken 790
    14620: 4099:         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
    14620: 4100:         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
    14620: 4101:         z->size [c] = (stbi_uc     ) s;
    14620: 4102:         z->value[c] = (stbi__uint16) i;
    14620: 4103:         if (s <= STBI__ZFAST_BITS) {
    14620: 4103-block  0
branch  0 taken 4023 (fallthrough)
branch  1 taken 10597
     4023: 4104:            int j = stbi__bit_reverse(next_code[s],s);
     4023: 4104-block  0
call    0 returned 4023
    71898: 4105:            while (j < (1 << STBI__ZFAST_BITS)) {
    71898: 4105-block  0
branch  0 taken 67875 (fallthrough)
branch  1 taken 4023
    67875: 4106:               z->fast[j] = fastv;
    67875: 4107:               j += (1 << s);
    67875: 4107-block  0
        -: 4108:            }
        -: 4109:         }
    14620: 4110:         ++next_code[s];
    14620: 4110-block  0
        -: 4111:      }
        -: 4112:   }
        -: 4113:   return 1;
        -: 4114:}
        -: 4115:
        -: 4116:// zlib-from-memory implementation for PNG reading
        -: 4117://    because PNG allows splitting the zlib stream arbitrarily,
        -: 4118://    and it's annoying structurally to have PNG call ZLIB call PNG,
        -: 4119://    we require PNG read all the IDATs and combine them into a single
        -: 4120://    memory buffer
        -: 4121:
        -: 4122:typedef struct
        -: 4123:{
        -: 4124:   stbi_uc *zbuffer, *zbuffer_end;
        -: 4125:   int num_bits;
        -: 4126:   stbi__uint32 code_buffer;
        -: 4127:
        -: 4128:   char *zout;
        -: 4129:   char *zout_start;
        -: 4130:   char *zout_end;
        -: 4131:   int   z_expandable;
        -: 4132:
        -: 4133:   stbi__zhuffman z_length, z_distance;
        -: 4134:} stbi__zbuf;
        -: 4135:
        -: 4136:stbi_inline static int stbi__zeof(stbi__zbuf *z)
        -: 4137:{
 1247358*: 4138:   return (z->zbuffer >= z->zbuffer_end);
        -: 4139:}
        -: 4140:
        -: 4141:stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
        -: 4142:{
  876496*: 4143:   return stbi__zeof(z) ? 0 : *z->zbuffer++;
        1: 4143-block  0
        1: 4143-block  1
    %%%%%: 4143-block  2
branch  0 never executed
branch  1 never executed
    %%%%%: 4143-block  3
   876494: 4143-block  4
branch  2 taken 876494 (fallthrough)
branch  3 taken 0
   876494: 4143-block  5
        -: 4144:}
        -: 4145:
function _ZL15stbi__fill_bitsP10stbi__zbuf called 371419 returned 100% blocks executed 86%
   371419: 4146:static void stbi__fill_bits(stbi__zbuf *z)
   371419: 4146-block  0
        -: 4147:{
        -: 4148:   do {
   876494: 4149:      if (z->code_buffer >= (1U << z->num_bits)) {
   876494: 4149-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 876494
    #####: 4150:        z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
    #####: 4151:        return;
    %%%%%: 4151-block  0
        -: 4152:      }
   876494: 4153:      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
   876494: 4154:      z->num_bits += 8;
   876494: 4155:   } while (z->num_bits <= 24);
   876494: 4155-block  0
branch  0 taken 505075
branch  1 taken 371419 (fallthrough)
        -: 4156:}
        -: 4157:
function _ZL14stbi__zreceiveP10stbi__zbufi called 252683 returned 100% blocks executed 100%
   252683: 4158:stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
        -: 4159:{
        -: 4160:   unsigned int k;
  254236*: 4161:   if (z->num_bits < n) stbi__fill_bits(z);
       46: 4161-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 45
        1: 4161-block  1
call    2 returned 1
        3: 4161-block  2
call    3 returned 3
       12: 4161-block  3
call    4 returned 12
       10: 4161-block  4
call    5 returned 10
       14: 4161-block  5
call    6 returned 14
      783: 4161-block  6
branch  7 taken 86 (fallthrough)
branch  8 taken 697
       86: 4161-block  7
call    9 returned 86
      635: 4161-block  8
branch 10 taken 0 (fallthrough)
branch 11 taken 635
    %%%%%: 4161-block  9
call   12 never executed
       48: 4161-block 10
branch 13 taken 0 (fallthrough)
branch 14 taken 48
    %%%%%: 4161-block 11
call   15 never executed
        2: 4161-block 12
branch 16 taken 0 (fallthrough)
branch 17 taken 2
    %%%%%: 4161-block 13
call   18 never executed
   252683: 4161-block 14
branch 19 taken 432 (fallthrough)
branch 20 taken 252251
      432: 4161-block 15
call   21 returned 432
   254381: 4162:   k = z->code_buffer & ((1 << n) - 1);
   254381: 4163:   z->code_buffer >>= n;
       46: 4164:   z->num_bits -= n;
       46: 4164-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 43
   252683: 4165:   return k;
        -: 4166:}
        -: 4167:
function _ZL30stbi__zhuffman_decode_slowpathP10stbi__zbufP14stbi__zhuffman called 95709 returned 100% blocks executed 100%
    95709: 4168:static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
        -: 4169:{
        -: 4170:   int b,s,k;
        -: 4171:   // not resolved by fast table, so compute it the slow way
        -: 4172:   // use jpeg approach, which requires MSbits at top
    95709: 4173:   k = stbi__bit_reverse(a->code_buffer, 16);
    95709: 4173-block  0
    62254: 4174:   for (s=STBI__ZFAST_BITS+1; ; ++s)
    62254: 4174-block  0
   157963: 4175:      if (k < z->maxcode[s])
   157963: 4175-block  0
branch  0 taken 62254 (fallthrough)
branch  1 taken 95709
        -: 4176:         break;
    95709: 4177:   if (s >= 16) return -1; // invalid code!
    95709: 4177-block  0
branch  0 taken 95709 (fallthrough)
branch  1 taken 0
        -: 4178:   // code size is s, so:
    95709: 4179:   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
    95709: 4180:   if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
    95709: 4180-block  0
branch  0 taken 95709 (fallthrough)
branch  1 taken 0
    95709: 4181:   if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
    95709: 4181-block  0
branch  0 taken 95709 (fallthrough)
branch  1 taken 0
    95709: 4182:   a->code_buffer >>= s;
    95709: 4183:   a->num_bits -= s;
    95709: 4184:   return z->value[b];
    95709: 4184-block  0
        -: 4185:}
        -: 4186:
function _ZL21stbi__zhuffman_decodeP10stbi__zbufP14stbi__zhuffman called 988423 returned 100% blocks executed 100%
   988423: 4187:stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
        -: 4188:{
        -: 4189:   int b,s;
   988423: 4190:   if (a->num_bits < 16) {
   988423: 4190-block  0
branch  0 taken 370861 (fallthrough)
branch  1 taken 617562
   370861: 4191:      if (stbi__zeof(a)) {
   370861: 4191-block  0
branch  0 taken 370861 (fallthrough)
branch  1 taken 0
        -: 4192:         return -1;   /* report error for unexpected end of data. */
        -: 4193:      }
   370861: 4194:      stbi__fill_bits(a);
   370861: 4194-block  0
call    0 returned 370861
        -: 4195:   }
   988423: 4196:   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
   988423: 4197:   if (b) {
   988423: 4197-block  0
branch  0 taken 892714 (fallthrough)
branch  1 taken 95709
   892714: 4198:      s = b >> 9;
   892714: 4199:      a->code_buffer >>= s;
   892714: 4200:      a->num_bits -= s;
   892714: 4201:      return b & 511;
   892714: 4201-block  0
        -: 4202:   }
    95709: 4203:   return stbi__zhuffman_decode_slowpath(a, z);
    95709: 4203-block  0
call    0 returned 95709
        -: 4204:}
        -: 4205:
function _ZL13stbi__zexpandP10stbi__zbufPci called 0 returned 0% blocks executed 0%
    #####: 4206:static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
        -: 4207:{
        -: 4208:   char *q;
        -: 4209:   unsigned int cur, limit, old_limit;
    #####: 4210:   z->zout = zout;
    #####: 4211:   if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
    %%%%%: 4211-block  0
branch  0 never executed
branch  1 never executed
    #####: 4212:   cur   = (unsigned int) (z->zout - z->zout_start);
    #####: 4213:   limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
    #####: 4214:   if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");
    %%%%%: 4214-block  0
branch  0 never executed
branch  1 never executed
    #####: 4215:   while (cur + n > limit) {
    %%%%%: 4215-block  0
branch  0 never executed
branch  1 never executed
    #####: 4216:      if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");
    %%%%%: 4216-block  0
branch  0 never executed
branch  1 never executed
    #####: 4217:      limit *= 2;
    %%%%%: 4217-block  0
        -: 4218:   }
    #####: 4219:   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
        -: 4220:   STBI_NOTUSED(old_limit);
    #####: 4221:   if (q == NULL) return stbi__err("outofmem", "Out of memory");
    %%%%%: 4221-block  0
branch  0 never executed
branch  1 never executed
    #####: 4222:   z->zout_start = q;
    #####: 4223:   z->zout       = q + cur;
    #####: 4224:   z->zout_end   = q + limit;
    #####: 4225:   return 1;
    %%%%%: 4225-block  0
        -: 4226:}
        -: 4227:
        -: 4228:static const int stbi__zlength_base[31] = {
        -: 4229:   3,4,5,6,7,8,9,10,11,13,
        -: 4230:   15,17,19,23,27,31,35,43,51,59,
        -: 4231:   67,83,99,115,131,163,195,227,258,0,0 };
        -: 4232:
        -: 4233:static const int stbi__zlength_extra[31]=
        -: 4234:{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };
        -: 4235:
        -: 4236:static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
        -: 4237:257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};
        -: 4238:
        -: 4239:static const int stbi__zdist_extra[32] =
        -: 4240:{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
        -: 4241:
function _ZL25stbi__parse_huffman_blockP10stbi__zbuf called 46 returned 100% blocks executed 81%
       46: 4242:static int stbi__parse_huffman_block(stbi__zbuf *a)
        -: 4243:{
       46: 4244:   char *zout = a->zout;
       46: 4244-block  0
        -: 4245:   for(;;) {
   740196: 4246:      int z = stbi__zhuffman_decode(a, &a->z_length);
   740196: 4246-block  0
call    0 returned 740196
   740196: 4247:      if (z < 256) {
branch  0 taken 504400 (fallthrough)
branch  1 taken 235796
   504400: 4248:         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
   504400: 4248-block  0
branch  0 taken 504400 (fallthrough)
branch  1 taken 0
   504400: 4249:         if (zout >= a->zout_end) {
   504400: 4249-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 504400
    #####: 4250:            if (!stbi__zexpand(a, zout, 1)) return 0;
    %%%%%: 4250-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4251:            zout = a->zout;
    %%%%%: 4251-block  0
        -: 4252:         }
   504400: 4253:         *zout++ = (char) z;
   504400: 4253-block  0
        -: 4254:      } else {
        -: 4255:         stbi_uc *p;
        -: 4256:         int len,dist;
   235796: 4257:         if (z == 256) {
   235796: 4257-block  0
branch  0 taken 46 (fallthrough)
branch  1 taken 235750
       46: 4258:            a->zout = zout;
       46: 4259:            return 1;
       46: 4259-block  0
        -: 4260:         }
   235750: 4261:         z -= 257;
   235750: 4262:         len = stbi__zlength_base[z];
   235750: 4263:         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
   235750: 4263-block  0
branch  0 taken 54357 (fallthrough)
branch  1 taken 181393
    54357: 4263-block  1
call    2 returned 54357
   235750: 4264:         z = stbi__zhuffman_decode(a, &a->z_distance);
   235750: 4264-block  0
call    0 returned 235750
   235750: 4265:         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG");
branch  0 taken 235750 (fallthrough)
branch  1 taken 0
   235750: 4266:         dist = stbi__zdist_base[z];
   235750: 4267:         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
   235750: 4267-block  0
branch  0 taken 198326 (fallthrough)
branch  1 taken 37424
   198326: 4267-block  1
call    2 returned 198326
   235750: 4268:         if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
   235750: 4268-block  0
branch  0 taken 235750 (fallthrough)
branch  1 taken 0
   235750: 4269:         if (zout + len > a->zout_end) {
   235750: 4269-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 235750
    #####: 4270:            if (!stbi__zexpand(a, zout, len)) return 0;
    %%%%%: 4270-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4271:            zout = a->zout;
    %%%%%: 4271-block  0
        -: 4272:         }
   235750: 4273:         p = (stbi_uc *) (zout - dist);
   235750: 4274:         if (dist == 1) { // run of one byte; common in images.
   235750: 4274-block  0
branch  0 taken 37011 (fallthrough)
branch  1 taken 198739
    37011: 4275:            stbi_uc v = *p;
  9007825: 4276:            if (len) { do *zout++ = v; while (--len); }
    37011: 4276-block  0
branch  0 taken 0
branch  1 taken 37011 (fallthrough)
  9007825: 4276-block  1
branch  2 taken 37011
branch  3 taken 8970814
        -: 4277:         } else {
  7267039: 4278:            if (len) { do *zout++ = *p++; while (--len); }
   198739: 4278-block  0
branch  0 taken 0
branch  1 taken 198739 (fallthrough)
  7267039: 4278-block  1
branch  2 taken 198739
branch  3 taken 7068300
        -: 4279:         }
        -: 4280:      }
        -: 4281:   }
        -: 4282:}
        -: 4283:
function _ZL27stbi__compute_huffman_codesP10stbi__zbuf called 46 returned 100% blocks executed 90%
       46: 4284:static int stbi__compute_huffman_codes(stbi__zbuf *a)
       46: 4284-block  0
branch  0 taken 12 (fallthrough)
branch  1 taken 34
        -: 4285:{
        -: 4286:   static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
        -: 4287:   stbi__zhuffman z_codelength;
        -: 4288:   stbi_uc lencodes[286+32+137];//padding for maximum single op
        -: 4289:   stbi_uc codelength_sizes[19];
        -: 4290:   int i,n;
        -: 4291:
       46: 4292:   int hlit  = stbi__zreceive(a,5) + 257;
       46: 4292-block  0
branch  0 taken 10 (fallthrough)
branch  1 taken 36
       46: 4293:   int hdist = stbi__zreceive(a,5) + 1;
       46: 4293-block  0
branch  0 taken 14 (fallthrough)
branch  1 taken 32
       46: 4294:   int hclen = stbi__zreceive(a,4) + 4;
       46: 4295:   int ntot  = hlit + hdist;
       46: 4295-block  0
        -: 4296:
        -: 4297:   memset(codelength_sizes, 0, sizeof(codelength_sizes));
      829: 4298:   for (i=0; i < hclen; ++i) {
      829: 4298-block  0
branch  0 taken 783 (fallthrough)
branch  1 taken 46
        -: 4299:      int s = stbi__zreceive(a,3);
      783: 4300:      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
      783: 4300-block  0
        -: 4301:   }
       46: 4302:   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;
       46: 4302-block  0
call    0 returned 46
branch  1 taken 46
branch  2 taken 0
        -: 4303:
        -: 4304:   n = 0;
    12523: 4305:   while (n < ntot) {
    12523: 4305-block  0
branch  0 taken 12477 (fallthrough)
branch  1 taken 46
    12477: 4306:      int c = stbi__zhuffman_decode(a, &z_codelength);
    12477: 4306-block  0
call    0 returned 12477
    12477: 4307:      if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
branch  0 taken 12477 (fallthrough)
branch  1 taken 0
    12477: 4308:      if (c < 16)
    12477: 4308-block  0
branch  0 taken 11792 (fallthrough)
branch  1 taken 685
    11792: 4309:         lencodes[n++] = (stbi_uc) c;
    11792: 4309-block  0
        -: 4310:      else {
        -: 4311:         stbi_uc fill = 0;
      685: 4312:         if (c == 16) {
      685: 4312-block  0
branch  0 taken 635 (fallthrough)
branch  1 taken 50
      635: 4313:            c = stbi__zreceive(a,2)+3;
      635: 4314:            if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
      635: 4314-block  0
branch  0 taken 635 (fallthrough)
branch  1 taken 0
      635: 4315:            fill = lencodes[n-1];
      635: 4315-block  0
       50: 4316:         } else if (c == 17) {
       50: 4316-block  0
branch  0 taken 48 (fallthrough)
branch  1 taken 2
       48: 4317:            c = stbi__zreceive(a,3)+3;
       48: 4317-block  0
        -: 4318:         } else if (c == 18) {
        2: 4319:            c = stbi__zreceive(a,7)+11;
        2: 4319-block  0
        -: 4320:         } else {
        -: 4321:            return stbi__err("bad codelengths", "Corrupt PNG");
        -: 4322:         }
      685: 4323:         if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
      685: 4323-block  0
branch  0 taken 685 (fallthrough)
branch  1 taken 0
      685: 4324:         memset(lencodes+n, fill, c);
      685: 4324-block  0
      685: 4325:         n += c;
      685: 4325-block  0
        -: 4326:      }
        -: 4327:   }
       46: 4328:   if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");
       46: 4328-block  0
branch  0 taken 46 (fallthrough)
branch  1 taken 0
       46: 4329:   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
       46: 4329-block  0
call    0 returned 46
branch  1 taken 46 (fallthrough)
branch  2 taken 0
      46*: 4330:   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
       46: 4330-block  0
call    0 returned 46
branch  1 taken 0 (fallthrough)
branch  2 taken 46
    %%%%%: 4330-block  1
        -: 4331:   return 1;
        -: 4332:}
        -: 4333:
function _ZL30stbi__parse_uncompressed_blockP10stbi__zbuf called 0 returned 0% blocks executed 0%
    #####: 4334:static int stbi__parse_uncompressed_block(stbi__zbuf *a)
        -: 4335:{
        -: 4336:   stbi_uc header[4];
        -: 4337:   int len,nlen,k;
    #####: 4338:   if (a->num_bits & 7)
    %%%%%: 4338-block  0
branch  0 never executed
branch  1 never executed
    #####: 4339:      stbi__zreceive(a, a->num_bits & 7); // discard
    %%%%%: 4339-block  0
call    0 never executed
        -: 4340:   // drain the bit-packed data into header
        -: 4341:   k = 0;
    #####: 4342:   while (a->num_bits > 0) {
    %%%%%: 4342-block  0
branch  0 never executed
branch  1 never executed
    #####: 4343:      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
    #####: 4344:      a->code_buffer >>= 8;
    #####: 4345:      a->num_bits -= 8;
    %%%%%: 4345-block  0
        -: 4346:   }
    #####: 4347:   if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");
    %%%%%: 4347-block  0
branch  0 never executed
branch  1 never executed
        -: 4348:   // now fill header the normal way
    #####: 4349:   while (k < 4)
    %%%%%: 4349-block  0
branch  0 never executed
branch  1 never executed
    #####: 4350:      header[k++] = stbi__zget8(a);
    %%%%%: 4350-block  0
    #####: 4351:   len  = header[1] * 256 + header[0];
    #####: 4352:   nlen = header[3] * 256 + header[2];
    #####: 4353:   if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
    %%%%%: 4353-block  0
branch  0 never executed
branch  1 never executed
    #####: 4354:   if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
    %%%%%: 4354-block  0
branch  0 never executed
branch  1 never executed
    #####: 4355:   if (a->zout + len > a->zout_end)
    %%%%%: 4355-block  0
branch  0 never executed
branch  1 never executed
    #####: 4356:      if (!stbi__zexpand(a, a->zout, len)) return 0;
    %%%%%: 4356-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4357:   memcpy(a->zout, a->zbuffer, len);
    %%%%%: 4357-block  0
    #####: 4358:   a->zbuffer += len;
    #####: 4359:   a->zout += len;
    #####: 4360:   return 1;
    %%%%%: 4360-block  0
        -: 4361:}
        -: 4362:
function _ZL23stbi__parse_zlib_headerP10stbi__zbuf called 1 returned 100% blocks executed 90%
        1: 4363:static int stbi__parse_zlib_header(stbi__zbuf *a)
        1: 4363-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 4364:{
        1: 4365:   int cmf   = stbi__zget8(a);
        1: 4365-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 4366:   int cm    = cmf & 15;
        -: 4367:   /* int cinfo = cmf >> 4; */
        1: 4368:   int flg   = stbi__zget8(a);
        1: 4369:   if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
        1: 4369-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4370:   if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
        1: 4370-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4371:   if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
        1: 4371-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
       1*: 4372:   if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
        1: 4372-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4372-block  1
        -: 4373:   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
        -: 4374:   return 1;
        -: 4375:}
        -: 4376:
        -: 4377:static const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =
        -: 4378:{
        -: 4379:   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        -: 4380:   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        -: 4381:   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        -: 4382:   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        -: 4383:   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
        -: 4384:   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
        -: 4385:   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
        -: 4386:   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
        -: 4387:   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
        -: 4388:};
        -: 4389:static const stbi_uc stbi__zdefault_distance[32] =
        -: 4390:{
        -: 4391:   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
        -: 4392:};
        -: 4393:/*
        -: 4394:Init algorithm:
        -: 4395:{
        -: 4396:   int i;   // use <= to match clearly with spec
        -: 4397:   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
        -: 4398:   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
        -: 4399:   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
        -: 4400:   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;
        -: 4401:
        -: 4402:   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
        -: 4403:}
        -: 4404:*/
        -: 4405:
function _ZL16stbi__parse_zlibP10stbi__zbufi called 1 returned 100% blocks executed 74%
        1: 4406:static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
        -: 4407:{
        -: 4408:   int final, type;
        1: 4409:   if (parse_header)
        1: 4409-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4410:      if (!stbi__parse_zlib_header(a)) return 0;
        1: 4410-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1: 4411:   a->num_bits = 0;
        1: 4412:   a->code_buffer = 0;
        1: 4412-block  0
        -: 4413:   do {
        -: 4414:      final = stbi__zreceive(a,1);
       46: 4415:      type = stbi__zreceive(a,2);
       46: 4416:      if (type == 0) {
       46: 4416-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 46
    #####: 4417:         if (!stbi__parse_uncompressed_block(a)) return 0;
    %%%%%: 4417-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
       46: 4418:      } else if (type == 3) {
       46: 4418-block  0
branch  0 taken 46 (fallthrough)
branch  1 taken 0
        -: 4419:         return 0;
        -: 4420:      } else {
       46: 4421:         if (type == 1) {
       46: 4421-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 46
        -: 4422:            // use fixed code lengths
    #####: 4423:            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
    %%%%%: 4423-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4424:            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
    %%%%%: 4424-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4425:         } else {
       46: 4426:            if (!stbi__compute_huffman_codes(a)) return 0;
       46: 4426-block  0
call    0 returned 46
branch  1 taken 46 (fallthrough)
branch  2 taken 0
        -: 4427:         }
       46: 4428:         if (!stbi__parse_huffman_block(a)) return 0;
       46: 4428-block  0
call    0 returned 46
branch  1 taken 46 (fallthrough)
branch  2 taken 0
        -: 4429:      }
       46: 4430:   } while (!final);
       46: 4430-block  0
branch  0 taken 45
branch  1 taken 1 (fallthrough)
        -: 4431:   return 1;
        -: 4432:}
        -: 4433:
        -: 4434:static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
        -: 4435:{
       1*: 4436:   a->zout_start = obuf;
       1*: 4437:   a->zout       = obuf;
       1*: 4438:   a->zout_end   = obuf + olen;
       1*: 4439:   a->z_expandable = exp;
        -: 4440:
       1*: 4441:   return stbi__parse_zlib(a, parse_header);
        -: 4442:}
        -: 4443:
function stbi_zlib_decode_malloc_guesssize called 0 returned 0% blocks executed 0%
    #####: 4444:STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
        -: 4445:{
        -: 4446:   stbi__zbuf a;
    #####: 4447:   char *p = (char *) stbi__malloc(initial_size);
    #####: 4448:   if (p == NULL) return NULL;
    %%%%%: 4448-block  0
branch  0 never executed
branch  1 never executed
    #####: 4449:   a.zbuffer = (stbi_uc *) buffer;
    #####: 4450:   a.zbuffer_end = (stbi_uc *) buffer + len;
    %%%%%: 4450-block  0
call    0 never executed
    #####: 4451:   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
branch  0 never executed
branch  1 never executed
    #####: 4452:      if (outlen) *outlen = (int) (a.zout - a.zout_start);
    %%%%%: 4452-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4452-block  1
    #####: 4453:      return a.zout_start;
    %%%%%: 4453-block  0
        -: 4454:   } else {
    #####: 4455:      STBI_FREE(a.zout_start);
    #####: 4456:      return NULL;
    %%%%%: 4456-block  0
        -: 4457:   }
        -: 4458:}
        -: 4459:
function stbi_zlib_decode_malloc called 0 returned 0% blocks executed 0%
    #####: 4460:STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
        -: 4461:{
    #####: 4462:   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
    %%%%%: 4462-block  0
call    0 never executed
        -: 4463:}
        -: 4464:
function stbi_zlib_decode_malloc_guesssize_headerflag called 1 returned 100% blocks executed 88%
        1: 4465:STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
        -: 4466:{
        -: 4467:   stbi__zbuf a;
        1: 4468:   char *p = (char *) stbi__malloc(initial_size);
        1: 4469:   if (p == NULL) return NULL;
        1: 4469-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4470:   a.zbuffer = (stbi_uc *) buffer;
        1: 4471:   a.zbuffer_end = (stbi_uc *) buffer + len;
        1: 4471-block  0
call    0 returned 1
        1: 4472:   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4473:      if (outlen) *outlen = (int) (a.zout - a.zout_start);
        1: 4473-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4473-block  1
        1: 4474:      return a.zout_start;
        1: 4474-block  0
        -: 4475:   } else {
    #####: 4476:      STBI_FREE(a.zout_start);
    #####: 4477:      return NULL;
    %%%%%: 4477-block  0
        -: 4478:   }
        -: 4479:}
        -: 4480:
function stbi_zlib_decode_buffer called 0 returned 0% blocks executed 0%
    #####: 4481:STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
        -: 4482:{
        -: 4483:   stbi__zbuf a;
    #####: 4484:   a.zbuffer = (stbi_uc *) ibuffer;
    #####: 4485:   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
    %%%%%: 4485-block  0
call    0 never executed
    #####: 4486:   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
branch  0 never executed
branch  1 never executed
    #####: 4487:      return (int) (a.zout - a.zout_start);
    %%%%%: 4487-block  0
        -: 4488:   else
        -: 4489:      return -1;
        -: 4490:}
        -: 4491:
function stbi_zlib_decode_noheader_malloc called 0 returned 0% blocks executed 0%
    #####: 4492:STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
        -: 4493:{
        -: 4494:   stbi__zbuf a;
        -: 4495:   char *p = (char *) stbi__malloc(16384);
    #####: 4496:   if (p == NULL) return NULL;
    %%%%%: 4496-block  0
branch  0 never executed
branch  1 never executed
    #####: 4497:   a.zbuffer = (stbi_uc *) buffer;
    #####: 4498:   a.zbuffer_end = (stbi_uc *) buffer+len;
    %%%%%: 4498-block  0
call    0 never executed
    #####: 4499:   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
branch  0 never executed
branch  1 never executed
    #####: 4500:      if (outlen) *outlen = (int) (a.zout - a.zout_start);
    %%%%%: 4500-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4500-block  1
    #####: 4501:      return a.zout_start;
    %%%%%: 4501-block  0
        -: 4502:   } else {
    #####: 4503:      STBI_FREE(a.zout_start);
    #####: 4504:      return NULL;
    %%%%%: 4504-block  0
        -: 4505:   }
        -: 4506:}
        -: 4507:
function stbi_zlib_decode_noheader_buffer called 0 returned 0% blocks executed 0%
    #####: 4508:STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
        -: 4509:{
        -: 4510:   stbi__zbuf a;
    #####: 4511:   a.zbuffer = (stbi_uc *) ibuffer;
    #####: 4512:   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
    %%%%%: 4512-block  0
call    0 never executed
    #####: 4513:   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
branch  0 never executed
branch  1 never executed
    #####: 4514:      return (int) (a.zout - a.zout_start);
    %%%%%: 4514-block  0
        -: 4515:   else
        -: 4516:      return -1;
        -: 4517:}
        -: 4518:#endif
        -: 4519:
        -: 4520:// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
        -: 4521://    simple implementation
        -: 4522://      - only 8-bit samples
        -: 4523://      - no CRC checking
        -: 4524://      - allocates lots of intermediate memory
        -: 4525://        - avoids problem of streaming data between subsystems
        -: 4526://        - avoids explicit window management
        -: 4527://    performance
        -: 4528://      - uses stb_zlib, a PD zlib implementation with fast huffman decoding
        -: 4529:
        -: 4530:#ifndef STBI_NO_PNG
        -: 4531:typedef struct
        -: 4532:{
        -: 4533:   stbi__uint32 length;
        -: 4534:   stbi__uint32 type;
        -: 4535:} stbi__pngchunk;
        -: 4536:
function _ZL22stbi__get_chunk_headerP13stbi__context called 115 returned 100% blocks executed 100%
      115: 4537:static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
        -: 4538:{
        -: 4539:   stbi__pngchunk c;
      115: 4540:   c.length = stbi__get32be(s);
      115: 4540-block  0
call    0 returned 115
      115: 4541:   c.type   = stbi__get32be(s);
call    0 returned 115
      115: 4542:   return c;
        -: 4543:}
        -: 4544:
        -: 4545:static int stbi__check_png_header(stbi__context *s)
        -: 4546:{
        -: 4547:   static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
        -: 4548:   int i;
       18: 4549:   for (i=0; i < 8; ++i)
        9: 4549-block  0
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        8: 4549-block  1
        9: 4549-block  2
branch  2 taken 8 (fallthrough)
branch  3 taken 1
        8: 4549-block  3
       16: 4550:      if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
        8: 4550-block  0
call    0 returned 8
branch  1 taken 8 (fallthrough)
branch  2 taken 0
        8: 4550-block  1
call    3 returned 8
branch  4 taken 8 (fallthrough)
branch  5 taken 0
        -: 4551:   return 1;
        -: 4552:}
        -: 4553:
        -: 4554:typedef struct
        -: 4555:{
        -: 4556:   stbi__context *s;
        -: 4557:   stbi_uc *idata, *expanded, *out;
        -: 4558:   int depth;
        -: 4559:} stbi__png;
        -: 4560:
        -: 4561:
        -: 4562:enum {
        -: 4563:   STBI__F_none=0,
        -: 4564:   STBI__F_sub=1,
        -: 4565:   STBI__F_up=2,
        -: 4566:   STBI__F_avg=3,
        -: 4567:   STBI__F_paeth=4,
        -: 4568:   // synthetic filters used for first scanline to avoid needing a dummy row of 0s
        -: 4569:   STBI__F_avg_first,
        -: 4570:   STBI__F_paeth_first
        -: 4571:};
        -: 4572:
        -: 4573:static stbi_uc first_row_filter[5] =
        -: 4574:{
        -: 4575:   STBI__F_none,
        -: 4576:   STBI__F_sub,
        -: 4577:   STBI__F_none,
        -: 4578:   STBI__F_avg_first,
        -: 4579:   STBI__F_paeth_first
        -: 4580:};
        -: 4581:
        -: 4582:static int stbi__paeth(int a, int b, int c)
        -: 4583:{
 4830920*: 4584:   int p = a + b - c;
 4830920*: 4585:   int pa = abs(p-a);
 4830920*: 4586:   int pb = abs(p-b);
 4830920*: 4587:   int pc = abs(p-c);
 4833280*: 4588:   if (pa <= pb && pa <= pc) return a;
  338825*: 4589:   if (pb <= pc) return b;
     1981: 4589-block  0
   336844: 4589-block  1
branch  0 taken 314797 (fallthrough)
branch  1 taken 22047
   314797: 4589-block  2
    %%%%%: 4589-block  3
branch  2 never executed
branch  3 never executed
    %%%%%: 4589-block  4
        -: 4590:   return c;
        -: 4591:}
        -: 4592:
        -: 4593:static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };
        -: 4594:
        -: 4595:// create the png data from post-deflated data
function _ZL26stbi__create_png_image_rawP9stbi__pngPhjijjii called 1 returned 100% blocks executed 25%
        1: 4596:static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
        -: 4597:{
        1: 4598:   int bytes = (depth == 16? 2 : 1);
        1: 4598-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4599:   stbi__context *s = a->s;
        1: 4600:   stbi__uint32 i,j,stride = x*out_n*bytes;
        -: 4601:   stbi__uint32 img_len, img_width_bytes;
        -: 4602:   int k;
        1: 4603:   int img_n = s->img_n; // copy it into a local for later
        -: 4604:
        1: 4605:   int output_bytes = out_n*bytes;
        1: 4606:   int filter_bytes = img_n*bytes;
        1: 4607:   int width = x;
        -: 4608:
       1*: 4609:   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
        1: 4609-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 4609-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 4609-block  2
call    4 never executed
        1: 4610:   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
        1: 4610-block  0
call    0 returned 1
        1: 4611:   if (!a->out) return stbi__err("outofmem", "Out of memory");
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 4612:
        1: 4613:   if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
        1: 4613-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4614:   img_width_bytes = (((img_n * x * depth) + 7) >> 3);
        1: 4615:   img_len = (img_width_bytes + 1) * y;
        -: 4616:
        -: 4617:   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
        -: 4618:   // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
        -: 4619:   // so just check for raw_len < img_len always.
        1: 4620:   if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");
        1: 4620-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 4621:
     2049: 4622:   for (j=0; j < y; ++j) {
     2049: 4622-block  0
branch  0 taken 2048 (fallthrough)
branch  1 taken 1
     2048: 4622-block  1
     2048: 4623:      stbi_uc *cur = a->out + stride*j;
        -: 4624:      stbi_uc *prior;
     2048: 4625:      int filter = *raw++;
        -: 4626:
     2048: 4627:      if (filter > 4)
     2048: 4627-block  0
branch  0 taken 2048 (fallthrough)
branch  1 taken 0
        -: 4628:         return stbi__err("invalid filter","Corrupt PNG");
        -: 4629:
     2048: 4630:      if (depth < 8) {
     2048: 4630-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2048
    #####: 4631:         if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");
    %%%%%: 4631-block  0
branch  0 never executed
branch  1 never executed
    #####: 4632:         cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
        -: 4633:         filter_bytes = 1;
    #####: 4634:         width = img_width_bytes;
    %%%%%: 4634-block  0
        -: 4635:      }
     2048: 4636:      prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above
        -: 4637:
        -: 4638:      // if first row, use special filter that doesn't sample previous row
     2048: 4639:      if (j == 0) filter = first_row_filter[filter];
     2048: 4639-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2047
        1: 4639-block  1
        -: 4640:
        -: 4641:      // handle first byte explicitly
    10240: 4642:      for (k=0; k < filter_bytes; ++k) {
    10240: 4642-block  0
branch  0 taken 8192 (fallthrough)
branch  1 taken 2048
     8192: 4642-block  1
     8192: 4643:         switch (filter) {
     8192: 4643-block  0
branch  0 taken 0
branch  1 taken 272
branch  2 taken 5560
branch  3 taken 0
branch  4 taken 2360
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
    #####: 4644:            case STBI__F_none       : cur[k] = raw[k]; break;
    %%%%%: 4644-block  0
      272: 4645:            case STBI__F_sub        : cur[k] = raw[k]; break;
      272: 4645-block  0
     5560: 4646:            case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
     5560: 4646-block  0
    #####: 4647:            case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;
    %%%%%: 4647-block  0
     4341: 4648:            case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;
     2360: 4648-block  0
branch  0 taken 1981 (fallthrough)
branch  1 taken 379
     2360: 4648-block  1
    #####: 4649:            case STBI__F_avg_first  : cur[k] = raw[k]; break;
    %%%%%: 4649-block  0
    #####: 4650:            case STBI__F_paeth_first: cur[k] = raw[k]; break;
    %%%%%: 4650-block  0
        -: 4651:         }
        -: 4652:      }
        -: 4653:
     2048: 4654:      if (depth == 8) {
     2048: 4654-block  0
branch  0 taken 2048 (fallthrough)
branch  1 taken 0
     2048: 4655:         if (img_n != out_n)
     2048: 4655-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2048
    #####: 4656:            cur[img_n] = 255; // first pixel
    %%%%%: 4656-block  0
     2048: 4657:         raw += img_n;
     2048: 4658:         cur += out_n;
     2048: 4659:         prior += out_n;
     2048: 4659-block  0
    #####: 4660:      } else if (depth == 16) {
    %%%%%: 4660-block  0
branch  0 never executed
branch  1 never executed
    #####: 4661:         if (img_n != out_n) {
    %%%%%: 4661-block  0
branch  0 never executed
branch  1 never executed
    #####: 4662:            cur[filter_bytes]   = 255; // first pixel top byte
    #####: 4663:            cur[filter_bytes+1] = 255; // first pixel bottom byte
    %%%%%: 4663-block  0
        -: 4664:         }
    #####: 4665:         raw += filter_bytes;
    #####: 4666:         cur += output_bytes;
    #####: 4667:         prior += output_bytes;
    %%%%%: 4667-block  0
        -: 4668:      } else {
    #####: 4669:         raw += 1;
    #####: 4670:         cur += 1;
    #####: 4671:         prior += 1;
    %%%%%: 4671-block  0
        -: 4672:      }
        -: 4673:
        -: 4674:      // this is a little gross, so that we don't switch per-pixel or per-component
     2048: 4675:      if (depth < 8 || img_n == out_n) {
     2048: 4675-block  0
branch  0 taken 2048 (fallthrough)
branch  1 taken 0
     2048: 4676:         int nk = (width - 1)*filter_bytes;
        -: 4677:         #define STBI__CASE(f) \
        -: 4678:             case f:     \
        -: 4679:                for (k=0; k < nk; ++k)
     2048: 4680:         switch (filter) {
     2048: 4680-block  0
branch  0 taken 0
branch  1 taken 68
branch  2 taken 1390
branch  3 taken 0
branch  4 taken 590
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
        -: 4681:            // "none" filter turns into a memcpy here; make that explicit.
    #####: 4682:            case STBI__F_none:         memcpy(cur, raw, nk); break;
    %%%%%: 4682-block  0
   556852: 4683:            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;
   556852: 4683-block  0
branch  0 taken 556784 (fallthrough)
branch  1 taken 68
   556784: 4683-block  1
 11382710: 4684:            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
 11382710: 4684-block  0
branch  0 taken 11381320 (fallthrough)
branch  1 taken 1390
 11381320: 4684-block  1
    #####: 4685:            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;
    %%%%%: 4685-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4685-block  1
  4831510: 4686:            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;
  4831510: 4686-block  0
branch  0 taken 4830920 (fallthrough)
branch  1 taken 590
  4830920: 4686-block  1
branch  2 taken 336844 (fallthrough)
branch  3 taken 4494076
  4830920: 4686-block  2
    #####: 4687:            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;
    %%%%%: 4687-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4687-block  1
    #####: 4688:            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;
    %%%%%: 4688-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4688-block  1
        -: 4689:         }
        -: 4690:         #undef STBI__CASE
     2048: 4691:         raw += nk;
     2048: 4691-block  0
        -: 4692:      } else {
    #####: 4693:         STBI_ASSERT(img_n+1 == out_n);
    %%%%%: 4693-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4693-block  1
call    2 never executed
        -: 4694:         #define STBI__CASE(f) \
        -: 4695:             case f:     \
        -: 4696:                for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
        -: 4697:                   for (k=0; k < filter_bytes; ++k)
    #####: 4698:         switch (filter) {
    %%%%%: 4698-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 4699:            STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;
    %%%%%: 4699-block  0
    %%%%%: 4699-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 4699-block  2
branch  2 never executed
branch  3 never executed
    %%%%%: 4699-block  3
    %%%%%: 4699-block  4
    #####: 4700:            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;
    %%%%%: 4700-block  0
    %%%%%: 4700-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 4700-block  2
branch  2 never executed
branch  3 never executed
    %%%%%: 4700-block  3
    %%%%%: 4700-block  4
    #####: 4701:            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
    %%%%%: 4701-block  0
    %%%%%: 4701-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 4701-block  2
branch  2 never executed
branch  3 never executed
    %%%%%: 4701-block  3
    %%%%%: 4701-block  4
    #####: 4702:            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;
    %%%%%: 4702-block  0
    %%%%%: 4702-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 4702-block  2
branch  2 never executed
branch  3 never executed
    %%%%%: 4702-block  3
    %%%%%: 4702-block  4
    #####: 4703:            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;
    %%%%%: 4703-block  0
    %%%%%: 4703-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 4703-block  2
branch  2 never executed
branch  3 never executed
    %%%%%: 4703-block  3
branch  4 never executed
branch  5 never executed
    %%%%%: 4703-block  4
    %%%%%: 4703-block  5
    #####: 4704:            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;
    %%%%%: 4704-block  0
    %%%%%: 4704-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 4704-block  2
branch  2 never executed
branch  3 never executed
    %%%%%: 4704-block  3
    %%%%%: 4704-block  4
    #####: 4705:            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;
    %%%%%: 4705-block  0
    %%%%%: 4705-block  1
branch  0 never executed
branch  1 never executed
    %%%%%: 4705-block  2
branch  2 never executed
branch  3 never executed
    %%%%%: 4705-block  3
    %%%%%: 4705-block  4
        -: 4706:         }
        -: 4707:         #undef STBI__CASE
        -: 4708:
        -: 4709:         // the loop above sets the high byte of the pixels' alpha, but for
        -: 4710:         // 16 bit png files we also need the low byte set. we'll do that here.
    #####: 4711:         if (depth == 16) {
    %%%%%: 4711-block  0
branch  0 never executed
branch  1 never executed
    #####: 4712:            cur = a->out + stride*j; // start at the beginning of the row again
    %%%%%: 4712-block  0
    #####: 4713:            for (i=0; i < x; ++i,cur+=output_bytes) {
    %%%%%: 4713-block  0
branch  0 never executed
branch  1 never executed
    #####: 4714:               cur[filter_bytes+1] = 255;
    %%%%%: 4714-block  0
        -: 4715:            }
        -: 4716:         }
        -: 4717:      }
        -: 4718:   }
        -: 4719:
        -: 4720:   // we make a separate pass to expand bits to pixels; for performance,
        -: 4721:   // this could run two scanlines behind the above code, so it won't
        -: 4722:   // intefere with filtering but will still be in the cache.
        1: 4723:   if (depth < 8) {
        1: 4723-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 4724:      for (j=0; j < y; ++j) {
    %%%%%: 4724-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4724-block  1
    #####: 4725:         stbi_uc *cur = a->out + stride*j;
    #####: 4726:         stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
        -: 4727:         // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
        -: 4728:         // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
    #####: 4729:         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range
    %%%%%: 4729-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4729-block  1
        -: 4730:
        -: 4731:         // note that the final byte might overshoot and write more data than desired.
        -: 4732:         // we can allocate enough data that this never writes out of memory, but it
        -: 4733:         // could also overwrite the next scanline. can it overwrite non-empty data
        -: 4734:         // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
        -: 4735:         // so we need to explicitly clamp the final ones
        -: 4736:
    #####: 4737:         if (depth == 4) {
    %%%%%: 4737-block  0
branch  0 never executed
branch  1 never executed
    #####: 4738:            for (k=x*img_n; k >= 2; k-=2, ++in) {
    %%%%%: 4738-block  0
    %%%%%: 4738-block  1
branch  0 never executed
branch  1 never executed
    #####: 4739:               *cur++ = scale * ((*in >> 4)       );
    #####: 4740:               *cur++ = scale * ((*in     ) & 0x0f);
    %%%%%: 4740-block  0
        -: 4741:            }
    #####: 4742:            if (k > 0) *cur++ = scale * ((*in >> 4)       );
    %%%%%: 4742-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4742-block  1
    #####: 4743:         } else if (depth == 2) {
    %%%%%: 4743-block  0
branch  0 never executed
branch  1 never executed
    #####: 4744:            for (k=x*img_n; k >= 4; k-=4, ++in) {
    %%%%%: 4744-block  0
    %%%%%: 4744-block  1
branch  0 never executed
branch  1 never executed
    #####: 4745:               *cur++ = scale * ((*in >> 6)       );
    #####: 4746:               *cur++ = scale * ((*in >> 4) & 0x03);
    #####: 4747:               *cur++ = scale * ((*in >> 2) & 0x03);
    #####: 4748:               *cur++ = scale * ((*in     ) & 0x03);
    %%%%%: 4748-block  0
        -: 4749:            }
    #####: 4750:            if (k > 0) *cur++ = scale * ((*in >> 6)       );
    %%%%%: 4750-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4750-block  1
    #####: 4751:            if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
    %%%%%: 4751-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4751-block  1
    #####: 4752:            if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
    %%%%%: 4752-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4752-block  1
    #####: 4753:         } else if (depth == 1) {
    %%%%%: 4753-block  0
branch  0 never executed
branch  1 never executed
    #####: 4754:            for (k=x*img_n; k >= 8; k-=8, ++in) {
    %%%%%: 4754-block  0
    %%%%%: 4754-block  1
branch  0 never executed
branch  1 never executed
    #####: 4755:               *cur++ = scale * ((*in >> 7)       );
    #####: 4756:               *cur++ = scale * ((*in >> 6) & 0x01);
    #####: 4757:               *cur++ = scale * ((*in >> 5) & 0x01);
    #####: 4758:               *cur++ = scale * ((*in >> 4) & 0x01);
    #####: 4759:               *cur++ = scale * ((*in >> 3) & 0x01);
    #####: 4760:               *cur++ = scale * ((*in >> 2) & 0x01);
    #####: 4761:               *cur++ = scale * ((*in >> 1) & 0x01);
    #####: 4762:               *cur++ = scale * ((*in     ) & 0x01);
    %%%%%: 4762-block  0
        -: 4763:            }
    #####: 4764:            if (k > 0) *cur++ = scale * ((*in >> 7)       );
    %%%%%: 4764-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4764-block  1
    #####: 4765:            if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
    %%%%%: 4765-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4765-block  1
    #####: 4766:            if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
    %%%%%: 4766-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4766-block  1
    #####: 4767:            if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
    %%%%%: 4767-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4767-block  1
    #####: 4768:            if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
    %%%%%: 4768-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4768-block  1
    #####: 4769:            if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
    %%%%%: 4769-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4769-block  1
    #####: 4770:            if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
    %%%%%: 4770-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4770-block  1
        -: 4771:         }
    #####: 4772:         if (img_n != out_n) {
    %%%%%: 4772-block  0
branch  0 never executed
branch  1 never executed
        -: 4773:            int q;
        -: 4774:            // insert alpha = 255
    #####: 4775:            cur = a->out + stride*j;
    #####: 4776:            if (img_n == 1) {
    %%%%%: 4776-block  0
branch  0 never executed
branch  1 never executed
    #####: 4777:               for (q=x-1; q >= 0; --q) {
    %%%%%: 4777-block  0
    %%%%%: 4777-block  1
branch  0 never executed
branch  1 never executed
    #####: 4778:                  cur[q*2+1] = 255;
    #####: 4779:                  cur[q*2+0] = cur[q];
    %%%%%: 4779-block  0
        -: 4780:               }
        -: 4781:            } else {
    #####: 4782:               STBI_ASSERT(img_n == 3);
    %%%%%: 4782-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4782-block  1
call    2 never executed
    #####: 4783:               for (q=x-1; q >= 0; --q) {
    %%%%%: 4783-block  0
    %%%%%: 4783-block  1
branch  0 never executed
branch  1 never executed
    #####: 4784:                  cur[q*4+3] = 255;
    #####: 4785:                  cur[q*4+2] = cur[q*3+2];
    #####: 4786:                  cur[q*4+1] = cur[q*3+1];
    #####: 4787:                  cur[q*4+0] = cur[q*3+0];
    %%%%%: 4787-block  0
        -: 4788:               }
        -: 4789:            }
        -: 4790:         }
        -: 4791:      }
        1: 4792:   } else if (depth == 16) {
        1: 4792-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 4793:      // force the image data from big-endian to platform-native.
        -: 4794:      // this is done in a separate pass due to the decoding relying
        -: 4795:      // on the data being untouched, but could probably be done
        -: 4796:      // per-line during decode if care is taken.
    #####: 4797:      stbi_uc *cur = a->out;
    %%%%%: 4797-block  0
        -: 4798:      stbi__uint16 *cur16 = (stbi__uint16*)cur;
        -: 4799:
    #####: 4800:      for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {
    %%%%%: 4800-block  0
branch  0 never executed
branch  1 never executed
    #####: 4801:         *cur16 = (cur[0] << 8) | cur[1];
    %%%%%: 4801-block  0
        -: 4802:      }
        -: 4803:   }
        -: 4804:
        -: 4805:   return 1;
        -: 4806:}
        -: 4807:
function _ZL22stbi__create_png_imageP9stbi__pngPhjiiii called 1 returned 100% blocks executed 26%
        1: 4808:static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
        -: 4809:{
        1: 4810:   int bytes = (depth == 16 ? 2 : 1);
        1: 4810-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4811:   int out_bytes = out_n * bytes;
        -: 4812:   stbi_uc *final;
        -: 4813:   int p;
        1: 4814:   if (!interlaced)
        1: 4814-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 4815:      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);
        1: 4815-block  0
call    0 returned 1
        -: 4816:
        -: 4817:   // de-interlacing
    #####: 4818:   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
    %%%%%: 4818-block  0
call    0 never executed
    #####: 4819:   if (!final) return stbi__err("outofmem", "Out of memory");
branch  0 never executed
branch  1 never executed
    #####: 4820:   for (p=0; p < 7; ++p) {
    %%%%%: 4820-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4820-block  1
    #####: 4821:      int xorig[] = { 0,4,0,2,0,1,0 };
    #####: 4822:      int yorig[] = { 0,0,4,0,2,0,1 };
    #####: 4823:      int xspc[]  = { 8,8,4,4,2,2,1 };
    #####: 4824:      int yspc[]  = { 8,8,8,4,4,2,2 };
        -: 4825:      int i,j,x,y;
        -: 4826:      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
    #####: 4827:      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
    #####: 4828:      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
    #####: 4829:      if (x && y) {
    %%%%%: 4829-block  0
branch  0 never executed
branch  1 never executed
    #####: 4830:         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
    #####: 4831:         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
    %%%%%: 4831-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4832:            STBI_FREE(final);
    #####: 4833:            return 0;
    %%%%%: 4833-block  0
        -: 4834:         }
    #####: 4835:         for (j=0; j < y; ++j) {
    %%%%%: 4835-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4835-block  1
    #####: 4836:            for (i=0; i < x; ++i) {
    %%%%%: 4836-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4836-block  1
    #####: 4837:               int out_y = j*yspc[p]+yorig[p];
    #####: 4838:               int out_x = i*xspc[p]+xorig[p];
    #####: 4839:               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
    #####: 4840:                      a->out + (j*x+i)*out_bytes, out_bytes);
    %%%%%: 4840-block  0
        -: 4841:            }
        -: 4842:         }
    #####: 4843:         STBI_FREE(a->out);
    #####: 4844:         image_data += img_len;
    #####: 4845:         image_data_len -= img_len;
    %%%%%: 4845-block  0
        -: 4846:      }
        -: 4847:   }
    #####: 4848:   a->out = final;
        -: 4849:
    #####: 4850:   return 1;
    %%%%%: 4850-block  0
        -: 4851:}
        -: 4852:
function _ZL26stbi__compute_transparencyP9stbi__pngPhi called 0 returned 0% blocks executed 0%
    #####: 4853:static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
        -: 4854:{
    #####: 4855:   stbi__context *s = z->s;
    #####: 4856:   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
    #####: 4857:   stbi_uc *p = z->out;
        -: 4858:
        -: 4859:   // compute color-based transparency, assuming we've
        -: 4860:   // already got 255 as the alpha value in the output
    #####: 4861:   STBI_ASSERT(out_n == 2 || out_n == 4);
    %%%%%: 4861-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4861-block  1
call    2 never executed
        -: 4862:
    #####: 4863:   if (out_n == 2) {
    %%%%%: 4863-block  0
branch  0 never executed
branch  1 never executed
    #####: 4864:      for (i=0; i < pixel_count; ++i) {
    %%%%%: 4864-block  0
branch  0 never executed
branch  1 never executed
    #####: 4865:         p[1] = (p[0] == tc[0] ? 0 : 255);
    %%%%%: 4865-block  0
branch  0 never executed
branch  1 never executed
    #####: 4866:         p += 2;
    %%%%%: 4866-block  0
        -: 4867:      }
        -: 4868:   } else {
    #####: 4869:      for (i=0; i < pixel_count; ++i) {
    %%%%%: 4869-block  0
branch  0 never executed
branch  1 never executed
    #####: 4870:         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
    %%%%%: 4870-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4870-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 4870-block  2
branch  4 never executed
branch  5 never executed
    #####: 4871:            p[3] = 0;
    %%%%%: 4871-block  0
    #####: 4872:         p += 4;
    %%%%%: 4872-block  0
        -: 4873:      }
        -: 4874:   }
    #####: 4875:   return 1;
        -: 4876:}
        -: 4877:
function _ZL28stbi__compute_transparency16P9stbi__pngPti called 0 returned 0% blocks executed 0%
    #####: 4878:static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
        -: 4879:{
    #####: 4880:   stbi__context *s = z->s;
    #####: 4881:   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
    #####: 4882:   stbi__uint16 *p = (stbi__uint16*) z->out;
        -: 4883:
        -: 4884:   // compute color-based transparency, assuming we've
        -: 4885:   // already got 65535 as the alpha value in the output
    #####: 4886:   STBI_ASSERT(out_n == 2 || out_n == 4);
    %%%%%: 4886-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4886-block  1
call    2 never executed
        -: 4887:
    #####: 4888:   if (out_n == 2) {
    %%%%%: 4888-block  0
branch  0 never executed
branch  1 never executed
    #####: 4889:      for (i = 0; i < pixel_count; ++i) {
    %%%%%: 4889-block  0
branch  0 never executed
branch  1 never executed
    #####: 4890:         p[1] = (p[0] == tc[0] ? 0 : 65535);
    %%%%%: 4890-block  0
branch  0 never executed
branch  1 never executed
    #####: 4891:         p += 2;
    %%%%%: 4891-block  0
        -: 4892:      }
        -: 4893:   } else {
    #####: 4894:      for (i = 0; i < pixel_count; ++i) {
    %%%%%: 4894-block  0
branch  0 never executed
branch  1 never executed
    #####: 4895:         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
    %%%%%: 4895-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4895-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 4895-block  2
branch  4 never executed
branch  5 never executed
    #####: 4896:            p[3] = 0;
    %%%%%: 4896-block  0
    #####: 4897:         p += 4;
    %%%%%: 4897-block  0
        -: 4898:      }
        -: 4899:   }
    #####: 4900:   return 1;
        -: 4901:}
        -: 4902:
function _ZL24stbi__expand_png_paletteP9stbi__pngPhii called 0 returned 0% blocks executed 0%
    #####: 4903:static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
        -: 4904:{
    #####: 4905:   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
    #####: 4906:   stbi_uc *p, *temp_out, *orig = a->out;
        -: 4907:
    #####: 4908:   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
    %%%%%: 4908-block  0
call    0 never executed
    #####: 4909:   if (p == NULL) return stbi__err("outofmem", "Out of memory");
branch  0 never executed
branch  1 never executed
        -: 4910:
        -: 4911:   // between here and free(out) below, exitting would leak
        -: 4912:   temp_out = p;
        -: 4913:
    #####: 4914:   if (pal_img_n == 3) {
    %%%%%: 4914-block  0
branch  0 never executed
branch  1 never executed
    #####: 4915:      for (i=0; i < pixel_count; ++i) {
    %%%%%: 4915-block  0
branch  0 never executed
branch  1 never executed
    #####: 4916:         int n = orig[i]*4;
    #####: 4917:         p[0] = palette[n  ];
    #####: 4918:         p[1] = palette[n+1];
    #####: 4919:         p[2] = palette[n+2];
    #####: 4920:         p += 3;
    %%%%%: 4920-block  0
        -: 4921:      }
        -: 4922:   } else {
    #####: 4923:      for (i=0; i < pixel_count; ++i) {
    %%%%%: 4923-block  0
branch  0 never executed
branch  1 never executed
    #####: 4924:         int n = orig[i]*4;
    #####: 4925:         p[0] = palette[n  ];
    #####: 4926:         p[1] = palette[n+1];
    #####: 4927:         p[2] = palette[n+2];
    #####: 4928:         p[3] = palette[n+3];
    #####: 4929:         p += 4;
    %%%%%: 4929-block  0
        -: 4930:      }
        -: 4931:   }
    #####: 4932:   STBI_FREE(a->out);
    #####: 4933:   a->out = temp_out;
        -: 4934:
        -: 4935:   STBI_NOTUSED(len);
        -: 4936:
    #####: 4937:   return 1;
    %%%%%: 4937-block  0
        -: 4938:}
        -: 4939:
        -: 4940:static int stbi__unpremultiply_on_load_global = 0;
        -: 4941:static int stbi__de_iphone_flag_global = 0;
        -: 4942:
function stbi_set_unpremultiply_on_load called 0 returned 0% blocks executed 0%
    #####: 4943:STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
        -: 4944:{
    #####: 4945:   stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
    #####: 4946:}
        -: 4947:
function stbi_convert_iphone_png_to_rgb called 0 returned 0% blocks executed 0%
    #####: 4948:STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
        -: 4949:{
    #####: 4950:   stbi__de_iphone_flag_global = flag_true_if_should_convert;
    #####: 4951:}
        -: 4952:
        -: 4953:#ifndef STBI_THREAD_LOCAL
        -: 4954:#define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global
        -: 4955:#define stbi__de_iphone_flag  stbi__de_iphone_flag_global
        -: 4956:#else
        -: 4957:static STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;
        -: 4958:static STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;
        -: 4959:
function _Z34stbi__unpremultiply_on_load_threadi called 0 returned 0% blocks executed 0%
    #####: 4960:STBIDEF void stbi__unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
        -: 4961:{
    #####: 4962:   stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
    #####: 4963:   stbi__unpremultiply_on_load_set = 1;
    #####: 4964:}
        -: 4965:
function stbi_convert_iphone_png_to_rgb_thread called 0 returned 0% blocks executed 0%
    #####: 4966:STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
        -: 4967:{
    #####: 4968:   stbi__de_iphone_flag_local = flag_true_if_should_convert;
    #####: 4969:   stbi__de_iphone_flag_set = 1;
    #####: 4970:}
        -: 4971:
        -: 4972:#define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \
        -: 4973:                                       ? stbi__unpremultiply_on_load_local      \
        -: 4974:                                       : stbi__unpremultiply_on_load_global)
        -: 4975:#define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \
        -: 4976:                                ? stbi__de_iphone_flag_local                    \
        -: 4977:                                : stbi__de_iphone_flag_global)
        -: 4978:#endif // STBI_THREAD_LOCAL
        -: 4979:
function _ZL15stbi__de_iphoneP9stbi__png called 0 returned 0% blocks executed 0%
    #####: 4980:static void stbi__de_iphone(stbi__png *z)
        -: 4981:{
    #####: 4982:   stbi__context *s = z->s;
    #####: 4983:   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
    #####: 4984:   stbi_uc *p = z->out;
        -: 4985:
    #####: 4986:   if (s->img_out_n == 3) {  // convert bgr to rgb
    %%%%%: 4986-block  0
branch  0 never executed
branch  1 never executed
    #####: 4987:      for (i=0; i < pixel_count; ++i) {
    %%%%%: 4987-block  0
branch  0 never executed
branch  1 never executed
    #####: 4988:         stbi_uc t = p[0];
    #####: 4989:         p[0] = p[2];
    #####: 4990:         p[2] = t;
    #####: 4991:         p += 3;
    %%%%%: 4991-block  0
        -: 4992:      }
        -: 4993:   } else {
    #####: 4994:      STBI_ASSERT(s->img_out_n == 4);
    %%%%%: 4994-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4994-block  1
call    2 never executed
    #####: 4995:      if (stbi__unpremultiply_on_load) {
    %%%%%: 4995-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 4995-block  1
    %%%%%: 4995-block  2
    %%%%%: 4995-block  3
branch  2 never executed
branch  3 never executed
        -: 4996:         // convert bgr to rgb and unpremultiply
    #####: 4997:         for (i=0; i < pixel_count; ++i) {
    %%%%%: 4997-block  0
branch  0 never executed
branch  1 never executed
    #####: 4998:            stbi_uc a = p[3];
    #####: 4999:            stbi_uc t = p[0];
    #####: 5000:            if (a) {
    %%%%%: 5000-block  0
branch  0 never executed
branch  1 never executed
    #####: 5001:               stbi_uc half = a / 2;
    #####: 5002:               p[0] = (p[2] * 255 + half) / a;
    #####: 5003:               p[1] = (p[1] * 255 + half) / a;
    #####: 5004:               p[2] = ( t   * 255 + half) / a;
    %%%%%: 5004-block  0
        -: 5005:            } else {
    #####: 5006:               p[0] = p[2];
    #####: 5007:               p[2] = t;
    %%%%%: 5007-block  0
        -: 5008:            }
    #####: 5009:            p += 4;
    %%%%%: 5009-block  0
        -: 5010:         }
        -: 5011:      } else {
        -: 5012:         // convert bgr to rgb
    #####: 5013:         for (i=0; i < pixel_count; ++i) {
    %%%%%: 5013-block  0
branch  0 never executed
branch  1 never executed
    #####: 5014:            stbi_uc t = p[0];
    #####: 5015:            p[0] = p[2];
    #####: 5016:            p[2] = t;
    #####: 5017:            p += 4;
    %%%%%: 5017-block  0
        -: 5018:         }
        -: 5019:      }
        -: 5020:   }
    #####: 5021:}
        -: 5022:
        -: 5023:#define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))
        -: 5024:
function _ZL20stbi__parse_png_fileP9stbi__pngii called 1 returned 100% blocks executed 58%
        1: 5025:static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
        -: 5026:{
        -: 5027:   stbi_uc palette[1024], pal_img_n=0;
        1: 5028:   stbi_uc has_trans=0, tc[3]={0};
        -: 5029:   stbi__uint16 tc16[3];
        -: 5030:   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
        -: 5031:   int first=1,k,interlace=0, color=0, is_iphone=0;
        1: 5032:   stbi__context *s = z->s;
        -: 5033:
        1: 5034:   z->expanded = NULL;
        1: 5035:   z->idata = NULL;
        1: 5036:   z->out = NULL;
        1: 5036-block  0
        -: 5037:
        1: 5038:   if (!stbi__check_png_header(s)) return 0;
        1: 5038-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 5039:
        1: 5040:   if (scan == STBI__SCAN_type) return 1;
        1: 5040-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 5041:
        -: 5042:   for (;;) {
      115: 5043:      stbi__pngchunk c = stbi__get_chunk_header(s);
      115: 5043-block  0
call    0 returned 115
      115: 5044:      switch (c.type) {
branch  0 taken 0
branch  1 taken 1
branch  2 taken 0
branch  3 taken 0
branch  4 taken 107
branch  5 taken 1
branch  6 taken 6
    #####: 5045:         case STBI__PNG_TYPE('C','g','B','I'):
        -: 5046:            is_iphone = 1;
    #####: 5047:            stbi__skip(s, c.length);
    %%%%%: 5047-block  0
call    0 never executed
        -: 5048:            break;
        1: 5049:         case STBI__PNG_TYPE('I','H','D','R'): {
        -: 5050:            int comp,filter;
        1: 5051:            if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
        1: 5051-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 5052:            first = 0;
        1: 5053:            if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
        1: 5053-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5054:            s->img_x = stbi__get32be(s);
        1: 5054-block  0
call    0 returned 1
        1: 5055:            s->img_y = stbi__get32be(s);
call    0 returned 1
        1: 5056:            if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5057:            if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
        1: 5057-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
       1*: 5058:            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
        1: 5058-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1: 5058-block  1
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    %%%%%: 5058-block  2
branch  5 never executed
branch  6 never executed
        1: 5059:            color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
        1: 5059-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
       1*: 5060:            if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
        1: 5060-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5060-block  1
branch  2 never executed
branch  3 never executed
        1: 5061:            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
        1: 5061-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5061-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 5062:            comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
        1: 5062-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1: 5063:            filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
        1: 5063-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1: 5064:            interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
        1: 5064-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1: 5065:            if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
        1: 5065-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5065-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 5066:            if (!pal_img_n) {
        1: 5066-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5067:               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
        1: 5067-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        1: 5068:               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
        1: 5068-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5069:               if (scan == STBI__SCAN_header) return 1;
        1: 5069-block  0
branch  0 taken 1
branch  1 taken 0
        -: 5070:            } else {
        -: 5071:               // if paletted, then pal_n is our final components, and
        -: 5072:               // img_n is # components to decompress/filter.
    #####: 5073:               s->img_n = 1;
    #####: 5074:               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
    %%%%%: 5074-block  0
branch  0 never executed
branch  1 never executed
        -: 5075:               // if SCAN_header, have to scan to see if we have a tRNS
        -: 5076:            }
        -: 5077:            break;
        -: 5078:         }
        -: 5079:
    #####: 5080:         case STBI__PNG_TYPE('P','L','T','E'):  {
    #####: 5081:            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
    %%%%%: 5081-block  0
branch  0 never executed
branch  1 never executed
    #####: 5082:            if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
    %%%%%: 5082-block  0
branch  0 never executed
branch  1 never executed
    #####: 5083:            pal_len = c.length / 3;
    #####: 5084:            if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
    %%%%%: 5084-block  0
branch  0 never executed
branch  1 never executed
    #####: 5085:            for (i=0; i < pal_len; ++i) {
    %%%%%: 5085-block  0
branch  0 never executed
branch  1 never executed
    #####: 5086:               palette[i*4+0] = stbi__get8(s);
    %%%%%: 5086-block  0
call    0 never executed
    #####: 5087:               palette[i*4+1] = stbi__get8(s);
call    0 never executed
    #####: 5088:               palette[i*4+2] = stbi__get8(s);
call    0 never executed
    #####: 5089:               palette[i*4+3] = 255;
        -: 5090:            }
        -: 5091:            break;
        -: 5092:         }
        -: 5093:
    #####: 5094:         case STBI__PNG_TYPE('t','R','N','S'): {
    #####: 5095:            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
    %%%%%: 5095-block  0
branch  0 never executed
branch  1 never executed
    #####: 5096:            if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
    %%%%%: 5096-block  0
branch  0 never executed
branch  1 never executed
    #####: 5097:            if (pal_img_n) {
    %%%%%: 5097-block  0
branch  0 never executed
branch  1 never executed
    #####: 5098:               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
    %%%%%: 5098-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5098-block  1
    #####: 5099:               if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
    %%%%%: 5099-block  0
branch  0 never executed
branch  1 never executed
    #####: 5100:               if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
    %%%%%: 5100-block  0
branch  0 never executed
branch  1 never executed
        -: 5101:               pal_img_n = 4;
    #####: 5102:               for (i=0; i < c.length; ++i)
    %%%%%: 5102-block  0
branch  0 never executed
branch  1 never executed
    #####: 5103:                  palette[i*4+3] = stbi__get8(s);
    %%%%%: 5103-block  0
call    0 never executed
        -: 5104:            } else {
    #####: 5105:               if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
    %%%%%: 5105-block  0
branch  0 never executed
branch  1 never executed
    #####: 5106:               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
    %%%%%: 5106-block  0
branch  0 never executed
branch  1 never executed
        -: 5107:               has_trans = 1;
    #####: 5108:               if (z->depth == 16) {
    %%%%%: 5108-block  0
branch  0 never executed
branch  1 never executed
    #####: 5109:                  for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
    %%%%%: 5109-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5109-block  1
call    2 never executed
        -: 5110:               } else {
    #####: 5111:                  for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
    %%%%%: 5111-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5111-block  1
call    2 never executed
        -: 5112:               }
        -: 5113:            }
        -: 5114:            break;
        -: 5115:         }
        -: 5116:
      107: 5117:         case STBI__PNG_TYPE('I','D','A','T'): {
      107: 5118:            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
      107: 5118-block  0
branch  0 taken 107 (fallthrough)
branch  1 taken 0
      107: 5119:            if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
      107: 5119-block  0
branch  0 taken 107 (fallthrough)
branch  1 taken 0
     107*: 5120:            if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }
      107: 5120-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 107
    %%%%%: 5120-block  1
      107: 5121:            if ((int)(ioff + c.length) < (int)ioff) return 0;
      107: 5121-block  0
branch  0 taken 107 (fallthrough)
branch  1 taken 0
      107: 5122:            if (ioff + c.length > idata_limit) {
      107: 5122-block  0
branch  0 taken 8 (fallthrough)
branch  1 taken 99
        -: 5123:               stbi__uint32 idata_limit_old = idata_limit;
        -: 5124:               stbi_uc *p;
        8: 5125:               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
        8: 5125-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 7
        1: 5125-block  1
       15: 5126:               while (ioff + c.length > idata_limit)
       15: 5126-block  0
branch  0 taken 7 (fallthrough)
branch  1 taken 8
        7: 5127:                  idata_limit *= 2;
        7: 5127-block  0
        -: 5128:               STBI_NOTUSED(idata_limit_old);
        8: 5129:               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
        8: 5129-block  0
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        8: 5130:               z->idata = p;
        8: 5130-block  0
        -: 5131:            }
      107: 5132:            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
      107: 5132-block  0
call    0 returned 107
branch  1 taken 107
branch  2 taken 0
        -: 5133:            ioff += c.length;
        -: 5134:            break;
        -: 5135:         }
        -: 5136:
        1: 5137:         case STBI__PNG_TYPE('I','E','N','D'): {
        -: 5138:            stbi__uint32 raw_len, bpl;
        1: 5139:            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
        1: 5139-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5140:            if (scan != STBI__SCAN_load) return 1;
        1: 5140-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5141:            if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
        1: 5141-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 5142:            // initial guess for decoded data size to avoid unnecessary reallocs
        1: 5143:            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
        1: 5144:            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
        1: 5145:            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
        1: 5145-block  0
call    0 returned 1
        1: 5146:            if (z->expanded == NULL) return 0; // zlib should set error
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5147:            STBI_FREE(z->idata); z->idata = NULL;
       1*: 5148:            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
        1: 5148-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5148-block  1
branch  2 never executed
branch  3 never executed
        1: 5148-block  2
branch  4 taken 0 (fallthrough)
branch  5 taken 1
    #####: 5149:               s->img_out_n = s->img_n+1;
    %%%%%: 5149-block  0
        -: 5150:            else
        1: 5151:               s->img_out_n = s->img_n;
        1: 5151-block  0
        1: 5152:            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
        1: 5152-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1: 5153:            if (has_trans) {
        1: 5153-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 5154:               if (z->depth == 16) {
    %%%%%: 5154-block  0
branch  0 never executed
branch  1 never executed
    #####: 5155:                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
    %%%%%: 5155-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5156:               } else {
    #####: 5157:                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
    %%%%%: 5157-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5158:               }
        -: 5159:            }
       1*: 5160:            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
        1: 5160-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%: 5160-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 5160-block  2
    %%%%%: 5160-block  3
    %%%%%: 5160-block  4
branch  4 never executed
branch  5 never executed
    %%%%%: 5160-block  5
branch  6 never executed
branch  7 never executed
    #####: 5161:               stbi__de_iphone(z);
    %%%%%: 5161-block  0
call    0 never executed
        1: 5162:            if (pal_img_n) {
        1: 5162-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 5163:               // pal_img_n == 3 or 4
    #####: 5164:               s->img_n = pal_img_n; // record the actual colors we had
    #####: 5165:               s->img_out_n = pal_img_n;
    #####: 5166:               if (req_comp >= 3) s->img_out_n = req_comp;
    %%%%%: 5166-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5166-block  1
    #####: 5167:               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
    %%%%%: 5167-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5168:                  return 0;
        1: 5169:            } else if (has_trans) {
        1: 5169-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 5170:               // non-paletted image with tRNS -> source image has (constant) alpha
    #####: 5171:               ++s->img_n;
    %%%%%: 5171-block  0
        -: 5172:            }
        1: 5173:            STBI_FREE(z->expanded); z->expanded = NULL;
        -: 5174:            // end of PNG chunk, read and skip CRC
        1: 5175:            stbi__get32be(s);
        1: 5175-block  0
call    0 returned 1
        -: 5176:            return 1;
        -: 5177:         }
        -: 5178:
        6: 5179:         default:
        -: 5180:            // if critical, fail
        6: 5181:            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
        6: 5181-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 0
        6: 5182:            if ((c.type & (1 << 29)) == 0) {
        6: 5182-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 0
        -: 5183:               #ifndef STBI_NO_FAILURE_STRINGS
        -: 5184:               // not threadsafe
        -: 5185:               static char invalid_chunk[] = "XXXX PNG chunk not known";
        -: 5186:               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
        -: 5187:               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
        -: 5188:               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
        -: 5189:               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
        -: 5190:               #endif
        -: 5191:               return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
        -: 5192:            }
        6: 5193:            stbi__skip(s, c.length);
        6: 5193-block  0
call    0 returned 6
        -: 5194:            break;
        -: 5195:      }
        -: 5196:      // end of PNG chunk, read and skip CRC
      114: 5197:      stbi__get32be(s);
      114: 5197-block  0
call    0 returned 114
        -: 5198:   }
        -: 5199:}
        -: 5200:
function _ZL12stbi__do_pngP9stbi__pngPiS1_S1_iP17stbi__result_info called 1 returned 100% blocks executed 65%
        1: 5201:static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
        -: 5202:{
        -: 5203:   void *result=NULL;
        1: 5204:   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
        1: 5204-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5205:   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
        1: 5205-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
        1: 5206:      if (p->depth <= 8)
        1: 5206-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5207:         ri->bits_per_channel = 8;
        1: 5207-block  0
    #####: 5208:      else if (p->depth == 16)
    %%%%%: 5208-block  0
branch  0 never executed
branch  1 never executed
    #####: 5209:         ri->bits_per_channel = 16;
    %%%%%: 5209-block  0
        -: 5210:      else
        -: 5211:         return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
        1: 5212:      result = p->out;
        1: 5213:      p->out = NULL;
        1: 5214:      if (req_comp && req_comp != p->s->img_out_n) {
        1: 5214-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5214-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####: 5215:         if (ri->bits_per_channel == 8)
    %%%%%: 5215-block  0
branch  0 never executed
branch  1 never executed
    #####: 5216:            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
    %%%%%: 5216-block  0
call    0 never executed
        -: 5217:         else
    #####: 5218:            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
    %%%%%: 5218-block  0
call    0 never executed
    #####: 5219:         p->s->img_out_n = req_comp;
    #####: 5220:         if (result == NULL) return result;
    %%%%%: 5220-block  0
branch  0 never executed
branch  1 never executed
        -: 5221:      }
        1: 5222:      *x = p->s->img_x;
        1: 5223:      *y = p->s->img_y;
        1: 5224:      if (n) *n = p->s->img_n;
        1: 5224-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 5224-block  1
        -: 5225:   }
        1: 5226:   STBI_FREE(p->out);      p->out      = NULL;
        1: 5227:   STBI_FREE(p->expanded); p->expanded = NULL;
        1: 5228:   STBI_FREE(p->idata);    p->idata    = NULL;
        -: 5229:
        1: 5230:   return result;
        1: 5230-block  0
        -: 5231:}
        -: 5232:
        -: 5233:static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 5234:{
        -: 5235:   stbi__png p;
        1: 5236:   p.s = s;
        1: 5237:   return stbi__do_png(&p, x,y,comp,req_comp, ri);
        1: 5237-block  0
call    0 returned 1
        -: 5238:}
        -: 5239:
function _ZL14stbi__png_testP13stbi__context called 1 returned 100% blocks executed 100%
        1: 5240:static int stbi__png_test(stbi__context *s)
        1: 5240-block  0
        -: 5241:{
        -: 5242:   int r;
        -: 5243:   r = stbi__check_png_header(s);
        -: 5244:   stbi__rewind(s);
        1: 5245:   return r;
        -: 5246:}
        -: 5247:
function _ZL18stbi__png_info_rawP9stbi__pngPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 5248:static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
        -: 5249:{
    #####: 5250:   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
branch  0 never executed
branch  1 never executed
    %%%%%: 5250-block  0
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5251:      stbi__rewind( p->s );
    #####: 5252:      return 0;
    %%%%%: 5252-block  0
        -: 5253:   }
    #####: 5254:   if (x) *x = p->s->img_x;
    %%%%%: 5254-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5254-block  1
    #####: 5255:   if (y) *y = p->s->img_y;
    %%%%%: 5255-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5255-block  1
    #####: 5256:   if (comp) *comp = p->s->img_n;
    %%%%%: 5256-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5256-block  1
        -: 5257:   return 1;
        -: 5258:}
        -: 5259:
        -: 5260:static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
        -: 5261:{
        -: 5262:   stbi__png p;
    #####: 5263:   p.s = s;
    #####: 5264:   return stbi__png_info_raw(&p, x, y, comp);
    %%%%%: 5264-block  0
call    0 never executed
        -: 5265:}
        -: 5266:
function _ZL14stbi__png_is16P13stbi__context called 0 returned 0% blocks executed 0%
    #####: 5267:static int stbi__png_is16(stbi__context *s)
        -: 5268:{
        -: 5269:   stbi__png p;
    #####: 5270:   p.s = s;
    %%%%%: 5270-block  0
call    0 never executed
        -: 5271:   if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
    #####: 5272:	   return 0;
    %%%%%: 5272-block  0
    #####: 5273:   if (p.depth != 16) {
    %%%%%: 5273-block  0
branch  0 never executed
branch  1 never executed
    #####: 5274:      stbi__rewind(p.s);
    #####: 5275:      return 0;
    %%%%%: 5275-block  0
        -: 5276:   }
        -: 5277:   return 1;
        -: 5278:}
        -: 5279:#endif
        -: 5280:
        -: 5281:// Microsoft/Windows BMP image
        -: 5282:
        -: 5283:#ifndef STBI_NO_BMP
function _ZL18stbi__bmp_test_rawP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 5284:static int stbi__bmp_test_raw(stbi__context *s)
        -: 5285:{
        -: 5286:   int r;
        -: 5287:   int sz;
    #####: 5288:   if (stbi__get8(s) != 'B') return 0;
    %%%%%: 5288-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5289:   if (stbi__get8(s) != 'M') return 0;
    %%%%%: 5289-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5290:   stbi__get32le(s); // discard filesize
    %%%%%: 5290-block  0
call    0 never executed
    #####: 5291:   stbi__get16le(s); // discard reserved
call    0 never executed
    #####: 5292:   stbi__get16le(s); // discard reserved
call    0 never executed
    #####: 5293:   stbi__get32le(s); // discard data offset
call    0 never executed
    #####: 5294:   sz = stbi__get32le(s);
call    0 never executed
    #####: 5295:   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
branch  0 never executed
branch  1 never executed
    %%%%%: 5295-block  0
branch  2 never executed
branch  3 never executed
    %%%%%: 5295-block  1
branch  4 never executed
branch  5 never executed
    #####: 5296:   return r;
    %%%%%: 5296-block  0
        -: 5297:}
        -: 5298:
        -: 5299:static int stbi__bmp_test(stbi__context *s)
        -: 5300:{
    #####: 5301:   int r = stbi__bmp_test_raw(s);
    %%%%%: 5301-block  0
call    0 never executed
        -: 5302:   stbi__rewind(s);
        -: 5303:   return r;
        -: 5304:}
        -: 5305:
        -: 5306:
        -: 5307:// returns 0..31 for the highest set bit
function _ZL14stbi__high_bitj called 0 returned 0% blocks executed 0%
    #####: 5308:static int stbi__high_bit(unsigned int z)
        -: 5309:{
        -: 5310:   int n=0;
    #####: 5311:   if (z == 0) return -1;
    %%%%%: 5311-block  0
branch  0 never executed
branch  1 never executed
    #####: 5312:   if (z >= 0x10000) { n += 16; z >>= 16; }
    %%%%%: 5312-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5312-block  1
    #####: 5313:   if (z >= 0x00100) { n +=  8; z >>=  8; }
    %%%%%: 5313-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5313-block  1
    #####: 5314:   if (z >= 0x00010) { n +=  4; z >>=  4; }
    %%%%%: 5314-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5314-block  1
    #####: 5315:   if (z >= 0x00004) { n +=  2; z >>=  2; }
    %%%%%: 5315-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5315-block  1
    #####: 5316:   if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
    %%%%%: 5316-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5316-block  1
        -: 5317:   return n;
        -: 5318:}
        -: 5319:
        -: 5320:static int stbi__bitcount(unsigned int a)
        -: 5321:{
    #####: 5322:   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
    #####: 5323:   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
    #####: 5324:   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
    #####: 5325:   a = (a + (a >> 8)); // max 16 per 8 bits
    #####: 5326:   a = (a + (a >> 16)); // max 32 per 8 bits
    #####: 5327:   return a & 0xff;
        -: 5328:}
        -: 5329:
        -: 5330:// extract an arbitrarily-aligned N-bit value (N=bits)
        -: 5331:// from v, and then make it 8-bits long and fractionally
        -: 5332:// extend it to full full range.
function _ZL17stbi__shiftsignedjii called 0 returned 0% blocks executed 0%
    #####: 5333:static int stbi__shiftsigned(unsigned int v, int shift, int bits)
        -: 5334:{
        -: 5335:   static unsigned int mul_table[9] = {
        -: 5336:      0,
        -: 5337:      0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
        -: 5338:      0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
        -: 5339:   };
        -: 5340:   static unsigned int shift_table[9] = {
        -: 5341:      0, 0,0,1,0,2,4,6,0,
        -: 5342:   };
    #####: 5343:   if (shift < 0)
    %%%%%: 5343-block  0
branch  0 never executed
branch  1 never executed
    #####: 5344:      v <<= -shift;
    %%%%%: 5344-block  0
        -: 5345:   else
    #####: 5346:      v >>= shift;
    %%%%%: 5346-block  0
    #####: 5347:   STBI_ASSERT(v < 256);
    %%%%%: 5347-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5347-block  1
call    2 never executed
    #####: 5348:   v >>= (8-bits);
    #####: 5349:   STBI_ASSERT(bits >= 0 && bits <= 8);
    %%%%%: 5349-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5349-block  1
call    2 never executed
    #####: 5350:   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
        -: 5351:}
        -: 5352:
        -: 5353:typedef struct
        -: 5354:{
        -: 5355:   int bytes_per_pixel, offset, hsz;
        -: 5356:   unsigned int mr,mg,mb,ma, all_a;
        -: 5357:   int extra_read;
        -: 5358:} stbi__bmp_data;
        -: 5359:
        -: 5360:static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
        -: 5361:{
        -: 5362:   // BI_BITFIELDS specifies masks explicitly, don't override
        -: 5363:   if (compress == 3)
        -: 5364:      return 1;
        -: 5365:
    #####: 5366:   if (compress == 0) {
    %%%%%: 5366-block  0
branch  0 never executed
branch  1 never executed
    #####: 5367:      if (info->bytes_per_pixel == 16) {
    %%%%%: 5367-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5367-block  1
branch  2 never executed
branch  3 never executed
    #####: 5368:         info->mr = 31u << 10;
    #####: 5369:         info->mg = 31u <<  5;
    #####: 5370:         info->mb = 31u <<  0;
    %%%%%: 5370-block  0
    %%%%%: 5370-block  1
    #####: 5371:      } else if (info->bytes_per_pixel == 32) {
    %%%%%: 5371-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5371-block  1
branch  2 never executed
branch  3 never executed
    #####: 5372:         info->mr = 0xffu << 16;
    #####: 5373:         info->mg = 0xffu <<  8;
    #####: 5374:         info->mb = 0xffu <<  0;
    #####: 5375:         info->ma = 0xffu << 24;
    #####: 5376:         info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
    %%%%%: 5376-block  0
    %%%%%: 5376-block  1
        -: 5377:      } else {
        -: 5378:         // otherwise, use defaults, which is all-0
    #####: 5379:         info->mr = info->mg = info->mb = info->ma = 0;
    %%%%%: 5379-block  0
    %%%%%: 5379-block  1
        -: 5380:      }
        -: 5381:      return 1;
        -: 5382:   }
        -: 5383:   return 0; // error
        -: 5384:}
        -: 5385:
function _ZL22stbi__bmp_parse_headerP13stbi__contextP14stbi__bmp_data called 0 returned 0% blocks executed 0%
    #####: 5386:static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
        -: 5387:{
        -: 5388:   int hsz;
    #####: 5389:   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
    %%%%%: 5389-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%: 5389-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    %%%%%: 5389-block  2
    #####: 5390:   stbi__get32le(s); // discard filesize
    %%%%%: 5390-block  0
call    0 never executed
    #####: 5391:   stbi__get16le(s); // discard reserved
call    0 never executed
    #####: 5392:   stbi__get16le(s); // discard reserved
call    0 never executed
    #####: 5393:   info->offset = stbi__get32le(s);
call    0 never executed
    #####: 5394:   info->hsz = hsz = stbi__get32le(s);
call    0 never executed
    #####: 5395:   info->mr = info->mg = info->mb = info->ma = 0;
    #####: 5396:   info->extra_read = 14;
        -: 5397:
    #####: 5398:   if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");
branch  0 never executed
branch  1 never executed
        -: 5399:
    #####: 5400:   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
    %%%%%: 5400-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5400-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 5400-block  2
branch  4 never executed
branch  5 never executed
    #####: 5401:   if (hsz == 12) {
    %%%%%: 5401-block  0
branch  0 never executed
branch  1 never executed
    #####: 5402:      s->img_x = stbi__get16le(s);
    %%%%%: 5402-block  0
call    0 never executed
    #####: 5403:      s->img_y = stbi__get16le(s);
call    0 never executed
        -: 5404:   } else {
    #####: 5405:      s->img_x = stbi__get32le(s);
    %%%%%: 5405-block  0
call    0 never executed
    #####: 5406:      s->img_y = stbi__get32le(s);
call    0 never executed
        -: 5407:   }
    #####: 5408:   if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
    %%%%%: 5408-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5409:   info->bytes_per_pixel = stbi__get16le(s);
    %%%%%: 5409-block  0
call    0 never executed
    #####: 5410:   if (hsz != 12) {
branch  0 never executed
branch  1 never executed
    #####: 5411:      int compress = stbi__get32le(s);
    %%%%%: 5411-block  0
call    0 never executed
    #####: 5412:      if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
branch  0 never executed
branch  1 never executed
    #####: 5413:      if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes
    %%%%%: 5413-block  0
branch  0 never executed
branch  1 never executed
    #####: 5414:      if (compress == 3 && info->bytes_per_pixel != 16 && info->bytes_per_pixel != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel
    %%%%%: 5414-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5414-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 5414-block  2
branch  4 never executed
branch  5 never executed
    #####: 5415:      stbi__get32le(s); // discard sizeof
    %%%%%: 5415-block  0
call    0 never executed
    #####: 5416:      stbi__get32le(s); // discard hres
call    0 never executed
    #####: 5417:      stbi__get32le(s); // discard vres
call    0 never executed
    #####: 5418:      stbi__get32le(s); // discard colorsused
call    0 never executed
    #####: 5419:      stbi__get32le(s); // discard max important
call    0 never executed
    #####: 5420:      if (hsz == 40 || hsz == 56) {
branch  0 never executed
branch  1 never executed
    #####: 5421:         if (hsz == 56) {
    %%%%%: 5421-block  0
branch  0 never executed
branch  1 never executed
    #####: 5422:            stbi__get32le(s);
    %%%%%: 5422-block  0
call    0 never executed
    #####: 5423:            stbi__get32le(s);
call    0 never executed
    #####: 5424:            stbi__get32le(s);
call    0 never executed
    #####: 5425:            stbi__get32le(s);
call    0 never executed
        -: 5426:         }
    #####: 5427:         if (info->bytes_per_pixel == 16 || info->bytes_per_pixel == 32) {
    %%%%%: 5427-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5427-block  1
branch  2 never executed
branch  3 never executed
    #####: 5428:            if (compress == 0) {
    %%%%%: 5428-block  0
branch  0 never executed
branch  1 never executed
        -: 5429:               stbi__bmp_set_mask_defaults(info, compress);
    #####: 5430:            } else if (compress == 3) {
    %%%%%: 5430-block  0
branch  0 never executed
branch  1 never executed
    #####: 5431:               info->mr = stbi__get32le(s);
    %%%%%: 5431-block  0
call    0 never executed
    #####: 5432:               info->mg = stbi__get32le(s);
call    0 never executed
    #####: 5433:               info->mb = stbi__get32le(s);
call    0 never executed
    #####: 5434:               info->extra_read += 12;
        -: 5435:               // not documented, but generated by photoshop and handled by mspaint
    #####: 5436:               if (info->mr == info->mg && info->mg == info->mb) {
branch  0 never executed
branch  1 never executed
    %%%%%: 5436-block  0
branch  2 never executed
branch  3 never executed
        -: 5437:                  // ?!?!?
    #####: 5438:                  return stbi__errpuc("bad BMP", "bad BMP");
    %%%%%: 5438-block  0
        -: 5439:               }
        -: 5440:            } else
        -: 5441:               return stbi__errpuc("bad BMP", "bad BMP");
        -: 5442:         }
        -: 5443:      } else {
        -: 5444:         // V4/V5 header
        -: 5445:         int i;
    #####: 5446:         if (hsz != 108 && hsz != 124)
    %%%%%: 5446-block  0
branch  0 never executed
branch  1 never executed
        -: 5447:            return stbi__errpuc("bad BMP", "bad BMP");
    #####: 5448:         info->mr = stbi__get32le(s);
    %%%%%: 5448-block  0
call    0 never executed
    #####: 5449:         info->mg = stbi__get32le(s);
call    0 never executed
    #####: 5450:         info->mb = stbi__get32le(s);
call    0 never executed
    #####: 5451:         info->ma = stbi__get32le(s);
call    0 never executed
    #####: 5452:         if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
branch  0 never executed
branch  1 never executed
        -: 5453:            stbi__bmp_set_mask_defaults(info, compress);
    #####: 5454:         stbi__get32le(s); // discard color space
    %%%%%: 5454-block  0
call    0 never executed
    #####: 5455:         for (i=0; i < 12; ++i)
    %%%%%: 5455-block  0
branch  0 never executed
branch  1 never executed
    #####: 5456:            stbi__get32le(s); // discard color space parameters
    %%%%%: 5456-block  0
call    0 never executed
    #####: 5457:         if (hsz == 124) {
    %%%%%: 5457-block  0
branch  0 never executed
branch  1 never executed
    #####: 5458:            stbi__get32le(s); // discard rendering intent
    %%%%%: 5458-block  0
call    0 never executed
    #####: 5459:            stbi__get32le(s); // discard offset of profile data
call    0 never executed
    #####: 5460:            stbi__get32le(s); // discard size of profile data
call    0 never executed
    #####: 5461:            stbi__get32le(s); // discard reserved
call    0 never executed
        -: 5462:         }
        -: 5463:      }
        -: 5464:   }
        -: 5465:   return (void *) 1;
        -: 5466:}
        -: 5467:
        -: 5468:
function _ZL14stbi__bmp_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 5469:static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 5470:{
        -: 5471:   stbi_uc *out;
        -: 5472:   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
        -: 5473:   stbi_uc pal[256][4];
        -: 5474:   int psize=0,i,j,width;
        -: 5475:   int flip_vertically, pad, target;
        -: 5476:   stbi__bmp_data info;
        -: 5477:   STBI_NOTUSED(ri);
        -: 5478:
    #####: 5479:   info.all_a = 255;
    #####: 5480:   if (stbi__bmp_parse_header(s, &info) == NULL)
    %%%%%: 5480-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5481:      return NULL; // error code already set
        -: 5482:
    #####: 5483:   flip_vertically = ((int) s->img_y) > 0;
    #####: 5484:   s->img_y = abs((int) s->img_y);
        -: 5485:
    #####: 5486:   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 5486-block  0
branch  0 never executed
branch  1 never executed
    #####: 5487:   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 5487-block  0
branch  0 never executed
branch  1 never executed
        -: 5488:
    #####: 5489:   mr = info.mr;
    #####: 5490:   mg = info.mg;
    #####: 5491:   mb = info.mb;
    #####: 5492:   ma = info.ma;
    #####: 5493:   all_a = info.all_a;
        -: 5494:
    #####: 5495:   if (info.hsz == 12) {
    %%%%%: 5495-block  0
branch  0 never executed
branch  1 never executed
    #####: 5496:      if (info.bytes_per_pixel < 24)
    %%%%%: 5496-block  0
branch  0 never executed
branch  1 never executed
    #####: 5497:         psize = (info.offset - info.extra_read - 24) / 3;
    %%%%%: 5497-block  0
        -: 5498:   } else {
    #####: 5499:      if (info.bytes_per_pixel < 16)
    %%%%%: 5499-block  0
branch  0 never executed
branch  1 never executed
    #####: 5500:         psize = (info.offset - info.extra_read - info.hsz) >> 2;
    %%%%%: 5500-block  0
        -: 5501:   }
    #####: 5502:   if (psize == 0) {
    %%%%%: 5502-block  0
branch  0 never executed
branch  1 never executed
    #####: 5503:      if (info.offset != s->callback_already_read + (s->img_buffer - s->img_buffer_original)) {
    %%%%%: 5503-block  0
branch  0 never executed
branch  1 never executed
        -: 5504:        return stbi__errpuc("bad offset", "Corrupt BMP");
        -: 5505:      }
        -: 5506:   }
        -: 5507:
    #####: 5508:   if (info.bytes_per_pixel == 24 && ma == 0xff000000)
    %%%%%: 5508-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5508-block  1
branch  2 never executed
branch  3 never executed
    #####: 5509:      s->img_n = 3;
    %%%%%: 5509-block  0
        -: 5510:   else
    #####: 5511:      s->img_n = ma ? 4 : 3;
    %%%%%: 5511-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5511-block  1
    #####: 5512:   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
    %%%%%: 5512-block  0
branch  0 never executed
branch  1 never executed
        -: 5513:      target = req_comp;
        -: 5514:   else
    #####: 5515:      target = s->img_n; // if they want monochrome, we'll post-convert
    %%%%%: 5515-block  0
        -: 5516:
        -: 5517:   // sanity-check size
    #####: 5518:   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
    %%%%%: 5518-block  0
branch  0 never executed
branch  1 never executed
        -: 5519:      return stbi__errpuc("too large", "Corrupt BMP");
        -: 5520:
    #####: 5521:   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
    %%%%%: 5521-block  0
call    0 never executed
    #####: 5522:   if (!out) return stbi__errpuc("outofmem", "Out of memory");
branch  0 never executed
branch  1 never executed
    #####: 5523:   if (info.bytes_per_pixel < 16) {
    %%%%%: 5523-block  0
branch  0 never executed
branch  1 never executed
        -: 5524:      int z=0;
    #####: 5525:      if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
    %%%%%: 5525-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5525-block  1
    #####: 5526:      for (i=0; i < psize; ++i) {
    %%%%%: 5526-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5526-block  1
    #####: 5527:         pal[i][2] = stbi__get8(s);
    %%%%%: 5527-block  0
call    0 never executed
    #####: 5528:         pal[i][1] = stbi__get8(s);
call    0 never executed
    #####: 5529:         pal[i][0] = stbi__get8(s);
call    0 never executed
    #####: 5530:         if (info.hsz != 12) stbi__get8(s);
branch  0 never executed
branch  1 never executed
    %%%%%: 5530-block  0
call    2 never executed
        -: 5531:         pal[i][3] = 255;
        -: 5532:      }
    #####: 5533:      stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
    %%%%%: 5533-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5533-block  1
call    2 never executed
    #####: 5534:      if (info.bytes_per_pixel == 1) width = (s->img_x + 7) >> 3;
branch  0 never executed
branch  1 never executed
    %%%%%: 5534-block  0
    #####: 5535:      else if (info.bytes_per_pixel == 4) width = (s->img_x + 1) >> 1;
    %%%%%: 5535-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5535-block  1
    #####: 5536:      else if (info.bytes_per_pixel == 8) width = s->img_x;
    %%%%%: 5536-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5536-block  1
    #####: 5537:      else { STBI_FREE(out); return stbi__errpuc("bad bytes_per_pixel", "Corrupt BMP"); }
    %%%%%: 5537-block  0
    #####: 5538:      pad = (-width)&3;
    #####: 5539:      if (info.bytes_per_pixel == 1) {
    %%%%%: 5539-block  0
branch  0 never executed
branch  1 never executed
    #####: 5540:         for (j=0; j < (int) s->img_y; ++j) {
    %%%%%: 5540-block  0
branch  0 never executed
branch  1 never executed
    #####: 5541:            int bit_offset = 7, v = stbi__get8(s);
    %%%%%: 5541-block  0
call    0 never executed
    #####: 5542:            for (i=0; i < (int) s->img_x; ++i) {
    %%%%%: 5542-block  0
branch  0 never executed
branch  1 never executed
    #####: 5543:               int color = (v>>bit_offset)&0x1;
    #####: 5544:               out[z++] = pal[color][0];
    #####: 5545:               out[z++] = pal[color][1];
    #####: 5546:               out[z++] = pal[color][2];
    #####: 5547:               if (target == 4) out[z++] = 255;
    %%%%%: 5547-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5547-block  1
    #####: 5548:               if (i+1 == (int) s->img_x) break;
    %%%%%: 5548-block  0
branch  0 never executed
branch  1 never executed
    #####: 5549:               if((--bit_offset) < 0) {
    %%%%%: 5549-block  0
branch  0 never executed
branch  1 never executed
        -: 5550:                  bit_offset = 7;
    #####: 5551:                  v = stbi__get8(s);
    %%%%%: 5551-block  0
call    0 never executed
        -: 5552:               }
        -: 5553:            }
    #####: 5554:            stbi__skip(s, pad);
    %%%%%: 5554-block  0
call    0 never executed
        -: 5555:         }
        -: 5556:      } else {
    #####: 5557:         for (j=0; j < (int) s->img_y; ++j) {
    %%%%%: 5557-block  0
branch  0 never executed
branch  1 never executed
    #####: 5558:            for (i=0; i < (int) s->img_x; i += 2) {
    %%%%%: 5558-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5558-block  1
    #####: 5559:               int v=stbi__get8(s),v2=0;
    %%%%%: 5559-block  0
call    0 never executed
    #####: 5560:               if (info.bytes_per_pixel == 4) {
branch  0 never executed
branch  1 never executed
    #####: 5561:                  v2 = v & 15;
    #####: 5562:                  v >>= 4;
    %%%%%: 5562-block  0
        -: 5563:               }
    #####: 5564:               out[z++] = pal[v][0];
    #####: 5565:               out[z++] = pal[v][1];
    #####: 5566:               out[z++] = pal[v][2];
    #####: 5567:               if (target == 4) out[z++] = 255;
    %%%%%: 5567-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5567-block  1
    #####: 5568:               if (i+1 == (int) s->img_x) break;
    %%%%%: 5568-block  0
branch  0 never executed
branch  1 never executed
    #####: 5569:               v = (info.bytes_per_pixel == 8) ? stbi__get8(s) : v2;
    %%%%%: 5569-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5569-block  1
call    2 never executed
    #####: 5570:               out[z++] = pal[v][0];
    #####: 5571:               out[z++] = pal[v][1];
    #####: 5572:               out[z++] = pal[v][2];
    #####: 5573:               if (target == 4) out[z++] = 255;
    %%%%%: 5573-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5573-block  1
        -: 5574:            }
    #####: 5575:            stbi__skip(s, pad);
    %%%%%: 5575-block  0
call    0 never executed
        -: 5576:         }
        -: 5577:      }
        -: 5578:   } else {
        -: 5579:      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
        -: 5580:      int z = 0;
        -: 5581:      int easy=0;
    #####: 5582:      stbi__skip(s, info.offset - info.extra_read - info.hsz);
    %%%%%: 5582-block  0
call    0 never executed
    #####: 5583:      if (info.bytes_per_pixel == 24) width = 3 * s->img_x;
branch  0 never executed
branch  1 never executed
    %%%%%: 5583-block  0
    #####: 5584:      else if (info.bytes_per_pixel == 16) width = 2*s->img_x;
    %%%%%: 5584-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5584-block  1
        -: 5585:      else /* bytes_per_pixel = 32 and pad = 0 */ width=0;
    #####: 5586:      pad = (-width) & 3;
    #####: 5587:      if (info.bytes_per_pixel == 24) {
    %%%%%: 5587-block  0
branch  0 never executed
branch  1 never executed
        -: 5588:         easy = 1;
    #####: 5589:      } else if (info.bytes_per_pixel == 32) {
    %%%%%: 5589-block  0
branch  0 never executed
branch  1 never executed
    #####: 5590:         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
    %%%%%: 5590-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5590-block  1
branch  2 never executed
branch  3 never executed
        -: 5591:            easy = 2;
        -: 5592:      }
        -: 5593:      if (!easy) {
    #####: 5594:         if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
    %%%%%: 5594-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5594-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 5594-block  2
        -: 5595:         // right shift amt to put high bit in position #7
    #####: 5596:         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
    #####: 5597:         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
    #####: 5598:         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
    #####: 5599:         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
    #####: 5600:         if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
    %%%%%: 5600-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5600-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 5600-block  2
        -: 5601:      }
    #####: 5602:      for (j=0; j < (int) s->img_y; ++j) {
    %%%%%: 5602-block  0
branch  0 never executed
branch  1 never executed
    #####: 5603:         if (easy) {
    %%%%%: 5603-block  0
branch  0 never executed
branch  1 never executed
    #####: 5604:            for (i=0; i < (int) s->img_x; ++i) {
    %%%%%: 5604-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5604-block  1
        -: 5605:               unsigned char a;
    #####: 5606:               out[z+2] = stbi__get8(s);
    %%%%%: 5606-block  0
call    0 never executed
    #####: 5607:               out[z+1] = stbi__get8(s);
call    0 never executed
    #####: 5608:               out[z+0] = stbi__get8(s);
call    0 never executed
    #####: 5609:               z += 3;
    #####: 5610:               a = (easy == 2 ? stbi__get8(s) : 255);
branch  0 never executed
branch  1 never executed
    %%%%%: 5610-block  0
call    2 never executed
    #####: 5611:               all_a |= a;
    #####: 5612:               if (target == 4) out[z++] = a;
    %%%%%: 5612-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5612-block  1
        -: 5613:            }
        -: 5614:         } else {
    #####: 5615:            int bytes_per_pixel = info.bytes_per_pixel;
    %%%%%: 5615-block  0
    #####: 5616:            for (i=0; i < (int) s->img_x; ++i) {
    %%%%%: 5616-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5616-block  1
    #####: 5617:               stbi__uint32 v = (bytes_per_pixel == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
    %%%%%: 5617-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5617-block  1
call    2 never executed
    %%%%%: 5617-block  2
call    3 never executed
        -: 5618:               unsigned int a;
    #####: 5619:               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
    %%%%%: 5619-block  0
call    0 never executed
    #####: 5620:               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
call    0 never executed
    #####: 5621:               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
call    0 never executed
    #####: 5622:               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
branch  0 never executed
branch  1 never executed
    %%%%%: 5622-block  0
call    2 never executed
    #####: 5623:               all_a |= a;
    #####: 5624:               if (target == 4) out[z++] = STBI__BYTECAST(a);
    %%%%%: 5624-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5624-block  1
        -: 5625:            }
        -: 5626:         }
    #####: 5627:         stbi__skip(s, pad);
    %%%%%: 5627-block  0
call    0 never executed
        -: 5628:      }
        -: 5629:   }
        -: 5630:
        -: 5631:   // if alpha channel is all 0s, replace with all 255s
    #####: 5632:   if (target == 4 && all_a == 0)
    %%%%%: 5632-block  0
branch  0 never executed
branch  1 never executed
    #####: 5633:      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
    %%%%%: 5633-block  0
    %%%%%: 5633-block  1
branch  0 never executed
branch  1 never executed
    #####: 5634:         out[i] = 255;
    %%%%%: 5634-block  0
        -: 5635:
    #####: 5636:   if (flip_vertically) {
    %%%%%: 5636-block  0
branch  0 never executed
branch  1 never executed
        -: 5637:      stbi_uc t;
    #####: 5638:      for (j=0; j < (int) s->img_y>>1; ++j) {
    %%%%%: 5638-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5638-block  1
    #####: 5639:         stbi_uc *p1 = out +      j     *s->img_x*target;
    #####: 5640:         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
    %%%%%: 5640-block  0
    #####: 5641:         for (i=0; i < (int) s->img_x*target; ++i) {
    %%%%%: 5641-block  0
branch  0 never executed
branch  1 never executed
    #####: 5642:            t = p1[i]; p1[i] = p2[i]; p2[i] = t;
    %%%%%: 5642-block  0
        -: 5643:         }
        -: 5644:      }
        -: 5645:   }
        -: 5646:
    #####: 5647:   if (req_comp && req_comp != target) {
    %%%%%: 5647-block  0
branch  0 never executed
branch  1 never executed
    #####: 5648:      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
    %%%%%: 5648-block  0
call    0 never executed
    #####: 5649:      if (out == NULL) return out; // stbi__convert_format frees input on failure
branch  0 never executed
branch  1 never executed
        -: 5650:   }
        -: 5651:
    #####: 5652:   *x = s->img_x;
    #####: 5653:   *y = s->img_y;
    #####: 5654:   if (comp) *comp = s->img_n;
    %%%%%: 5654-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5654-block  1
        -: 5655:   return out;
        -: 5656:}
        -: 5657:#endif
        -: 5658:
        -: 5659:// Targa Truevision - TGA
        -: 5660:// by Jonathan Dummer
        -: 5661:#ifndef STBI_NO_TGA
        -: 5662:// returns STBI_rgb or whatever, 0 on error
        -: 5663:static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
        -: 5664:{
        -: 5665:   // only RGB or RGBA (incl. 16bit) or grey allowed
        -: 5666:   if (is_rgb16) *is_rgb16 = 0;
    #####: 5667:   switch(bits_per_pixel) {
    %%%%%: 5667-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    %%%%%: 5667-block  1
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    %%%%%: 5667-block  2
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
        -: 5668:      case 8:  return STBI_grey;
    #####: 5669:      case 16: if(is_grey) return STBI_grey_alpha;
    %%%%%: 5669-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5669-block  1
branch  2 never executed
branch  3 never executed
        -: 5670:               // fallthrough
        -: 5671:      case 15: if(is_rgb16) *is_rgb16 = 1;
        -: 5672:               return STBI_rgb;
    #####: 5673:      case 24: // fallthrough
    #####: 5674:      case 32: return bits_per_pixel/8;
    %%%%%: 5674-block  0
    %%%%%: 5674-block  1
    %%%%%: 5674-block  2
    %%%%%: 5674-block  3
    #####: 5675:      default: return 0;
    %%%%%: 5675-block  0
    %%%%%: 5675-block  1
        -: 5676:   }
        -: 5677:}
        -: 5678:
function _ZL14stbi__tga_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 5679:static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
        -: 5680:{
        -: 5681:    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
        -: 5682:    int sz, tga_colormap_type;
    #####: 5683:    stbi__get8(s);                   // discard Offset
    %%%%%: 5683-block  0
call    0 never executed
    #####: 5684:    tga_colormap_type = stbi__get8(s); // colormap type
call    0 never executed
    #####: 5685:    if( tga_colormap_type > 1 ) {
branch  0 never executed
branch  1 never executed
        -: 5686:        stbi__rewind(s);
    #####: 5687:        return 0;      // only RGB or indexed allowed
    %%%%%: 5687-block  0
        -: 5688:    }
    #####: 5689:    tga_image_type = stbi__get8(s); // image type
    %%%%%: 5689-block  0
call    0 never executed
    #####: 5690:    if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
branch  0 never executed
branch  1 never executed
    #####: 5691:        if (tga_image_type != 1 && tga_image_type != 9) {
    %%%%%: 5691-block  0
branch  0 never executed
branch  1 never executed
        -: 5692:            stbi__rewind(s);
    #####: 5693:            return 0;
    %%%%%: 5693-block  0
        -: 5694:        }
        -: 5695:        stbi__skip(s,4);       // skip index of first colormap entry and number of entries
    #####: 5696:        sz = stbi__get8(s);    //   check bits per palette color entry
    %%%%%: 5696-block  0
call    0 never executed
    #####: 5697:        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
branch  0 never executed
branch  1 never executed
    %%%%%: 5697-block  0
branch  2 never executed
branch  3 never executed
    %%%%%: 5697-block  1
branch  4 never executed
branch  5 never executed
        -: 5698:            stbi__rewind(s);
    #####: 5699:            return 0;
    %%%%%: 5699-block  0
        -: 5700:        }
        -: 5701:        stbi__skip(s,4);       // skip image x and y origin
        -: 5702:        tga_colormap_bpp = sz;
        -: 5703:    } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
    #####: 5704:        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
    %%%%%: 5704-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5704-block  1
branch  2 never executed
branch  3 never executed
        -: 5705:            stbi__rewind(s);
    #####: 5706:            return 0; // only RGB or grey allowed, +/- RLE
    %%%%%: 5706-block  0
        -: 5707:        }
        -: 5708:        stbi__skip(s,9); // skip colormap specification and image x/y origin
        -: 5709:        tga_colormap_bpp = 0;
        -: 5710:    }
    #####: 5711:    tga_w = stbi__get16le(s);
    %%%%%: 5711-block  0
call    0 never executed
    #####: 5712:    if( tga_w < 1 ) {
branch  0 never executed
branch  1 never executed
        -: 5713:        stbi__rewind(s);
    #####: 5714:        return 0;   // test width
    %%%%%: 5714-block  0
        -: 5715:    }
    #####: 5716:    tga_h = stbi__get16le(s);
    %%%%%: 5716-block  0
call    0 never executed
    #####: 5717:    if( tga_h < 1 ) {
branch  0 never executed
branch  1 never executed
        -: 5718:        stbi__rewind(s);
    #####: 5719:        return 0;   // test height
    %%%%%: 5719-block  0
        -: 5720:    }
    #####: 5721:    tga_bits_per_pixel = stbi__get8(s); // bits per pixel
    %%%%%: 5721-block  0
call    0 never executed
    #####: 5722:    stbi__get8(s); // ignore alpha bits
call    0 never executed
    #####: 5723:    if (tga_colormap_bpp != 0) {
branch  0 never executed
branch  1 never executed
    #####: 5724:        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
    %%%%%: 5724-block  0
branch  0 never executed
branch  1 never executed
        -: 5725:            // when using a colormap, tga_bits_per_pixel is the size of the indexes
        -: 5726:            // I don't think anything but 8 or 16bit indexes makes sense
        -: 5727:            stbi__rewind(s);
    #####: 5728:            return 0;
    %%%%%: 5728-block  0
        -: 5729:        }
        -: 5730:        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
        -: 5731:    } else {
    #####: 5732:        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
    %%%%%: 5732-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 5733:    }
    #####: 5734:    if(!tga_comp) {
    %%%%%: 5734-block  0
branch  0 never executed
branch  1 never executed
        -: 5735:      stbi__rewind(s);
    #####: 5736:      return 0;
    %%%%%: 5736-block  0
        -: 5737:    }
    #####: 5738:    if (x) *x = tga_w;
    %%%%%: 5738-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5738-block  1
    #####: 5739:    if (y) *y = tga_h;
    %%%%%: 5739-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5739-block  1
    #####: 5740:    if (comp) *comp = tga_comp;
    %%%%%: 5740-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5740-block  1
        -: 5741:    return 1;                   // seems to have passed everything
        -: 5742:}
        -: 5743:
function _ZL14stbi__tga_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 5744:static int stbi__tga_test(stbi__context *s)
        -: 5745:{
        -: 5746:   int res = 0;
        -: 5747:   int sz, tga_color_type;
    #####: 5748:   stbi__get8(s);      //   discard Offset
    %%%%%: 5748-block  0
call    0 never executed
    #####: 5749:   tga_color_type = stbi__get8(s);   //   color type
call    0 never executed
    #####: 5750:   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
branch  0 never executed
branch  1 never executed
    %%%%%: 5750-block  0
    #####: 5751:   sz = stbi__get8(s);   //   image type
    %%%%%: 5751-block  0
call    0 never executed
    #####: 5752:   if ( tga_color_type == 1 ) { // colormapped (paletted) image
branch  0 never executed
branch  1 never executed
    #####: 5753:      if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
    %%%%%: 5753-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5753-block  1
        -: 5754:      stbi__skip(s,4);       // skip index of first colormap entry and number of entries
    #####: 5755:      sz = stbi__get8(s);    //   check bits per palette color entry
    %%%%%: 5755-block  0
call    0 never executed
    #####: 5756:      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
branch  0 never executed
branch  1 never executed
    %%%%%: 5756-block  0
branch  2 never executed
branch  3 never executed
    %%%%%: 5756-block  1
branch  4 never executed
branch  5 never executed
    %%%%%: 5756-block  2
        -: 5757:      stbi__skip(s,4);       // skip image x and y origin
        -: 5758:   } else { // "normal" image w/o colormap
    #####: 5759:      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
    %%%%%: 5759-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5759-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 5759-block  2
        -: 5760:      stbi__skip(s,9); // skip colormap specification and image x/y origin
        -: 5761:   }
    #####: 5762:   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
    %%%%%: 5762-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%: 5762-block  1
    #####: 5763:   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
    %%%%%: 5763-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%: 5763-block  1
    #####: 5764:   sz = stbi__get8(s);   //   bits per pixel
    %%%%%: 5764-block  0
call    0 never executed
    #####: 5765:   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bytes_per_pixel is size of an index
branch  0 never executed
branch  1 never executed
    %%%%%: 5765-block  0
branch  2 never executed
branch  3 never executed
    %%%%%: 5765-block  1
    #####: 5766:   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
    %%%%%: 5766-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5766-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 5766-block  2
branch  4 never executed
branch  5 never executed
    %%%%%: 5766-block  3
        -: 5767:
        -: 5768:   res = 1; // if we got this far, everything's good and we can return 1 instead of 0
        -: 5769:
    #####: 5770:errorEnd:
        -: 5771:   stbi__rewind(s);
    #####: 5772:   return res;
        -: 5773:}
        -: 5774:
        -: 5775:// read 16bit value and convert to 24bit RGB
function _ZL20stbi__tga_read_rgb16P13stbi__contextPh called 0 returned 0% blocks executed 0%
    #####: 5776:static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
        -: 5777:{
    #####: 5778:   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
    %%%%%: 5778-block  0
call    0 never executed
        -: 5779:   stbi__uint16 fiveBitMask = 31;
        -: 5780:   // we have 3 channels with 5bits each
    #####: 5781:   int r = (px >> 10) & fiveBitMask;
    #####: 5782:   int g = (px >> 5) & fiveBitMask;
    #####: 5783:   int b = px & fiveBitMask;
        -: 5784:   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
    #####: 5785:   out[0] = (stbi_uc)((r * 255)/31);
    #####: 5786:   out[1] = (stbi_uc)((g * 255)/31);
    #####: 5787:   out[2] = (stbi_uc)((b * 255)/31);
        -: 5788:
        -: 5789:   // some people claim that the most significant bit might be used for alpha
        -: 5790:   // (possibly if an alpha-bit is set in the "image descriptor byte")
        -: 5791:   // but that only made 16bit test images completely translucent..
        -: 5792:   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
    #####: 5793:}
        -: 5794:
function _ZL14stbi__tga_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 5795:static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 5796:{
        -: 5797:   //   read in the TGA header stuff
    #####: 5798:   int tga_offset = stbi__get8(s);
    %%%%%: 5798-block  0
call    0 never executed
    #####: 5799:   int tga_indexed = stbi__get8(s);
call    0 never executed
    #####: 5800:   int tga_image_type = stbi__get8(s);
call    0 never executed
        -: 5801:   int tga_is_RLE = 0;
    #####: 5802:   int tga_palette_start = stbi__get16le(s);
call    0 never executed
    #####: 5803:   int tga_palette_len = stbi__get16le(s);
call    0 never executed
    #####: 5804:   int tga_palette_bits = stbi__get8(s);
call    0 never executed
    #####: 5805:   int tga_x_origin = stbi__get16le(s);
call    0 never executed
    #####: 5806:   int tga_y_origin = stbi__get16le(s);
call    0 never executed
    #####: 5807:   int tga_width = stbi__get16le(s);
call    0 never executed
    #####: 5808:   int tga_height = stbi__get16le(s);
call    0 never executed
    #####: 5809:   int tga_bits_per_pixel = stbi__get8(s);
call    0 never executed
        -: 5810:   int tga_comp, tga_rgb16=0;
    #####: 5811:   int tga_inverted = stbi__get8(s);
call    0 never executed
        -: 5812:   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
        -: 5813:   //   image data
        -: 5814:   unsigned char *tga_data;
        -: 5815:   unsigned char *tga_palette = NULL;
        -: 5816:   int i, j;
    #####: 5817:   unsigned char raw_data[4] = {0};
        -: 5818:   int RLE_count = 0;
        -: 5819:   int RLE_repeating = 0;
        -: 5820:   int read_next_pixel = 1;
        -: 5821:   STBI_NOTUSED(ri);
        -: 5822:   STBI_NOTUSED(tga_x_origin); // @TODO
        -: 5823:   STBI_NOTUSED(tga_y_origin); // @TODO
        -: 5824:
    #####: 5825:   if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
branch  0 never executed
branch  1 never executed
    #####: 5826:   if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 5826-block  0
branch  0 never executed
branch  1 never executed
        -: 5827:
        -: 5828:   //   do a tiny bit of precessing
    #####: 5829:   if ( tga_image_type >= 8 )
    %%%%%: 5829-block  0
branch  0 never executed
branch  1 never executed
        -: 5830:   {
    #####: 5831:      tga_image_type -= 8;
    %%%%%: 5831-block  0
        -: 5832:      tga_is_RLE = 1;
        -: 5833:   }
        -: 5834:   tga_inverted = 1 - ((tga_inverted >> 5) & 1);
        -: 5835:
        -: 5836:   //   If I'm paletted, then I'll use the number of bits from the palette
    #####: 5837:   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
    %%%%%: 5837-block  0
branch  0 never executed
branch  1 never executed
        -: 5838:   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);
        -: 5839:
    #####: 5840:   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
    %%%%%: 5840-block  0
branch  0 never executed
branch  1 never executed
        -: 5841:      return stbi__errpuc("bad format", "Can't find out TGA pixelformat");
        -: 5842:
        -: 5843:   //   tga info
    #####: 5844:   *x = tga_width;
    #####: 5845:   *y = tga_height;
    #####: 5846:   if (comp) *comp = tga_comp;
    %%%%%: 5846-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5846-block  1
        -: 5847:
    #####: 5848:   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
    %%%%%: 5848-block  0
branch  0 never executed
branch  1 never executed
        -: 5849:      return stbi__errpuc("too large", "Corrupt TGA");
        -: 5850:
    #####: 5851:   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
    %%%%%: 5851-block  0
call    0 never executed
    #####: 5852:   if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");
branch  0 never executed
branch  1 never executed
        -: 5853:
        -: 5854:   // skip to the data's starting position (offset usually = 0)
    #####: 5855:   stbi__skip(s, tga_offset );
    %%%%%: 5855-block  0
call    0 never executed
        -: 5856:
    #####: 5857:   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
branch  0 never executed
branch  1 never executed
    %%%%%: 5857-block  0
branch  2 never executed
branch  3 never executed
    #####: 5858:      for (i=0; i < tga_height; ++i) {
    %%%%%: 5858-block  0
branch  0 never executed
branch  1 never executed
    #####: 5859:         int row = tga_inverted ? tga_height -i - 1 : i;
    %%%%%: 5859-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5859-block  1
    #####: 5860:         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
    #####: 5861:         stbi__getn(s, tga_row, tga_width * tga_comp);
    %%%%%: 5861-block  0
call    0 never executed
        -: 5862:      }
        -: 5863:   } else  {
        -: 5864:      //   do I need to load a palette?
    #####: 5865:      if ( tga_indexed)
    %%%%%: 5865-block  0
branch  0 never executed
branch  1 never executed
        -: 5866:      {
    #####: 5867:         if (tga_palette_len == 0) {  /* you have to have at least one entry! */
    %%%%%: 5867-block  0
branch  0 never executed
branch  1 never executed
    #####: 5868:            STBI_FREE(tga_data);
    #####: 5869:            return stbi__errpuc("bad palette", "Corrupt TGA");
    %%%%%: 5869-block  0
        -: 5870:         }
        -: 5871:
        -: 5872:         //   any data to skip? (offset usually = 0)
    #####: 5873:         stbi__skip(s, tga_palette_start );
    %%%%%: 5873-block  0
call    0 never executed
        -: 5874:         //   load the palette
    #####: 5875:         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
call    0 never executed
    #####: 5876:         if (!tga_palette) {
branch  0 never executed
branch  1 never executed
    #####: 5877:            STBI_FREE(tga_data);
    #####: 5878:            return stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 5878-block  0
        -: 5879:         }
    #####: 5880:         if (tga_rgb16) {
    %%%%%: 5880-block  0
branch  0 never executed
branch  1 never executed
        -: 5881:            stbi_uc *pal_entry = tga_palette;
    #####: 5882:            STBI_ASSERT(tga_comp == STBI_rgb);
    %%%%%: 5882-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5882-block  1
call    2 never executed
    #####: 5883:            for (i=0; i < tga_palette_len; ++i) {
    %%%%%: 5883-block  0
branch  0 never executed
branch  1 never executed
    #####: 5884:               stbi__tga_read_rgb16(s, pal_entry);
    %%%%%: 5884-block  0
call    0 never executed
    #####: 5885:               pal_entry += tga_comp;
        -: 5886:            }
    #####: 5887:         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
    %%%%%: 5887-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5888:               STBI_FREE(tga_data);
    #####: 5889:               STBI_FREE(tga_palette);
    #####: 5890:               return stbi__errpuc("bad palette", "Corrupt TGA");
    %%%%%: 5890-block  0
        -: 5891:         }
        -: 5892:      }
        -: 5893:      //   load the data
    #####: 5894:      for (i=0; i < tga_width * tga_height; ++i)
    %%%%%: 5894-block  0
branch  0 never executed
branch  1 never executed
        -: 5895:      {
        -: 5896:         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
    #####: 5897:         if ( tga_is_RLE )
    %%%%%: 5897-block  0
branch  0 never executed
branch  1 never executed
        -: 5898:         {
    #####: 5899:            if ( RLE_count == 0 )
    %%%%%: 5899-block  0
branch  0 never executed
branch  1 never executed
        -: 5900:            {
        -: 5901:               //   yep, get the next byte as a RLE command
    #####: 5902:               int RLE_cmd = stbi__get8(s);
    %%%%%: 5902-block  0
call    0 never executed
    #####: 5903:               RLE_count = 1 + (RLE_cmd & 127);
    #####: 5904:               RLE_repeating = RLE_cmd >> 7;
        -: 5905:               read_next_pixel = 1;
    #####: 5906:            } else if ( !RLE_repeating )
    %%%%%: 5906-block  0
branch  0 never executed
branch  1 never executed
        -: 5907:            {
        -: 5908:               read_next_pixel = 1;
        -: 5909:            }
        -: 5910:         } else
        -: 5911:         {
        -: 5912:            read_next_pixel = 1;
        -: 5913:         }
        -: 5914:         //   OK, if I need to read a pixel, do it now
    #####: 5915:         if ( read_next_pixel )
    %%%%%: 5915-block  0
branch  0 never executed
branch  1 never executed
        -: 5916:         {
        -: 5917:            //   load however much data we did have
    #####: 5918:            if ( tga_indexed )
    %%%%%: 5918-block  0
branch  0 never executed
branch  1 never executed
        -: 5919:            {
        -: 5920:               // read in index, then perform the lookup
    #####: 5921:               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
    %%%%%: 5921-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5921-block  1
call    2 never executed
    %%%%%: 5921-block  2
call    3 never executed
    #####: 5922:               if ( pal_idx >= tga_palette_len ) {
    %%%%%: 5922-block  0
branch  0 never executed
branch  1 never executed
        -: 5923:                  // invalid index
        -: 5924:                  pal_idx = 0;
        -: 5925:               }
    #####: 5926:               pal_idx *= tga_comp;
    %%%%%: 5926-block  0
    #####: 5927:               for (j = 0; j < tga_comp; ++j) {
    %%%%%: 5927-block  0
branch  0 never executed
branch  1 never executed
    #####: 5928:                  raw_data[j] = tga_palette[pal_idx+j];
    %%%%%: 5928-block  0
        -: 5929:               }
    #####: 5930:            } else if(tga_rgb16) {
    %%%%%: 5930-block  0
branch  0 never executed
branch  1 never executed
    #####: 5931:               STBI_ASSERT(tga_comp == STBI_rgb);
    %%%%%: 5931-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5931-block  1
call    2 never executed
    #####: 5932:               stbi__tga_read_rgb16(s, raw_data);
    %%%%%: 5932-block  0
call    0 never executed
        -: 5933:            } else {
        -: 5934:               //   read in the data raw
    #####: 5935:               for (j = 0; j < tga_comp; ++j) {
    %%%%%: 5935-block  0
branch  0 never executed
branch  1 never executed
    #####: 5936:                  raw_data[j] = stbi__get8(s);
    %%%%%: 5936-block  0
call    0 never executed
        -: 5937:               }
        -: 5938:            }
        -: 5939:            //   clear the reading flag for the next pixel
        -: 5940:            read_next_pixel = 0;
        -: 5941:         } // end of reading a pixel
        -: 5942:
        -: 5943:         // copy data
    #####: 5944:         for (j = 0; j < tga_comp; ++j)
    %%%%%: 5944-block  0
branch  0 never executed
branch  1 never executed
    #####: 5945:           tga_data[i*tga_comp+j] = raw_data[j];
    %%%%%: 5945-block  0
        -: 5946:
        -: 5947:         //   in case we're in RLE mode, keep counting down
    #####: 5948:         --RLE_count;
    %%%%%: 5948-block  0
        -: 5949:      }
        -: 5950:      //   do I need to invert the image?
    #####: 5951:      if ( tga_inverted )
    %%%%%: 5951-block  0
branch  0 never executed
branch  1 never executed
        -: 5952:      {
    #####: 5953:         for (j = 0; j*2 < tga_height; ++j)
    %%%%%: 5953-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5953-block  1
        -: 5954:         {
    #####: 5955:            int index1 = j * tga_width * tga_comp;
    #####: 5956:            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
    #####: 5957:            for (i = tga_width * tga_comp; i > 0; --i)
    %%%%%: 5957-block  0
    %%%%%: 5957-block  1
branch  0 never executed
branch  1 never executed
        -: 5958:            {
    #####: 5959:               unsigned char temp = tga_data[index1];
    #####: 5960:               tga_data[index1] = tga_data[index2];
    #####: 5961:               tga_data[index2] = temp;
    #####: 5962:               ++index1;
    #####: 5963:               ++index2;
    %%%%%: 5963-block  0
        -: 5964:            }
        -: 5965:         }
        -: 5966:      }
        -: 5967:      //   clear my palette, if I had one
    #####: 5968:      if ( tga_palette != NULL )
    %%%%%: 5968-block  0
branch  0 never executed
branch  1 never executed
        -: 5969:      {
    #####: 5970:         STBI_FREE( tga_palette );
    %%%%%: 5970-block  0
        -: 5971:      }
        -: 5972:   }
        -: 5973:
        -: 5974:   // swap RGB - if the source data was RGB16, it already is in the right order
    #####: 5975:   if (tga_comp >= 3 && !tga_rgb16)
    %%%%%: 5975-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 5975-block  1
branch  2 never executed
branch  3 never executed
        -: 5976:   {
        -: 5977:      unsigned char* tga_pixel = tga_data;
    #####: 5978:      for (i=0; i < tga_width * tga_height; ++i)
    %%%%%: 5978-block  0
branch  0 never executed
branch  1 never executed
        -: 5979:      {
    #####: 5980:         unsigned char temp = tga_pixel[0];
    #####: 5981:         tga_pixel[0] = tga_pixel[2];
    #####: 5982:         tga_pixel[2] = temp;
    #####: 5983:         tga_pixel += tga_comp;
    %%%%%: 5983-block  0
        -: 5984:      }
        -: 5985:   }
        -: 5986:
        -: 5987:   // convert to target component count
    #####: 5988:   if (req_comp && req_comp != tga_comp)
    %%%%%: 5988-block  0
branch  0 never executed
branch  1 never executed
    #####: 5989:      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);
    %%%%%: 5989-block  0
call    0 never executed
        -: 5990:
        -: 5991:   //   the things I do to get rid of an error message, and yet keep
        -: 5992:   //   Microsoft's C compilers happy... [8^(
        -: 5993:   tga_palette_start = tga_palette_len = tga_palette_bits =
        -: 5994:         tga_x_origin = tga_y_origin = 0;
        -: 5995:   STBI_NOTUSED(tga_palette_start);
        -: 5996:   //   OK, done
        -: 5997:   return tga_data;
        -: 5998:}
        -: 5999:#endif
        -: 6000:
        -: 6001:// *************************************************************************************************
        -: 6002:// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB
        -: 6003:
        -: 6004:#ifndef STBI_NO_PSD
        -: 6005:static int stbi__psd_test(stbi__context *s)
        -: 6006:{
    #####: 6007:   int r = (stbi__get32be(s) == 0x38425053);
    %%%%%: 6007-block  0
call    0 never executed
        -: 6008:   stbi__rewind(s);
        -: 6009:   return r;
        -: 6010:}
        -: 6011:
function _ZL20stbi__psd_decode_rleP13stbi__contextPhi called 0 returned 0% blocks executed 0%
    #####: 6012:static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
    %%%%%: 6012-block  0
        -: 6013:{
        -: 6014:   int count, nleft, len;
        -: 6015:
        -: 6016:   count = 0;
    #####: 6017:   while ((nleft = pixelCount - count) > 0) {
    %%%%%: 6017-block  0
branch  0 never executed
branch  1 never executed
    #####: 6018:      len = stbi__get8(s);
    %%%%%: 6018-block  0
call    0 never executed
    #####: 6019:      if (len == 128) {
branch  0 never executed
branch  1 never executed
        -: 6020:         // No-op.
    #####: 6021:      } else if (len < 128) {
    %%%%%: 6021-block  0
branch  0 never executed
branch  1 never executed
        -: 6022:         // Copy next len+1 bytes literally.
    #####: 6023:         len++;
    #####: 6024:         if (len > nleft) return 0; // corrupt data
    %%%%%: 6024-block  0
branch  0 never executed
branch  1 never executed
    #####: 6025:         count += len;
    %%%%%: 6025-block  0
    #####: 6026:         while (len) {
    %%%%%: 6026-block  0
branch  0 never executed
branch  1 never executed
    #####: 6027:            *p = stbi__get8(s);
    %%%%%: 6027-block  0
call    0 never executed
    #####: 6028:            p += 4;
    #####: 6029:            len--;
        -: 6030:         }
    #####: 6031:      } else if (len > 128) {
    %%%%%: 6031-block  0
branch  0 never executed
branch  1 never executed
        -: 6032:         stbi_uc   val;
        -: 6033:         // Next -len+1 bytes in the dest are replicated from next source byte.
        -: 6034:         // (Interpret len as a negative 8-bit int.)
    #####: 6035:         len = 257 - len;
    #####: 6036:         if (len > nleft) return 0; // corrupt data
    %%%%%: 6036-block  0
branch  0 never executed
branch  1 never executed
    #####: 6037:         val = stbi__get8(s);
    %%%%%: 6037-block  0
call    0 never executed
    #####: 6038:         count += len;
    #####: 6039:         while (len) {
    %%%%%: 6039-block  0
branch  0 never executed
branch  1 never executed
    #####: 6040:            *p = val;
    #####: 6041:            p += 4;
    #####: 6042:            len--;
    %%%%%: 6042-block  0
        -: 6043:         }
        -: 6044:      }
        -: 6045:   }
        -: 6046:
        -: 6047:   return 1;
        -: 6048:}
        -: 6049:
function _ZL14stbi__psd_loadP13stbi__contextPiS1_S1_iP17stbi__result_infoi called 0 returned 0% blocks executed 0%
    #####: 6050:static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
        -: 6051:{
        -: 6052:   int pixelCount;
        -: 6053:   int channelCount, compression;
        -: 6054:   int channel, i;
        -: 6055:   int bitdepth;
        -: 6056:   int w,h;
        -: 6057:   stbi_uc *out;
        -: 6058:   STBI_NOTUSED(ri);
        -: 6059:
        -: 6060:   // Check identifier
    #####: 6061:   if (stbi__get32be(s) != 0x38425053)   // "8BPS"
    %%%%%: 6061-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 6062:      return stbi__errpuc("not PSD", "Corrupt PSD image");
        -: 6063:
        -: 6064:   // Check file type version.
    #####: 6065:   if (stbi__get16be(s) != 1)
    %%%%%: 6065-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 6066:      return stbi__errpuc("wrong version", "Unsupported version of PSD image");
        -: 6067:
        -: 6068:   // Skip 6 reserved bytes.
        -: 6069:   stbi__skip(s, 6 );
        -: 6070:
        -: 6071:   // Read the number of channels (R, G, B, A, etc).
    #####: 6072:   channelCount = stbi__get16be(s);
    %%%%%: 6072-block  0
call    0 never executed
    #####: 6073:   if (channelCount < 0 || channelCount > 16)
branch  0 never executed
branch  1 never executed
        -: 6074:      return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");
        -: 6075:
        -: 6076:   // Read the rows and columns of the image.
    #####: 6077:   h = stbi__get32be(s);
    %%%%%: 6077-block  0
call    0 never executed
    #####: 6078:   w = stbi__get32be(s);
call    0 never executed
        -: 6079:
    #####: 6080:   if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
branch  0 never executed
branch  1 never executed
    #####: 6081:   if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 6081-block  0
branch  0 never executed
branch  1 never executed
        -: 6082:
        -: 6083:   // Make sure the depth is 8 bits.
    #####: 6084:   bitdepth = stbi__get16be(s);
    %%%%%: 6084-block  0
call    0 never executed
    #####: 6085:   if (bitdepth != 8 && bitdepth != 16)
branch  0 never executed
branch  1 never executed
        -: 6086:      return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");
        -: 6087:
        -: 6088:   // Make sure the color mode is RGB.
        -: 6089:   // Valid options are:
        -: 6090:   //   0: Bitmap
        -: 6091:   //   1: Grayscale
        -: 6092:   //   2: Indexed color
        -: 6093:   //   3: RGB color
        -: 6094:   //   4: CMYK color
        -: 6095:   //   7: Multichannel
        -: 6096:   //   8: Duotone
        -: 6097:   //   9: Lab color
    #####: 6098:   if (stbi__get16be(s) != 3)
    %%%%%: 6098-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 6099:      return stbi__errpuc("wrong color format", "PSD is not in RGB color format");
        -: 6100:
        -: 6101:   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
    #####: 6102:   stbi__skip(s,stbi__get32be(s) );
    %%%%%: 6102-block  0
call    0 never executed
call    1 never executed
        -: 6103:
        -: 6104:   // Skip the image resources.  (resolution, pen tool paths, etc)
    #####: 6105:   stbi__skip(s, stbi__get32be(s) );
call    0 never executed
call    1 never executed
        -: 6106:
        -: 6107:   // Skip the reserved data.
    #####: 6108:   stbi__skip(s, stbi__get32be(s) );
call    0 never executed
call    1 never executed
        -: 6109:
        -: 6110:   // Find out if the data is compressed.
        -: 6111:   // Known values:
        -: 6112:   //   0: no compression
        -: 6113:   //   1: RLE compressed
    #####: 6114:   compression = stbi__get16be(s);
call    0 never executed
    #####: 6115:   if (compression > 1)
branch  0 never executed
branch  1 never executed
        -: 6116:      return stbi__errpuc("bad compression", "PSD has an unknown compression format");
        -: 6117:
        -: 6118:   // Check size
    #####: 6119:   if (!stbi__mad3sizes_valid(4, w, h, 0))
    %%%%%: 6119-block  0
branch  0 never executed
branch  1 never executed
        -: 6120:      return stbi__errpuc("too large", "Corrupt PSD");
        -: 6121:
        -: 6122:   // Create the destination image.
        -: 6123:
    #####: 6124:   if (!compression && bitdepth == 16 && bpc == 16) {
    %%%%%: 6124-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6124-block  1
branch  2 never executed
branch  3 never executed
    #####: 6125:      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
    %%%%%: 6125-block  0
call    0 never executed
    #####: 6126:      ri->bits_per_channel = 16;
        -: 6127:   } else
    #####: 6128:      out = (stbi_uc *) stbi__malloc(4 * w*h);
    %%%%%: 6128-block  0
        -: 6129:
    #####: 6130:   if (!out) return stbi__errpuc("outofmem", "Out of memory");
    %%%%%: 6130-block  0
branch  0 never executed
branch  1 never executed
    #####: 6131:   pixelCount = w*h;
        -: 6132:
        -: 6133:   // Initialize the data to zero.
        -: 6134:   //memset( out, 0, pixelCount * 4 );
        -: 6135:
        -: 6136:   // Finally, the image data.
    #####: 6137:   if (compression) {
    %%%%%: 6137-block  0
branch  0 never executed
branch  1 never executed
        -: 6138:      // RLE as used by .PSD and .TIFF
        -: 6139:      // Loop until you get the number of unpacked bytes you are expecting:
        -: 6140:      //     Read the next source byte into n.
        -: 6141:      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
        -: 6142:      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
        -: 6143:      //     Else if n is 128, noop.
        -: 6144:      // Endloop
        -: 6145:
        -: 6146:      // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
        -: 6147:      // which we're going to just skip.
    #####: 6148:      stbi__skip(s, h * channelCount * 2 );
    %%%%%: 6148-block  0
call    0 never executed
        -: 6149:
        -: 6150:      // Read the RLE data by channel.
    #####: 6151:      for (channel = 0; channel < 4; channel++) {
    %%%%%: 6151-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6151-block  1
        -: 6152:         stbi_uc *p;
        -: 6153:
    #####: 6154:         p = out+channel;
    #####: 6155:         if (channel >= channelCount) {
    %%%%%: 6155-block  0
branch  0 never executed
branch  1 never executed
        -: 6156:            // Fill this channel with default data.
    #####: 6157:            for (i = 0; i < pixelCount; i++, p += 4)
    %%%%%: 6157-block  0
branch  0 never executed
branch  1 never executed
    #####: 6158:               *p = (channel == 3 ? 255 : 0);
    %%%%%: 6158-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6158-block  1
        -: 6159:         } else {
        -: 6160:            // Read the RLE data.
    #####: 6161:            if (!stbi__psd_decode_rle(s, p, pixelCount)) {
    %%%%%: 6161-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6162:               STBI_FREE(out);
    #####: 6163:               return stbi__errpuc("corrupt", "bad RLE data");
    %%%%%: 6163-block  0
        -: 6164:            }
        -: 6165:         }
        -: 6166:      }
        -: 6167:
        -: 6168:   } else {
        -: 6169:      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
        -: 6170:      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.
        -: 6171:
        -: 6172:      // Read the data by channel.
    #####: 6173:      for (channel = 0; channel < 4; channel++) {
    %%%%%: 6173-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6173-block  1
    #####: 6174:         if (channel >= channelCount) {
    %%%%%: 6174-block  0
branch  0 never executed
branch  1 never executed
        -: 6175:            // Fill this channel with default data.
    #####: 6176:            if (bitdepth == 16 && bpc == 16) {
    %%%%%: 6176-block  0
branch  0 never executed
branch  1 never executed
    #####: 6177:               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
    #####: 6178:               stbi__uint16 val = channel == 3 ? 65535 : 0;
    %%%%%: 6178-block  0
branch  0 never executed
branch  1 never executed
    #####: 6179:               for (i = 0; i < pixelCount; i++, q += 4)
    %%%%%: 6179-block  0
branch  0 never executed
branch  1 never executed
    #####: 6180:                  *q = val;
    %%%%%: 6180-block  0
        -: 6181:            } else {
    #####: 6182:               stbi_uc *p = out+channel;
    #####: 6183:               stbi_uc val = channel == 3 ? 255 : 0;
    %%%%%: 6183-block  0
branch  0 never executed
branch  1 never executed
    #####: 6184:               for (i = 0; i < pixelCount; i++, p += 4)
    %%%%%: 6184-block  0
branch  0 never executed
branch  1 never executed
    #####: 6185:                  *p = val;
    %%%%%: 6185-block  0
        -: 6186:            }
        -: 6187:         } else {
    #####: 6188:            if (ri->bits_per_channel == 16) {    // output bpc
    %%%%%: 6188-block  0
branch  0 never executed
branch  1 never executed
    #####: 6189:               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
    %%%%%: 6189-block  0
    #####: 6190:               for (i = 0; i < pixelCount; i++, q += 4)
    %%%%%: 6190-block  0
branch  0 never executed
branch  1 never executed
    #####: 6191:                  *q = (stbi__uint16) stbi__get16be(s);
    %%%%%: 6191-block  0
call    0 never executed
        -: 6192:            } else {
    #####: 6193:               stbi_uc *p = out+channel;
    #####: 6194:               if (bitdepth == 16) {  // input bpc
    %%%%%: 6194-block  0
branch  0 never executed
branch  1 never executed
    #####: 6195:                  for (i = 0; i < pixelCount; i++, p += 4)
    %%%%%: 6195-block  0
branch  0 never executed
branch  1 never executed
    #####: 6196:                     *p = (stbi_uc) (stbi__get16be(s) >> 8);
    %%%%%: 6196-block  0
call    0 never executed
        -: 6197:               } else {
    #####: 6198:                  for (i = 0; i < pixelCount; i++, p += 4)
    %%%%%: 6198-block  0
branch  0 never executed
branch  1 never executed
    #####: 6199:                     *p = stbi__get8(s);
    %%%%%: 6199-block  0
call    0 never executed
        -: 6200:               }
        -: 6201:            }
        -: 6202:         }
        -: 6203:      }
        -: 6204:   }
        -: 6205:
        -: 6206:   // remove weird white matte from PSD
    #####: 6207:   if (channelCount >= 4) {
    %%%%%: 6207-block  0
branch  0 never executed
branch  1 never executed
    #####: 6208:      if (ri->bits_per_channel == 16) {
    %%%%%: 6208-block  0
branch  0 never executed
branch  1 never executed
    #####: 6209:         for (i=0; i < w*h; ++i) {
    %%%%%: 6209-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6209-block  1
    #####: 6210:            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
    #####: 6211:            if (pixel[3] != 0 && pixel[3] != 65535) {
    %%%%%: 6211-block  0
branch  0 never executed
branch  1 never executed
    #####: 6212:               float a = pixel[3] / 65535.0f;
    #####: 6213:               float ra = 1.0f / a;
    #####: 6214:               float inv_a = 65535.0f * (1 - ra);
    #####: 6215:               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
    #####: 6216:               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
    #####: 6217:               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
    %%%%%: 6217-block  0
        -: 6218:            }
        -: 6219:         }
        -: 6220:      } else {
    #####: 6221:         for (i=0; i < w*h; ++i) {
    %%%%%: 6221-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6221-block  1
    #####: 6222:            unsigned char *pixel = out + 4*i;
    #####: 6223:            if (pixel[3] != 0 && pixel[3] != 255) {
    %%%%%: 6223-block  0
branch  0 never executed
branch  1 never executed
    #####: 6224:               float a = pixel[3] / 255.0f;
    #####: 6225:               float ra = 1.0f / a;
    #####: 6226:               float inv_a = 255.0f * (1 - ra);
    #####: 6227:               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
    #####: 6228:               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
    #####: 6229:               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
    %%%%%: 6229-block  0
        -: 6230:            }
        -: 6231:         }
        -: 6232:      }
        -: 6233:   }
        -: 6234:
        -: 6235:   // convert to desired output format
    #####: 6236:   if (req_comp && req_comp != 4) {
    %%%%%: 6236-block  0
branch  0 never executed
branch  1 never executed
    #####: 6237:      if (ri->bits_per_channel == 16)
    %%%%%: 6237-block  0
branch  0 never executed
branch  1 never executed
    #####: 6238:         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
    %%%%%: 6238-block  0
call    0 never executed
        -: 6239:      else
    #####: 6240:         out = stbi__convert_format(out, 4, req_comp, w, h);
    %%%%%: 6240-block  0
call    0 never executed
    #####: 6241:      if (out == NULL) return out; // stbi__convert_format frees input on failure
    %%%%%: 6241-block  0
branch  0 never executed
branch  1 never executed
        -: 6242:   }
        -: 6243:
    #####: 6244:   if (comp) *comp = 4;
    %%%%%: 6244-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6244-block  1
    #####: 6245:   *y = h;
    #####: 6246:   *x = w;
        -: 6247:
    #####: 6248:   return out;
    %%%%%: 6248-block  0
        -: 6249:}
        -: 6250:#endif
        -: 6251:
        -: 6252:// *************************************************************************************************
        -: 6253:// Softimage PIC loader
        -: 6254:// by Tom Seddon
        -: 6255://
        -: 6256:// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
        -: 6257:// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/
        -: 6258:
        -: 6259:#ifndef STBI_NO_PIC
        -: 6260:static int stbi__pic_is4(stbi__context *s,const char *str)
        -: 6261:{
        -: 6262:   int i;
    #####: 6263:   for (i=0; i<4; ++i)
    %%%%%: 6263-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6263-block  1
    %%%%%: 6263-block  2
branch  2 never executed
branch  3 never executed
    %%%%%: 6263-block  3
    %%%%%: 6263-block  4
branch  4 never executed
branch  5 never executed
    %%%%%: 6263-block  5
    #####: 6264:      if (stbi__get8(s) != (stbi_uc)str[i])
    %%%%%: 6264-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%: 6264-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    %%%%%: 6264-block  2
call    6 never executed
branch  7 never executed
branch  8 never executed
        -: 6265:         return 0;
        -: 6266:
        -: 6267:   return 1;
        -: 6268:}
        -: 6269:
function _ZL19stbi__pic_test_coreP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 6270:static int stbi__pic_test_core(stbi__context *s)
    %%%%%: 6270-block  0
        -: 6271:{
        -: 6272:   int i;
        -: 6273:
    #####: 6274:   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
    %%%%%: 6274-block  0
branch  0 never executed
branch  1 never executed
        -: 6275:      return 0;
        -: 6276:
    #####: 6277:   for(i=0;i<84;++i)
    %%%%%: 6277-block  0
branch  0 never executed
branch  1 never executed
    #####: 6278:      stbi__get8(s);
    %%%%%: 6278-block  0
call    0 never executed
        -: 6279:
        -: 6280:   if (!stbi__pic_is4(s,"PICT"))
        -: 6281:      return 0;
        -: 6282:
        -: 6283:   return 1;
        -: 6284:}
        -: 6285:
        -: 6286:typedef struct
        -: 6287:{
        -: 6288:   stbi_uc size,type,channel;
        -: 6289:} stbi__pic_packet;
        -: 6290:
function _ZL13stbi__readvalP13stbi__contextiPh called 0 returned 0% blocks executed 0%
    #####: 6291:static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
    %%%%%: 6291-block  0
        -: 6292:{
        -: 6293:   int mask=0x80, i;
        -: 6294:
    #####: 6295:   for (i=0; i<4; ++i, mask>>=1) {
    %%%%%: 6295-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6295-block  1
    #####: 6296:      if (channel & mask) {
    %%%%%: 6296-block  0
branch  0 never executed
branch  1 never executed
    #####: 6297:         if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
    %%%%%: 6297-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6297-block  1
    #####: 6298:         dest[i]=stbi__get8(s);
    %%%%%: 6298-block  0
call    0 never executed
        -: 6299:      }
        -: 6300:   }
        -: 6301:
        -: 6302:   return dest;
        -: 6303:}
        -: 6304:
        -: 6305:static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
        -: 6306:{
        -: 6307:   int mask=0x80,i;
        -: 6308:
    #####: 6309:   for (i=0;i<4; ++i, mask>>=1)
    %%%%%: 6309-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6309-block  1
    %%%%%: 6309-block  2
branch  2 never executed
branch  3 never executed
    %%%%%: 6309-block  3
    #####: 6310:      if (channel&mask)
    %%%%%: 6310-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6310-block  1
branch  2 never executed
branch  3 never executed
    #####: 6311:         dest[i]=src[i];
    %%%%%: 6311-block  0
    %%%%%: 6311-block  1
        -: 6312:}
        -: 6313:
function _ZL19stbi__pic_load_coreP13stbi__contextiiPiPh called 0 returned 0% blocks executed 0%
    #####: 6314:static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
    %%%%%: 6314-block  0
        -: 6315:{
        -: 6316:   int act_comp=0,num_packets=0,y,chained;
        -: 6317:   stbi__pic_packet packets[10];
        -: 6318:
        -: 6319:   // this will (should...) cater for even some bizarre stuff like having data
        -: 6320:    // for the same channel in multiple packets.
        -: 6321:   do {
        -: 6322:      stbi__pic_packet *packet;
        -: 6323:
    #####: 6324:      if (num_packets==sizeof(packets)/sizeof(packets[0]))
    %%%%%: 6324-block  0
branch  0 never executed
branch  1 never executed
        -: 6325:         return stbi__errpuc("bad format","too many packets");
        -: 6326:
    #####: 6327:      packet = &packets[num_packets++];
        -: 6328:
    #####: 6329:      chained = stbi__get8(s);
    %%%%%: 6329-block  0
call    0 never executed
    #####: 6330:      packet->size    = stbi__get8(s);
call    0 never executed
    #####: 6331:      packet->type    = stbi__get8(s);
call    0 never executed
    #####: 6332:      packet->channel = stbi__get8(s);
call    0 never executed
        -: 6333:
    #####: 6334:      act_comp |= packet->channel;
branch  0 never executed
branch  1 never executed
        -: 6335:
    #####: 6336:      if (stbi__at_eof(s))          return stbi__errpuc("bad file","file too short (reading packets)");
    %%%%%: 6336-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6336-block  1
    #####: 6337:      if (packet->size != 8)  return stbi__errpuc("bad format","packet isn't 8bpp");
    %%%%%: 6337-block  0
branch  0 never executed
branch  1 never executed
    #####: 6338:   } while (chained);
    %%%%%: 6338-block  0
branch  0 never executed
branch  1 never executed
        -: 6339:
    #####: 6340:   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?
    %%%%%: 6340-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6340-block  1
        -: 6341:
    #####: 6342:   for(y=0; y<height; ++y) {
    %%%%%: 6342-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6342-block  1
        -: 6343:      int packet_idx;
        -: 6344:
    #####: 6345:      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
    %%%%%: 6345-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6345-block  1
        -: 6346:         stbi__pic_packet *packet = &packets[packet_idx];
    #####: 6347:         stbi_uc *dest = result+y*width*4;
        -: 6348:
    #####: 6349:         switch (packet->type) {
    %%%%%: 6349-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6350:            default:
        -: 6351:               return stbi__errpuc("bad format","packet has bad compression type");
        -: 6352:
        -: 6353:            case 0: {//uncompressed
        -: 6354:               int x;
        -: 6355:
    #####: 6356:               for(x=0;x<width;++x, dest+=4)
    %%%%%: 6356-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6356-block  1
    #####: 6357:                  if (!stbi__readval(s,packet->channel,dest))
    %%%%%: 6357-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 6358:                     return 0;
        -: 6359:               break;
        -: 6360:            }
        -: 6361:
        -: 6362:            case 1://Pure RLE
        -: 6363:               {
        -: 6364:                  int left=width, i;
        -: 6365:
    #####: 6366:                  while (left>0) {
    %%%%%: 6366-block  0
branch  0 never executed
branch  1 never executed
        -: 6367:                     stbi_uc count,value[4];
        -: 6368:
    #####: 6369:                     count=stbi__get8(s);
    %%%%%: 6369-block  0
call    0 never executed
    #####: 6370:                     if (stbi__at_eof(s))   return stbi__errpuc("bad file","file too short (pure read count)");
    %%%%%: 6370-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6370-block  1
    %%%%%: 6370-block  2
        -: 6371:
    #####: 6372:                     if (count > left)
    %%%%%: 6372-block  0
branch  0 never executed
branch  1 never executed
    #####: 6373:                        count = (stbi_uc) left;
    %%%%%: 6373-block  0
        -: 6374:
    #####: 6375:                     if (!stbi__readval(s,packet->channel,value))  return 0;
    %%%%%: 6375-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 6376:
    #####: 6377:                     for(i=0; i<count; ++i,dest+=4)
    %%%%%: 6377-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6377-block  1
        -: 6378:                        stbi__copyval(packet->channel,dest,value);
    #####: 6379:                     left -= count;
    %%%%%: 6379-block  0
        -: 6380:                  }
        -: 6381:               }
        -: 6382:               break;
        -: 6383:
        -: 6384:            case 2: {//Mixed RLE
        -: 6385:               int left=width;
    #####: 6386:               while (left>0) {
    %%%%%: 6386-block  0
branch  0 never executed
branch  1 never executed
    #####: 6387:                  int count = stbi__get8(s), i;
    %%%%%: 6387-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6388:                  if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");
    %%%%%: 6388-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6388-block  1
        -: 6389:
    #####: 6390:                  if (count >= 128) { // Repeated
    %%%%%: 6390-block  0
branch  0 never executed
branch  1 never executed
        -: 6391:                     stbi_uc value[4];
        -: 6392:
    #####: 6393:                     if (count==128)
    %%%%%: 6393-block  0
branch  0 never executed
branch  1 never executed
    #####: 6394:                        count = stbi__get16be(s);
    %%%%%: 6394-block  0
call    0 never executed
        -: 6395:                     else
    #####: 6396:                        count -= 127;
    %%%%%: 6396-block  0
    #####: 6397:                     if (count > left)
    %%%%%: 6397-block  0
branch  0 never executed
branch  1 never executed
    #####: 6398:                        return stbi__errpuc("bad file","scanline overrun");
    %%%%%: 6398-block  0
        -: 6399:
    #####: 6400:                     if (!stbi__readval(s,packet->channel,value))
    %%%%%: 6400-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 6401:                        return 0;
        -: 6402:
    #####: 6403:                     for(i=0;i<count;++i, dest += 4)
    %%%%%: 6403-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6403-block  1
        -: 6404:                        stbi__copyval(packet->channel,dest,value);
        -: 6405:                  } else { // Raw
    #####: 6406:                     ++count;
    #####: 6407:                     if (count>left) return stbi__errpuc("bad file","scanline overrun");
    %%%%%: 6407-block  0
branch  0 never executed
branch  1 never executed
        -: 6408:
    #####: 6409:                     for(i=0;i<count;++i, dest+=4)
    %%%%%: 6409-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6409-block  1
    #####: 6410:                        if (!stbi__readval(s,packet->channel,dest))
    %%%%%: 6410-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 6411:                           return 0;
        -: 6412:                  }
    #####: 6413:                  left-=count;
    %%%%%: 6413-block  0
        -: 6414:               }
        -: 6415:               break;
        -: 6416:            }
        -: 6417:         }
        -: 6418:      }
        -: 6419:   }
        -: 6420:
        -: 6421:   return result;
        -: 6422:}
        -: 6423:
function _ZL14stbi__pic_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 6424:static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)
        -: 6425:{
        -: 6426:   stbi_uc *result;
        -: 6427:   int i, x,y, internal_comp;
        -: 6428:   STBI_NOTUSED(ri);
        -: 6429:
    #####: 6430:   if (!comp) comp = &internal_comp;
    %%%%%: 6430-block  0
branch  0 never executed
branch  1 never executed
        -: 6431:
    #####: 6432:   for (i=0; i<92; ++i)
    %%%%%: 6432-block  0
branch  0 never executed
branch  1 never executed
    #####: 6433:      stbi__get8(s);
    %%%%%: 6433-block  0
call    0 never executed
        -: 6434:
    #####: 6435:   x = stbi__get16be(s);
    %%%%%: 6435-block  0
call    0 never executed
    #####: 6436:   y = stbi__get16be(s);
call    0 never executed
        -: 6437:
    #####: 6438:   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
branch  0 never executed
branch  1 never executed
    #####: 6439:   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 6439-block  0
branch  0 never executed
branch  1 never executed
        -: 6440:
    #####: 6441:   if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");
    %%%%%: 6441-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6441-block  1
        -: 6442:   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");
        -: 6443:
    #####: 6444:   stbi__get32be(s); //skip `ratio'
    %%%%%: 6444-block  0
call    0 never executed
    #####: 6445:   stbi__get16be(s); //skip `fields'
call    0 never executed
    #####: 6446:   stbi__get16be(s); //skip `pad'
call    0 never executed
        -: 6447:
        -: 6448:   // intermediate buffer is RGBA
    #####: 6449:   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
call    0 never executed
    #####: 6450:   if (!result) return stbi__errpuc("outofmem", "Out of memory");
branch  0 never executed
branch  1 never executed
    #####: 6451:   memset(result, 0xff, x*y*4);
    %%%%%: 6451-block  0
call    0 never executed
        -: 6452:
    #####: 6453:   if (!stbi__pic_load_core(s,x,y,comp, result)) {
    %%%%%: 6453-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6454:      STBI_FREE(result);
    %%%%%: 6454-block  0
        -: 6455:      result=0;
        -: 6456:   }
    #####: 6457:   *px = x;
    #####: 6458:   *py = y;
    #####: 6459:   if (req_comp == 0) req_comp = *comp;
    %%%%%: 6459-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6459-block  1
    #####: 6460:   result=stbi__convert_format(result,4,req_comp,x,y);
    %%%%%: 6460-block  0
call    0 never executed
        -: 6461:
    #####: 6462:   return result;
        -: 6463:}
        -: 6464:
        -: 6465:static int stbi__pic_test(stbi__context *s)
        -: 6466:{
    #####: 6467:   int r = stbi__pic_test_core(s);
    %%%%%: 6467-block  0
call    0 never executed
        -: 6468:   stbi__rewind(s);
        -: 6469:   return r;
        -: 6470:}
        -: 6471:#endif
        -: 6472:
        -: 6473:// *************************************************************************************************
        -: 6474:// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb
        -: 6475:
        -: 6476:#ifndef STBI_NO_GIF
        -: 6477:typedef struct
        -: 6478:{
        -: 6479:   stbi__int16 prefix;
        -: 6480:   stbi_uc first;
        -: 6481:   stbi_uc suffix;
        -: 6482:} stbi__gif_lzw;
        -: 6483:
        -: 6484:typedef struct
        -: 6485:{
        -: 6486:   int w,h;
        -: 6487:   stbi_uc *out;                 // output buffer (always 4 components)
        -: 6488:   stbi_uc *background;          // The current "background" as far as a gif is concerned
        -: 6489:   stbi_uc *history;
        -: 6490:   int flags, bgindex, ratio, transparent, eflags;
        -: 6491:   stbi_uc  pal[256][4];
        -: 6492:   stbi_uc lpal[256][4];
        -: 6493:   stbi__gif_lzw codes[8192];
        -: 6494:   stbi_uc *color_table;
        -: 6495:   int parse, step;
        -: 6496:   int lflags;
        -: 6497:   int start_x, start_y;
        -: 6498:   int max_x, max_y;
        -: 6499:   int cur_x, cur_y;
        -: 6500:   int line_size;
        -: 6501:   int delay;
        -: 6502:} stbi__gif;
        -: 6503:
function _ZL18stbi__gif_test_rawP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 6504:static int stbi__gif_test_raw(stbi__context *s)
        -: 6505:{
        -: 6506:   int sz;
    #####: 6507:   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
    %%%%%: 6507-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%: 6507-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    %%%%%: 6507-block  2
call    6 never executed
branch  7 never executed
branch  8 never executed
    %%%%%: 6507-block  3
call    9 never executed
branch 10 never executed
branch 11 never executed
    %%%%%: 6507-block  4
    #####: 6508:   sz = stbi__get8(s);
    %%%%%: 6508-block  0
call    0 never executed
    #####: 6509:   if (sz != '9' && sz != '7') return 0;
branch  0 never executed
branch  1 never executed
    #####: 6510:   if (stbi__get8(s) != 'a') return 0;
    %%%%%: 6510-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%: 6510-block  1
        -: 6511:   return 1;
        -: 6512:}
        -: 6513:
        -: 6514:static int stbi__gif_test(stbi__context *s)
        -: 6515:{
    #####: 6516:   int r = stbi__gif_test_raw(s);
    %%%%%: 6516-block  0
call    0 never executed
        -: 6517:   stbi__rewind(s);
        -: 6518:   return r;
        -: 6519:}
        -: 6520:
function _ZL26stbi__gif_parse_colortableP13stbi__contextPA4_hii called 0 returned 0% blocks executed 0%
    #####: 6521:static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
    %%%%%: 6521-block  0
        -: 6522:{
        -: 6523:   int i;
    #####: 6524:   for (i=0; i < num_entries; ++i) {
    %%%%%: 6524-block  0
branch  0 never executed
branch  1 never executed
    #####: 6525:      pal[i][2] = stbi__get8(s);
    %%%%%: 6525-block  0
call    0 never executed
    #####: 6526:      pal[i][1] = stbi__get8(s);
call    0 never executed
    #####: 6527:      pal[i][0] = stbi__get8(s);
call    0 never executed
    #####: 6528:      pal[i][3] = transp == i ? 0 : 255;
branch  0 never executed
branch  1 never executed
    %%%%%: 6528-block  0
        -: 6529:   }
    #####: 6530:}
        -: 6531:
function _ZL16stbi__gif_headerP13stbi__contextP9stbi__gifPii called 0 returned 0% blocks executed 0%
    #####: 6532:static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
        -: 6533:{
        -: 6534:   stbi_uc version;
    #####: 6535:   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
    %%%%%: 6535-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%: 6535-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    %%%%%: 6535-block  2
call    6 never executed
branch  7 never executed
branch  8 never executed
    %%%%%: 6535-block  3
call    9 never executed
branch 10 never executed
branch 11 never executed
    #####: 6536:      return stbi__err("not GIF", "Corrupt GIF");
    %%%%%: 6536-block  0
        -: 6537:
    #####: 6538:   version = stbi__get8(s);
    %%%%%: 6538-block  0
call    0 never executed
    #####: 6539:   if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");
branch  0 never executed
branch  1 never executed
    #####: 6540:   if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");
    %%%%%: 6540-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 6541:
    #####: 6542:   stbi__g_failure_reason = "";
    #####: 6543:   g->w = stbi__get16le(s);
    %%%%%: 6543-block  0
call    0 never executed
    #####: 6544:   g->h = stbi__get16le(s);
call    0 never executed
    #####: 6545:   g->flags = stbi__get8(s);
call    0 never executed
    #####: 6546:   g->bgindex = stbi__get8(s);
call    0 never executed
    #####: 6547:   g->ratio = stbi__get8(s);
call    0 never executed
    #####: 6548:   g->transparent = -1;
        -: 6549:
    #####: 6550:   if (g->w > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
branch  0 never executed
branch  1 never executed
    #####: 6551:   if (g->h > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
    %%%%%: 6551-block  0
branch  0 never executed
branch  1 never executed
        -: 6552:
    #####: 6553:   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments
    %%%%%: 6553-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6553-block  1
        -: 6554:
    #####: 6555:   if (is_info) return 1;
    %%%%%: 6555-block  0
branch  0 never executed
branch  1 never executed
        -: 6556:
    #####: 6557:   if (g->flags & 0x80)
    %%%%%: 6557-block  0
branch  0 never executed
branch  1 never executed
    #####: 6558:      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);
    %%%%%: 6558-block  0
call    0 never executed
        -: 6559:
        -: 6560:   return 1;
        -: 6561:}
        -: 6562:
function _ZL18stbi__gif_info_rawP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 6563:static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
        -: 6564:{
        -: 6565:   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
    #####: 6566:   if (!g) return stbi__err("outofmem", "Out of memory");
    %%%%%: 6566-block  0
branch  0 never executed
branch  1 never executed
    #####: 6567:   if (!stbi__gif_header(s, g, comp, 1)) {
    %%%%%: 6567-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6568:      STBI_FREE(g);
        -: 6569:      stbi__rewind( s );
    #####: 6570:      return 0;
    %%%%%: 6570-block  0
        -: 6571:   }
    #####: 6572:   if (x) *x = g->w;
    %%%%%: 6572-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6572-block  1
    #####: 6573:   if (y) *y = g->h;
    %%%%%: 6573-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6573-block  1
    #####: 6574:   STBI_FREE(g);
    #####: 6575:   return 1;
    %%%%%: 6575-block  0
        -: 6576:}
        -: 6577:
function _ZL18stbi__out_gif_codeP9stbi__gift called 0 returned 0% blocks executed 0%
    #####: 6578:static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
        -: 6579:{
        -: 6580:   stbi_uc *p, *c;
        -: 6581:   int idx;
        -: 6582:
        -: 6583:   // recurse to decode the prefixes, since the linked-list is backwards,
        -: 6584:   // and working backwards through an interleaved image would be nasty
    #####: 6585:   if (g->codes[code].prefix >= 0)
    %%%%%: 6585-block  0
branch  0 never executed
branch  1 never executed
    #####: 6586:      stbi__out_gif_code(g, g->codes[code].prefix);
    %%%%%: 6586-block  0
call    0 never executed
        -: 6587:
    #####: 6588:   if (g->cur_y >= g->max_y) return;
    %%%%%: 6588-block  0
branch  0 never executed
branch  1 never executed
        -: 6589:
    #####: 6590:   idx = g->cur_x + g->cur_y;
    #####: 6591:   p = &g->out[idx];
    #####: 6592:   g->history[idx / 4] = 1;
        -: 6593:
    #####: 6594:   c = &g->color_table[g->codes[code].suffix * 4];
    #####: 6595:   if (c[3] > 128) { // don't render transparent pixels;
    %%%%%: 6595-block  0
branch  0 never executed
branch  1 never executed
    #####: 6596:      p[0] = c[2];
    #####: 6597:      p[1] = c[1];
    #####: 6598:      p[2] = c[0];
    #####: 6599:      p[3] = c[3];
    %%%%%: 6599-block  0
        -: 6600:   }
    #####: 6601:   g->cur_x += 4;
        -: 6602:
    #####: 6603:   if (g->cur_x >= g->max_x) {
    %%%%%: 6603-block  0
branch  0 never executed
branch  1 never executed
    #####: 6604:      g->cur_x = g->start_x;
    #####: 6605:      g->cur_y += g->step;
    %%%%%: 6605-block  0
        -: 6606:
    #####: 6607:      while (g->cur_y >= g->max_y && g->parse > 0) {
    %%%%%: 6607-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6607-block  1
branch  2 never executed
branch  3 never executed
    #####: 6608:         g->step = (1 << g->parse) * g->line_size;
    #####: 6609:         g->cur_y = g->start_y + (g->step >> 1);
    #####: 6610:         --g->parse;
    %%%%%: 6610-block  0
        -: 6611:      }
        -: 6612:   }
        -: 6613:}
        -: 6614:
function _ZL24stbi__process_gif_rasterP13stbi__contextP9stbi__gif called 0 returned 0% blocks executed 0%
    #####: 6615:static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
        -: 6616:{
        -: 6617:   stbi_uc lzw_cs;
        -: 6618:   stbi__int32 len, init_code;
        -: 6619:   stbi__uint32 first;
        -: 6620:   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
        -: 6621:   stbi__gif_lzw *p;
        -: 6622:
    #####: 6623:   lzw_cs = stbi__get8(s);
    %%%%%: 6623-block  0
call    0 never executed
    #####: 6624:   if (lzw_cs > 12) return NULL;
branch  0 never executed
branch  1 never executed
    #####: 6625:   clear = 1 << lzw_cs;
        -: 6626:   first = 1;
    #####: 6627:   codesize = lzw_cs + 1;
    #####: 6628:   codemask = (1 << codesize) - 1;
    %%%%%: 6628-block  0
        -: 6629:   bits = 0;
        -: 6630:   valid_bits = 0;
    #####: 6631:   for (init_code = 0; init_code < clear; init_code++) {
    %%%%%: 6631-block  0
branch  0 never executed
branch  1 never executed
    #####: 6632:      g->codes[init_code].prefix = -1;
    #####: 6633:      g->codes[init_code].first = (stbi_uc) init_code;
    #####: 6634:      g->codes[init_code].suffix = (stbi_uc) init_code;
    %%%%%: 6634-block  0
        -: 6635:   }
        -: 6636:
        -: 6637:   // support no starting clear code
    #####: 6638:   avail = clear+2;
    %%%%%: 6638-block  0
        -: 6639:   oldcode = -1;
        -: 6640:
        -: 6641:   len = 0;
        -: 6642:   for(;;) {
    #####: 6643:      if (valid_bits < codesize) {
    %%%%%: 6643-block  0
branch  0 never executed
branch  1 never executed
    #####: 6644:         if (len == 0) {
    %%%%%: 6644-block  0
branch  0 never executed
branch  1 never executed
    #####: 6645:            len = stbi__get8(s); // start new block
    %%%%%: 6645-block  0
call    0 never executed
    #####: 6646:            if (len == 0)
branch  0 never executed
branch  1 never executed
    #####: 6647:               return g->out;
    %%%%%: 6647-block  0
        -: 6648:         }
    #####: 6649:         --len;
    #####: 6650:         bits |= (stbi__int32) stbi__get8(s) << valid_bits;
    %%%%%: 6650-block  0
call    0 never executed
    #####: 6651:         valid_bits += 8;
        -: 6652:      } else {
    #####: 6653:         stbi__int32 code = bits & codemask;
    #####: 6654:         bits >>= codesize;
    #####: 6655:         valid_bits -= codesize;
        -: 6656:         // @OPTIMIZE: is there some way we can accelerate the non-clear path?
    #####: 6657:         if (code == clear) {  // clear code
    %%%%%: 6657-block  0
branch  0 never executed
branch  1 never executed
        -: 6658:            codesize = lzw_cs + 1;
        -: 6659:            codemask = (1 << codesize) - 1;
        -: 6660:            avail = clear + 2;
        -: 6661:            oldcode = -1;
        -: 6662:            first = 0;
    #####: 6663:         } else if (code == clear + 1) { // end of stream code
    %%%%%: 6663-block  0
branch  0 never executed
branch  1 never executed
    #####: 6664:            stbi__skip(s, len);
    %%%%%: 6664-block  0
call    0 never executed
    #####: 6665:            while ((len = stbi__get8(s)) > 0)
    %%%%%: 6665-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6666:               stbi__skip(s,len);
    %%%%%: 6666-block  0
call    0 never executed
    #####: 6667:            return g->out;
    %%%%%: 6667-block  0
    #####: 6668:         } else if (code <= avail) {
    %%%%%: 6668-block  0
branch  0 never executed
branch  1 never executed
    #####: 6669:            if (first) {
    %%%%%: 6669-block  0
branch  0 never executed
branch  1 never executed
        -: 6670:               return stbi__errpuc("no clear code", "Corrupt GIF");
        -: 6671:            }
        -: 6672:
    #####: 6673:            if (oldcode >= 0) {
    %%%%%: 6673-block  0
branch  0 never executed
branch  1 never executed
    #####: 6674:               p = &g->codes[avail++];
    #####: 6675:               if (avail > 8192) {
    %%%%%: 6675-block  0
branch  0 never executed
branch  1 never executed
        -: 6676:                  return stbi__errpuc("too many codes", "Corrupt GIF");
        -: 6677:               }
        -: 6678:
    #####: 6679:               p->prefix = (stbi__int16) oldcode;
    #####: 6680:               p->first = g->codes[oldcode].first;
    #####: 6681:               p->suffix = (code == avail) ? p->first : g->codes[code].first;
    %%%%%: 6681-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6681-block  1
    %%%%%: 6681-block  2
    #####: 6682:            } else if (code == avail)
    %%%%%: 6682-block  0
branch  0 never executed
branch  1 never executed
        -: 6683:               return stbi__errpuc("illegal code in raster", "Corrupt GIF");
        -: 6684:
    #####: 6685:            stbi__out_gif_code(g, (stbi__uint16) code);
    %%%%%: 6685-block  0
call    0 never executed
        -: 6686:
    #####: 6687:            if ((avail & codemask) == 0 && avail <= 0x0FFF) {
branch  0 never executed
branch  1 never executed
    %%%%%: 6687-block  0
branch  2 never executed
branch  3 never executed
    #####: 6688:               codesize++;
    #####: 6689:               codemask = (1 << codesize) - 1;
    %%%%%: 6689-block  0
        -: 6690:            }
        -: 6691:
        -: 6692:            oldcode = code;
        -: 6693:         } else {
        -: 6694:            return stbi__errpuc("illegal code in raster", "Corrupt GIF");
        -: 6695:         }
        -: 6696:      }
        -: 6697:   }
        -: 6698:}
        -: 6699:
        -: 6700:// this function is designed to support animated gifs, although stb_image doesn't support it
        -: 6701:// two back is the image from two frames ago, used for a very specific disposal format
function _ZL19stbi__gif_load_nextP13stbi__contextP9stbi__gifPiiPh called 0 returned 0% blocks executed 0%
    #####: 6702:static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)
        -: 6703:{
        -: 6704:   int dispose;
        -: 6705:   int first_frame;
        -: 6706:   int pi;
        -: 6707:   int pcount;
        -: 6708:   STBI_NOTUSED(req_comp);
        -: 6709:
        -: 6710:   // on first frame, any non-written pixels get the background colour (non-transparent)
        -: 6711:   first_frame = 0;
    #####: 6712:   if (g->out == 0) {
    %%%%%: 6712-block  0
branch  0 never executed
branch  1 never executed
    #####: 6713:      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header
    %%%%%: 6713-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6714:      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))
    %%%%%: 6714-block  0
branch  0 never executed
branch  1 never executed
        -: 6715:         return stbi__errpuc("too large", "GIF image is too large");
    #####: 6716:      pcount = g->w * g->h;
    #####: 6717:      g->out = (stbi_uc *) stbi__malloc(4 * pcount);
    #####: 6718:      g->background = (stbi_uc *) stbi__malloc(4 * pcount);
    #####: 6719:      g->history = (stbi_uc *) stbi__malloc(pcount);
    #####: 6720:      if (!g->out || !g->background || !g->history)
    %%%%%: 6720-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6720-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 6720-block  2
branch  4 never executed
branch  5 never executed
        -: 6721:         return stbi__errpuc("outofmem", "Out of memory");
        -: 6722:
        -: 6723:      // image is treated as "transparent" at the start - ie, nothing overwrites the current background;
        -: 6724:      // background colour is only used for pixels that are not rendered first frame, after that "background"
        -: 6725:      // color refers to the color that was there the previous frame.
        -: 6726:      memset(g->out, 0x00, 4 * pcount);
        -: 6727:      memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)
        -: 6728:      memset(g->history, 0x00, pcount);        // pixels that were affected previous frame
        -: 6729:      first_frame = 1;
        -: 6730:   } else {
        -: 6731:      // second frame - how do we dispose of the previous one?
    #####: 6732:      dispose = (g->eflags & 0x1C) >> 2;
    #####: 6733:      pcount = g->w * g->h;
        -: 6734:
    #####: 6735:      if ((dispose == 3) && (two_back == 0)) {
    %%%%%: 6735-block  0
branch  0 never executed
branch  1 never executed
        -: 6736:         dispose = 2; // if I don't have an image to revert back to, default to the old background
        -: 6737:      }
        -: 6738:
    #####: 6739:      if (dispose == 3) { // use previous graphic
    %%%%%: 6739-block  0
branch  0 never executed
branch  1 never executed
    #####: 6740:         for (pi = 0; pi < pcount; ++pi) {
    %%%%%: 6740-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6740-block  1
    #####: 6741:            if (g->history[pi]) {
    %%%%%: 6741-block  0
branch  0 never executed
branch  1 never executed
    #####: 6742:               memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );
    %%%%%: 6742-block  0
        -: 6743:            }
        -: 6744:         }
    #####: 6745:      } else if (dispose == 2) {
    %%%%%: 6745-block  0
branch  0 never executed
branch  1 never executed
        -: 6746:         // restore what was changed last frame to background before that frame;
    #####: 6747:         for (pi = 0; pi < pcount; ++pi) {
    %%%%%: 6747-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6747-block  1
    #####: 6748:            if (g->history[pi]) {
    %%%%%: 6748-block  0
branch  0 never executed
branch  1 never executed
    #####: 6749:               memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );
    %%%%%: 6749-block  0
        -: 6750:            }
        -: 6751:         }
        -: 6752:      } else {
        -: 6753:         // This is a non-disposal case eithe way, so just
        -: 6754:         // leave the pixels as is, and they will become the new background
        -: 6755:         // 1: do not dispose
        -: 6756:         // 0:  not specified.
        -: 6757:      }
        -: 6758:
        -: 6759:      // background is what out is after the undoing of the previou frame;
    #####: 6760:      memcpy( g->background, g->out, 4 * g->w * g->h );
    %%%%%: 6760-block  0
        -: 6761:   }
        -: 6762:
        -: 6763:   // clear my history;
    #####: 6764:   memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame
    %%%%%: 6764-block  0
        -: 6765:
        -: 6766:   for (;;) {
    #####: 6767:      int tag = stbi__get8(s);
    %%%%%: 6767-block  0
call    0 never executed
    #####: 6768:      switch (tag) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6769:         case 0x2C: /* Image Descriptor */
        -: 6770:         {
        -: 6771:            stbi__int32 x, y, w, h;
        -: 6772:            stbi_uc *o;
        -: 6773:
    #####: 6774:            x = stbi__get16le(s);
    %%%%%: 6774-block  0
call    0 never executed
    #####: 6775:            y = stbi__get16le(s);
call    0 never executed
    #####: 6776:            w = stbi__get16le(s);
call    0 never executed
    #####: 6777:            h = stbi__get16le(s);
call    0 never executed
    #####: 6778:            if (((x + w) > (g->w)) || ((y + h) > (g->h)))
branch  0 never executed
branch  1 never executed
    %%%%%: 6778-block  0
branch  2 never executed
branch  3 never executed
        -: 6779:               return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");
        -: 6780:
    #####: 6781:            g->line_size = g->w * 4;
    #####: 6782:            g->start_x = x * 4;
    #####: 6783:            g->start_y = y * g->line_size;
    #####: 6784:            g->max_x   = g->start_x + w * 4;
    #####: 6785:            g->max_y   = g->start_y + h * g->line_size;
    #####: 6786:            g->cur_x   = g->start_x;
    #####: 6787:            g->cur_y   = g->start_y;
        -: 6788:
        -: 6789:            // if the width of the specified rectangle is 0, that means
        -: 6790:            // we may not see *any* pixels or the image is malformed;
        -: 6791:            // to make sure this is caught, move the current y down to
        -: 6792:            // max_y (which is what out_gif_code checks).
    #####: 6793:            if (w == 0)
    %%%%%: 6793-block  0
branch  0 never executed
branch  1 never executed
    #####: 6794:               g->cur_y = g->max_y;
    %%%%%: 6794-block  0
        -: 6795:
    #####: 6796:            g->lflags = stbi__get8(s);
    %%%%%: 6796-block  0
call    0 never executed
        -: 6797:
    #####: 6798:            if (g->lflags & 0x40) {
branch  0 never executed
branch  1 never executed
    #####: 6799:               g->step = 8 * g->line_size; // first interlaced spacing
    #####: 6800:               g->parse = 3;
    %%%%%: 6800-block  0
        -: 6801:            } else {
    #####: 6802:               g->step = g->line_size;
    #####: 6803:               g->parse = 0;
    %%%%%: 6803-block  0
        -: 6804:            }
        -: 6805:
    #####: 6806:            if (g->lflags & 0x80) {
    %%%%%: 6806-block  0
branch  0 never executed
branch  1 never executed
    #####: 6807:               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
    %%%%%: 6807-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6807-block  1
    %%%%%: 6807-block  2
call    2 never executed
    #####: 6808:               g->color_table = (stbi_uc *) g->lpal;
    #####: 6809:            } else if (g->flags & 0x80) {
    %%%%%: 6809-block  0
branch  0 never executed
branch  1 never executed
    #####: 6810:               g->color_table = (stbi_uc *) g->pal;
    %%%%%: 6810-block  0
        -: 6811:            } else
        -: 6812:               return stbi__errpuc("missing color table", "Corrupt GIF");
        -: 6813:
    #####: 6814:            o = stbi__process_gif_raster(s, g);
    %%%%%: 6814-block  0
call    0 never executed
    #####: 6815:            if (!o) return NULL;
branch  0 never executed
branch  1 never executed
        -: 6816:
        -: 6817:            // if this was the first frame,
    #####: 6818:            pcount = g->w * g->h;
    #####: 6819:            if (first_frame && (g->bgindex > 0)) {
    %%%%%: 6819-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6819-block  1
branch  2 never executed
branch  3 never executed
        -: 6820:               // if first frame, any pixel not drawn to gets the background color
    #####: 6821:               for (pi = 0; pi < pcount; ++pi) {
    %%%%%: 6821-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6821-block  1
    #####: 6822:                  if (g->history[pi] == 0) {
    %%%%%: 6822-block  0
branch  0 never executed
branch  1 never executed
    #####: 6823:                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;
    #####: 6824:                     memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );
    %%%%%: 6824-block  0
        -: 6825:                  }
        -: 6826:               }
        -: 6827:            }
        -: 6828:
        -: 6829:            return o;
        -: 6830:         }
        -: 6831:
    #####: 6832:         case 0x21: // Comment Extension.
        -: 6833:         {
        -: 6834:            int len;
    #####: 6835:            int ext = stbi__get8(s);
    %%%%%: 6835-block  0
call    0 never executed
    #####: 6836:            if (ext == 0xF9) { // Graphic Control Extension.
branch  0 never executed
branch  1 never executed
    #####: 6837:               len = stbi__get8(s);
    %%%%%: 6837-block  0
call    0 never executed
    #####: 6838:               if (len == 4) {
branch  0 never executed
branch  1 never executed
    #####: 6839:                  g->eflags = stbi__get8(s);
    %%%%%: 6839-block  0
call    0 never executed
    #####: 6840:                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.
call    0 never executed
        -: 6841:
        -: 6842:                  // unset old transparent
    #####: 6843:                  if (g->transparent >= 0) {
branch  0 never executed
branch  1 never executed
    #####: 6844:                     g->pal[g->transparent][3] = 255;
    %%%%%: 6844-block  0
        -: 6845:                  }
    #####: 6846:                  if (g->eflags & 0x01) {
    %%%%%: 6846-block  0
branch  0 never executed
branch  1 never executed
    #####: 6847:                     g->transparent = stbi__get8(s);
    %%%%%: 6847-block  0
call    0 never executed
        -: 6848:                     if (g->transparent >= 0) {
    #####: 6849:                        g->pal[g->transparent][3] = 0;
        -: 6850:                     }
        -: 6851:                  } else {
        -: 6852:                     // don't need transparent
        -: 6853:                     stbi__skip(s, 1);
    #####: 6854:                     g->transparent = -1;
    %%%%%: 6854-block  0
        -: 6855:                  }
        -: 6856:               } else {
    #####: 6857:                  stbi__skip(s, len);
    %%%%%: 6857-block  0
call    0 never executed
    #####: 6858:                  break;
        -: 6859:               }
        -: 6860:            }
    #####: 6861:            while ((len = stbi__get8(s)) != 0) {
    %%%%%: 6861-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6862:               stbi__skip(s, len);
    %%%%%: 6862-block  0
call    0 never executed
        -: 6863:            }
        -: 6864:            break;
        -: 6865:         }
        -: 6866:
        -: 6867:         case 0x3B: // gif stream termination code
        -: 6868:            return (stbi_uc *) s; // using '1' causes warning on some compilers
        -: 6869:
    #####: 6870:         default:
    #####: 6871:            return stbi__errpuc("unknown code", "Corrupt GIF");
    %%%%%: 6871-block  0
        -: 6872:      }
        -: 6873:   }
        -: 6874:}
        -: 6875:
function _ZL28stbi__load_gif_main_outofmemP9stbi__gifPhPPi called 0 returned 0% blocks executed 0%
    #####: 6876:static void *stbi__load_gif_main_outofmem(stbi__gif *g, stbi_uc *out, int **delays)
        -: 6877:{
    #####: 6878:   STBI_FREE(g->out);
    #####: 6879:   STBI_FREE(g->history);
    #####: 6880:   STBI_FREE(g->background);
        -: 6881:
    #####: 6882:   if (out) STBI_FREE(out);
    %%%%%: 6882-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6882-block  1
    #####: 6883:   if (delays && *delays) STBI_FREE(*delays);
    %%%%%: 6883-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 6883-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 6883-block  2
    #####: 6884:   return stbi__errpuc("outofmem", "Out of memory");
        -: 6885:}
        -: 6886:
function _ZL19stbi__load_gif_mainP13stbi__contextPPiS1_S1_S1_S1_i called 0 returned 0% blocks executed 0%
    #####: 6887:static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
    %%%%%: 6887-block  0
call    0 never executed
        -: 6888:{
    #####: 6889:   if (stbi__gif_test(s)) {
branch  0 never executed
branch  1 never executed
        -: 6890:      int layers = 0;
        -: 6891:      stbi_uc *u = 0;
        -: 6892:      stbi_uc *out = 0;
        -: 6893:      stbi_uc *two_back = 0;
        -: 6894:      stbi__gif g;
        -: 6895:      int stride;
        -: 6896:      int out_size = 0;
        -: 6897:      int delays_size = 0;
        -: 6898:
        -: 6899:      STBI_NOTUSED(out_size);
        -: 6900:      STBI_NOTUSED(delays_size);
        -: 6901:
        -: 6902:      memset(&g, 0, sizeof(g));
    #####: 6903:      if (delays) {
    %%%%%: 6903-block  0
branch  0 never executed
branch  1 never executed
    #####: 6904:         *delays = 0;
    %%%%%: 6904-block  0
        -: 6905:      }
        -: 6906:
        -: 6907:      do {
    #####: 6908:         u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);
    %%%%%: 6908-block  0
call    0 never executed
    #####: 6909:         if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
branch  0 never executed
branch  1 never executed
        -: 6910:
    #####: 6911:         if (u) {
    %%%%%: 6911-block  0
branch  0 never executed
branch  1 never executed
    #####: 6912:            *x = g.w;
    #####: 6913:            *y = g.h;
    #####: 6914:            ++layers;
    #####: 6915:            stride = g.w * g.h * 4;
        -: 6916:
    #####: 6917:            if (out) {
    %%%%%: 6917-block  0
branch  0 never executed
branch  1 never executed
    #####: 6918:               void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );
    #####: 6919:               if (!tmp)
    %%%%%: 6919-block  0
branch  0 never executed
branch  1 never executed
    #####: 6920:                  return stbi__load_gif_main_outofmem(&g, out, delays);
    %%%%%: 6920-block  0
call    0 never executed
        -: 6921:               else {
        -: 6922:                   out = (stbi_uc*) tmp;
        -: 6923:                   out_size = layers * stride;
        -: 6924:               }
        -: 6925:
    #####: 6926:               if (delays) {
    %%%%%: 6926-block  0
branch  0 never executed
branch  1 never executed
    #####: 6927:                  int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );
    #####: 6928:                  if (!new_delays)
    %%%%%: 6928-block  0
branch  0 never executed
branch  1 never executed
    #####: 6929:                     return stbi__load_gif_main_outofmem(&g, out, delays);
    %%%%%: 6929-block  0
call    0 never executed
    #####: 6930:                  *delays = new_delays;
    %%%%%: 6930-block  0
        -: 6931:                  delays_size = layers * sizeof(int);
        -: 6932:               }
        -: 6933:            } else {
    #####: 6934:               out = (stbi_uc*)stbi__malloc( layers * stride );
    #####: 6935:               if (!out)
    %%%%%: 6935-block  0
branch  0 never executed
branch  1 never executed
    #####: 6936:                  return stbi__load_gif_main_outofmem(&g, out, delays);
    %%%%%: 6936-block  0
call    0 never executed
        -: 6937:               out_size = layers * stride;
    #####: 6938:               if (delays) {
    %%%%%: 6938-block  0
branch  0 never executed
branch  1 never executed
    #####: 6939:                  *delays = (int*) stbi__malloc( layers * sizeof(int) );
    #####: 6940:                  if (!*delays)
    %%%%%: 6940-block  0
branch  0 never executed
branch  1 never executed
    #####: 6941:                     return stbi__load_gif_main_outofmem(&g, out, delays);
    %%%%%: 6941-block  0
call    0 never executed
        -: 6942:                  delays_size = layers * sizeof(int);
        -: 6943:               }
        -: 6944:            }
    #####: 6945:            memcpy( out + ((layers - 1) * stride), u, stride );
    %%%%%: 6945-block  0
branch  0 never executed
branch  1 never executed
    #####: 6946:            if (layers >= 2) {
    %%%%%: 6946-block  0
branch  0 never executed
branch  1 never executed
    #####: 6947:               two_back = out - 2 * stride;
    %%%%%: 6947-block  0
        -: 6948:            }
        -: 6949:
    #####: 6950:            if (delays) {
    %%%%%: 6950-block  0
branch  0 never executed
branch  1 never executed
    #####: 6951:               (*delays)[layers - 1U] = g.delay;
    %%%%%: 6951-block  0
        -: 6952:            }
        -: 6953:         }
    #####: 6954:      } while (u != 0);
    %%%%%: 6954-block  0
branch  0 never executed
branch  1 never executed
        -: 6955:
        -: 6956:      // free temp buffer;
    #####: 6957:      STBI_FREE(g.out);
    #####: 6958:      STBI_FREE(g.history);
    #####: 6959:      STBI_FREE(g.background);
        -: 6960:
        -: 6961:      // do the final conversion after loading everything;
    #####: 6962:      if (req_comp && req_comp != 4)
    %%%%%: 6962-block  0
branch  0 never executed
branch  1 never executed
    #####: 6963:         out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);
    %%%%%: 6963-block  0
call    0 never executed
        -: 6964:
    #####: 6965:      *z = layers;
    #####: 6966:      return out;
    %%%%%: 6966-block  0
        -: 6967:   } else {
        -: 6968:      return stbi__errpuc("not GIF", "Image was not as a gif type.");
        -: 6969:   }
        -: 6970:}
        -: 6971:
function _ZL14stbi__gif_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 6972:static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
    %%%%%: 6972-block  0
call    0 never executed
        -: 6973:{
        -: 6974:   stbi_uc *u = 0;
        -: 6975:   stbi__gif g;
        -: 6976:   memset(&g, 0, sizeof(g));
        -: 6977:   STBI_NOTUSED(ri);
        -: 6978:
    #####: 6979:   u = stbi__gif_load_next(s, &g, comp, req_comp, 0);
    %%%%%: 6979-block  0
call    0 never executed
    #####: 6980:   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
branch  0 never executed
branch  1 never executed
    #####: 6981:   if (u) {
    %%%%%: 6981-block  0
branch  0 never executed
branch  1 never executed
    #####: 6982:      *x = g.w;
    #####: 6983:      *y = g.h;
        -: 6984:
        -: 6985:      // moved conversion to after successful load so that the same
        -: 6986:      // can be done for multiple frames.
    #####: 6987:      if (req_comp && req_comp != 4)
    %%%%%: 6987-block  0
branch  0 never executed
branch  1 never executed
    #####: 6988:         u = stbi__convert_format(u, 4, req_comp, g.w, g.h);
    %%%%%: 6988-block  0
call    0 never executed
    #####: 6989:   } else if (g.out) {
    %%%%%: 6989-block  0
branch  0 never executed
branch  1 never executed
        -: 6990:      // if there was an error and we allocated an image buffer, free it!
    #####: 6991:      STBI_FREE(g.out);
    %%%%%: 6991-block  0
        -: 6992:   }
        -: 6993:
        -: 6994:   // free buffers needed for multiple frame loading;
    #####: 6995:   STBI_FREE(g.history);
    #####: 6996:   STBI_FREE(g.background);
        -: 6997:
    #####: 6998:   return u;
        -: 6999:}
        -: 7000:
        -: 7001:static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
        -: 7002:{
    #####: 7003:   return stbi__gif_info_raw(s,x,y,comp);
    %%%%%: 7003-block  0
call    0 never executed
        -: 7004:}
        -: 7005:#endif
        -: 7006:
        -: 7007:// *************************************************************************************************
        -: 7008:// Radiance RGBE HDR loader
        -: 7009:// originally by Nicolas Schulz
        -: 7010:#ifndef STBI_NO_HDR
function _ZL19stbi__hdr_test_coreP13stbi__contextPKc called 0 returned 0% blocks executed 0%
    #####: 7011:static int stbi__hdr_test_core(stbi__context *s, const char *signature)
    %%%%%: 7011-block  0
        -: 7012:{
        -: 7013:   int i;
    #####: 7014:   for (i=0; signature[i]; ++i)
    %%%%%: 7014-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7014-block  1
    #####: 7015:      if (stbi__get8(s) != signature[i])
    %%%%%: 7015-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7016:          return 0;
        -: 7017:   stbi__rewind(s);
    #####: 7018:   return 1;
    %%%%%: 7018-block  0
        -: 7019:}
        -: 7020:
function _ZL14stbi__hdr_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 7021:static int stbi__hdr_test(stbi__context* s)
        -: 7022:{
    #####: 7023:   int r = stbi__hdr_test_core(s, "#?RADIANCE\n");
    %%%%%: 7023-block  0
call    0 never executed
        -: 7024:   stbi__rewind(s);
    #####: 7025:   if(!r) {
branch  0 never executed
branch  1 never executed
    #####: 7026:       r = stbi__hdr_test_core(s, "#?RGBE\n");
    %%%%%: 7026-block  0
call    0 never executed
        -: 7027:       stbi__rewind(s);
        -: 7028:   }
    #####: 7029:   return r;
        -: 7030:}
        -: 7031:
        -: 7032:#define STBI__HDR_BUFLEN  1024
function _ZL18stbi__hdr_gettokenP13stbi__contextPc called 0 returned 0% blocks executed 0%
    #####: 7033:static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
        -: 7034:{
        -: 7035:   int len=0;
        -: 7036:   char c = '\0';
        -: 7037:
    #####: 7038:   c = (char) stbi__get8(z);
    %%%%%: 7038-block  0
call    0 never executed
        -: 7039:
    #####: 7040:   while (!stbi__at_eof(z) && c != '\n') {
    %%%%%: 7040-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7040-block  1
branch  2 never executed
branch  3 never executed
    #####: 7041:      buffer[len++] = c;
    #####: 7042:      if (len == STBI__HDR_BUFLEN-1) {
    %%%%%: 7042-block  0
branch  0 never executed
branch  1 never executed
        -: 7043:         // flush to end of line
    #####: 7044:         while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
    %%%%%: 7044-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7044-block  1
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 7045:            ;
        -: 7046:         break;
        -: 7047:      }
    #####: 7048:      c = (char) stbi__get8(z);
    %%%%%: 7048-block  0
call    0 never executed
        -: 7049:   }
        -: 7050:
    #####: 7051:   buffer[len] = 0;
    #####: 7052:   return buffer;
        -: 7053:}
        -: 7054:
function _ZL17stbi__hdr_convertPfPhi called 0 returned 0% blocks executed 0%
    #####: 7055:static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
        -: 7056:{
    #####: 7057:   if ( input[3] != 0 ) {
    %%%%%: 7057-block  0
branch  0 never executed
branch  1 never executed
        -: 7058:      float f1;
        -: 7059:      // Exponent
    #####: 7060:      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
    %%%%%: 7060-block  0
branch  0 never executed
branch  1 never executed
    #####: 7061:      if (req_comp <= 2)
    %%%%%: 7061-block  0
branch  0 never executed
branch  1 never executed
    #####: 7062:         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
    %%%%%: 7062-block  0
        -: 7063:      else {
    #####: 7064:         output[0] = input[0] * f1;
    #####: 7065:         output[1] = input[1] * f1;
    #####: 7066:         output[2] = input[2] * f1;
    %%%%%: 7066-block  0
        -: 7067:      }
    #####: 7068:      if (req_comp == 2) output[1] = 1;
    %%%%%: 7068-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7068-block  1
    #####: 7069:      if (req_comp == 4) output[3] = 1;
    %%%%%: 7069-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7069-block  1
        -: 7070:   } else {
    #####: 7071:      switch (req_comp) {
    %%%%%: 7071-block  0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 7072:         case 4: output[3] = 1; /* fallthrough */
    %%%%%: 7072-block  0
    #####: 7073:         case 3: output[0] = output[1] = output[2] = 0;
    #####: 7074:                 break;
    %%%%%: 7074-block  0
    #####: 7075:         case 2: output[1] = 1; /* fallthrough */
    %%%%%: 7075-block  0
    #####: 7076:         case 1: output[0] = 0;
    #####: 7077:                 break;
    %%%%%: 7077-block  0
        -: 7078:      }
        -: 7079:   }
    #####: 7080:}
        -: 7081:
function _ZL14stbi__hdr_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 7082:static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 7083:{
        -: 7084:   char buffer[STBI__HDR_BUFLEN];
        -: 7085:   char *token;
        -: 7086:   int valid = 0;
        -: 7087:   int width, height;
        -: 7088:   stbi_uc *scanline;
        -: 7089:   float *hdr_data;
        -: 7090:   int len;
        -: 7091:   unsigned char count, value;
        -: 7092:   int i, j, k, c1,c2, z;
        -: 7093:   const char *headerToken;
        -: 7094:   STBI_NOTUSED(ri);
        -: 7095:
        -: 7096:   // Check identifier
    #####: 7097:   headerToken = stbi__hdr_gettoken(s,buffer);
    %%%%%: 7097-block  0
call    0 never executed
    #####: 7098:   if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)
branch  0 never executed
branch  1 never executed
    %%%%%: 7098-block  0
branch  2 never executed
branch  3 never executed
        -: 7099:      return stbi__errpf("not HDR", "Corrupt HDR image");
        -: 7100:
        -: 7101:   // Parse header
        -: 7102:   for(;;) {
    #####: 7103:      token = stbi__hdr_gettoken(s,buffer);
    %%%%%: 7103-block  0
call    0 never executed
    #####: 7104:      if (token[0] == 0) break;
branch  0 never executed
branch  1 never executed
    #####: 7105:      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
    %%%%%: 7105-block  0
branch  0 never executed
branch  1 never executed
        -: 7106:   }
        -: 7107:
    #####: 7108:   if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");
    %%%%%: 7108-block  0
branch  0 never executed
branch  1 never executed
        -: 7109:
        -: 7110:   // Parse width and height
        -: 7111:   // can't use sscanf() if we're not using stdio!
    #####: 7112:   token = stbi__hdr_gettoken(s,buffer);
    %%%%%: 7112-block  0
call    0 never executed
    #####: 7113:   if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
branch  0 never executed
branch  1 never executed
    #####: 7114:   token += 3;
    #####: 7115:   height = (int) strtol(token, &token, 10);
    %%%%%: 7115-block  0
call    0 never executed
    #####: 7116:   while (*token == ' ') ++token;
    %%%%%: 7116-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7116-block  1
    #####: 7117:   if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
    %%%%%: 7117-block  0
branch  0 never executed
branch  1 never executed
    #####: 7118:   token += 3;
    #####: 7119:   width = (int) strtol(token, NULL, 10);
    %%%%%: 7119-block  0
call    0 never executed
        -: 7120:
    #####: 7121:   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");
branch  0 never executed
branch  1 never executed
    #####: 7122:   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");
    %%%%%: 7122-block  0
branch  0 never executed
branch  1 never executed
        -: 7123:
    #####: 7124:   *x = width;
    #####: 7125:   *y = height;
        -: 7126:
    #####: 7127:   if (comp) *comp = 3;
    %%%%%: 7127-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7127-block  1
    #####: 7128:   if (req_comp == 0) req_comp = 3;
    %%%%%: 7128-block  0
branch  0 never executed
branch  1 never executed
        -: 7129:
    #####: 7130:   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
    %%%%%: 7130-block  0
branch  0 never executed
branch  1 never executed
        -: 7131:      return stbi__errpf("too large", "HDR image is too large");
        -: 7132:
        -: 7133:   // Read data
    #####: 7134:   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);
    %%%%%: 7134-block  0
call    0 never executed
    #####: 7135:   if (!hdr_data)
branch  0 never executed
branch  1 never executed
        -: 7136:      return stbi__errpf("outofmem", "Out of memory");
        -: 7137:
        -: 7138:   // Load image data
        -: 7139:   // image data is stored as some number of sca
    #####: 7140:   if ( width < 8 || width >= 32768) {
    %%%%%: 7140-block  0
branch  0 never executed
branch  1 never executed
        -: 7141:      // Read flat data
    #####: 7142:      for (j=0; j < height; ++j) {
    %%%%%: 7142-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7142-block  1
    #####: 7143:         for (i=0; i < width; ++i) {
    %%%%%: 7143-block  0
branch  0 never executed
branch  1 never executed
        -: 7144:            stbi_uc rgbe[4];
    #####: 7145:           main_decode_loop:
    %%%%%: 7145-block  0
    #####: 7146:            stbi__getn(s, rgbe, 4);
    %%%%%: 7146-block  0
call    0 never executed
    #####: 7147:            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
call    0 never executed
        -: 7148:         }
        -: 7149:      }
        -: 7150:   } else {
        -: 7151:      // Read RLE-encoded data
        -: 7152:      scanline = NULL;
        -: 7153:
    #####: 7154:      for (j = 0; j < height; ++j) {
    %%%%%: 7154-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7154-block  1
    #####: 7155:         c1 = stbi__get8(s);
    %%%%%: 7155-block  0
call    0 never executed
    #####: 7156:         c2 = stbi__get8(s);
call    0 never executed
    #####: 7157:         len = stbi__get8(s);
call    0 never executed
    #####: 7158:         if (c1 != 2 || c2 != 2 || (len & 0x80)) {
branch  0 never executed
branch  1 never executed
    %%%%%: 7158-block  0
branch  2 never executed
branch  3 never executed
        -: 7159:            // not run-length encoded, so we have to actually use THIS data as a decoded
        -: 7160:            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
        -: 7161:            stbi_uc rgbe[4];
    #####: 7162:            rgbe[0] = (stbi_uc) c1;
    #####: 7163:            rgbe[1] = (stbi_uc) c2;
    #####: 7164:            rgbe[2] = (stbi_uc) len;
    #####: 7165:            rgbe[3] = (stbi_uc) stbi__get8(s);
    %%%%%: 7165-block  0
call    0 never executed
    #####: 7166:            stbi__hdr_convert(hdr_data, rgbe, req_comp);
call    0 never executed
        -: 7167:            i = 1;
        -: 7168:            j = 0;
    #####: 7169:            STBI_FREE(scanline);
    #####: 7170:            goto main_decode_loop; // yes, this makes no sense
        -: 7171:         }
    #####: 7172:         len <<= 8;
    #####: 7173:         len |= stbi__get8(s);
    %%%%%: 7173-block  0
call    0 never executed
    #####: 7174:         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }
branch  0 never executed
branch  1 never executed
    %%%%%: 7174-block  0
    #####: 7175:         if (scanline == NULL) {
    %%%%%: 7175-block  0
branch  0 never executed
branch  1 never executed
    #####: 7176:            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);
    %%%%%: 7176-block  0
call    0 never executed
    #####: 7177:            if (!scanline) {
branch  0 never executed
branch  1 never executed
    #####: 7178:               STBI_FREE(hdr_data);
    #####: 7179:               return stbi__errpf("outofmem", "Out of memory");
    %%%%%: 7179-block  0
        -: 7180:            }
        -: 7181:         }
        -: 7182:
    #####: 7183:         for (k = 0; k < 4; ++k) {
    %%%%%: 7183-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7183-block  1
        -: 7184:            int nleft;
        -: 7185:            i = 0;
    #####: 7186:            while ((nleft = width - i) > 0) {
    %%%%%: 7186-block  0
branch  0 never executed
branch  1 never executed
    #####: 7187:               count = stbi__get8(s);
    %%%%%: 7187-block  0
call    0 never executed
    #####: 7188:               if (count > 128) {
branch  0 never executed
branch  1 never executed
        -: 7189:                  // Run
    #####: 7190:                  value = stbi__get8(s);
    %%%%%: 7190-block  0
call    0 never executed
    #####: 7191:                  count -= 128;
    #####: 7192:                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
branch  0 never executed
branch  1 never executed
    %%%%%: 7192-block  0
    #####: 7193:                  for (z = 0; z < count; ++z)
    %%%%%: 7193-block  0
branch  0 never executed
branch  1 never executed
    #####: 7194:                     scanline[i++ * 4 + k] = value;
    %%%%%: 7194-block  0
        -: 7195:               } else {
        -: 7196:                  // Dump
    #####: 7197:                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
    %%%%%: 7197-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7197-block  1
    #####: 7198:                  for (z = 0; z < count; ++z)
    %%%%%: 7198-block  0
branch  0 never executed
branch  1 never executed
    #####: 7199:                     scanline[i++ * 4 + k] = stbi__get8(s);
    %%%%%: 7199-block  0
call    0 never executed
        -: 7200:               }
        -: 7201:            }
        -: 7202:         }
    #####: 7203:         for (i=0; i < width; ++i)
    %%%%%: 7203-block  0
branch  0 never executed
branch  1 never executed
    #####: 7204:            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
    %%%%%: 7204-block  0
call    0 never executed
        -: 7205:      }
    #####: 7206:      if (scanline)
    %%%%%: 7206-block  0
branch  0 never executed
branch  1 never executed
    #####: 7207:         STBI_FREE(scanline);
    %%%%%: 7207-block  0
        -: 7208:   }
        -: 7209:
        -: 7210:   return hdr_data;
        -: 7211:}
        -: 7212:
function _ZL14stbi__hdr_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7213:static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
        -: 7214:{
        -: 7215:   char buffer[STBI__HDR_BUFLEN];
        -: 7216:   char *token;
        -: 7217:   int valid = 0;
        -: 7218:   int dummy;
        -: 7219:
    #####: 7220:   if (!x) x = &dummy;
    %%%%%: 7220-block  0
branch  0 never executed
branch  1 never executed
    #####: 7221:   if (!y) y = &dummy;
    %%%%%: 7221-block  0
branch  0 never executed
branch  1 never executed
    #####: 7222:   if (!comp) comp = &dummy;
    %%%%%: 7222-block  0
branch  0 never executed
branch  1 never executed
        -: 7223:
    #####: 7224:   if (stbi__hdr_test(s) == 0) {
    %%%%%: 7224-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7225:       stbi__rewind( s );
    #####: 7226:       return 0;
    %%%%%: 7226-block  0
        -: 7227:   }
        -: 7228:
        -: 7229:   for(;;) {
    #####: 7230:      token = stbi__hdr_gettoken(s,buffer);
    %%%%%: 7230-block  0
call    0 never executed
    #####: 7231:      if (token[0] == 0) break;
branch  0 never executed
branch  1 never executed
    #####: 7232:      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
    %%%%%: 7232-block  0
branch  0 never executed
branch  1 never executed
        -: 7233:   }
        -: 7234:
    #####: 7235:   if (!valid) {
    %%%%%: 7235-block  0
branch  0 never executed
branch  1 never executed
        -: 7236:       stbi__rewind( s );
    #####: 7237:       return 0;
    %%%%%: 7237-block  0
        -: 7238:   }
    #####: 7239:   token = stbi__hdr_gettoken(s,buffer);
    %%%%%: 7239-block  0
call    0 never executed
    #####: 7240:   if (strncmp(token, "-Y ", 3)) {
branch  0 never executed
branch  1 never executed
        -: 7241:       stbi__rewind( s );
    #####: 7242:       return 0;
    %%%%%: 7242-block  0
        -: 7243:   }
    #####: 7244:   token += 3;
    #####: 7245:   *y = (int) strtol(token, &token, 10);
    %%%%%: 7245-block  0
call    0 never executed
    #####: 7246:   while (*token == ' ') ++token;
    %%%%%: 7246-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7246-block  1
    #####: 7247:   if (strncmp(token, "+X ", 3)) {
    %%%%%: 7247-block  0
branch  0 never executed
branch  1 never executed
        -: 7248:       stbi__rewind( s );
    #####: 7249:       return 0;
    %%%%%: 7249-block  0
        -: 7250:   }
    #####: 7251:   token += 3;
    #####: 7252:   *x = (int) strtol(token, NULL, 10);
    %%%%%: 7252-block  0
call    0 never executed
    #####: 7253:   *comp = 3;
    #####: 7254:   return 1;
        -: 7255:}
        -: 7256:#endif // STBI_NO_HDR
        -: 7257:
        -: 7258:#ifndef STBI_NO_BMP
function _ZL14stbi__bmp_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7259:static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
        -: 7260:{
        -: 7261:   void *p;
        -: 7262:   stbi__bmp_data info;
        -: 7263:
    #####: 7264:   info.all_a = 255;
    #####: 7265:   p = stbi__bmp_parse_header(s, &info);
    %%%%%: 7265-block  0
call    0 never executed
    #####: 7266:   if (p == NULL) {
branch  0 never executed
branch  1 never executed
        -: 7267:      stbi__rewind( s );
    #####: 7268:      return 0;
    %%%%%: 7268-block  0
        -: 7269:   }
    #####: 7270:   if (x) *x = s->img_x;
    %%%%%: 7270-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7270-block  1
    #####: 7271:   if (y) *y = s->img_y;
    %%%%%: 7271-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7271-block  1
    #####: 7272:   if (comp) {
    %%%%%: 7272-block  0
branch  0 never executed
branch  1 never executed
    #####: 7273:      if (info.bytes_per_pixel == 24 && info.ma == 0xff000000)
    %%%%%: 7273-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7273-block  1
branch  2 never executed
branch  3 never executed
    #####: 7274:         *comp = 3;
    %%%%%: 7274-block  0
        -: 7275:      else
    #####: 7276:         *comp = info.ma ? 4 : 3;
    %%%%%: 7276-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7276-block  1
        -: 7277:   }
        -: 7278:   return 1;
        -: 7279:}
        -: 7280:#endif
        -: 7281:
        -: 7282:#ifndef STBI_NO_PSD
function _ZL14stbi__psd_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7283:static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
        -: 7284:{
        -: 7285:   int channelCount, dummy, depth;
    #####: 7286:   if (!x) x = &dummy;
    %%%%%: 7286-block  0
branch  0 never executed
branch  1 never executed
    #####: 7287:   if (!y) y = &dummy;
    %%%%%: 7287-block  0
branch  0 never executed
branch  1 never executed
    #####: 7288:   if (!comp) comp = &dummy;
    %%%%%: 7288-block  0
branch  0 never executed
branch  1 never executed
    #####: 7289:   if (stbi__get32be(s) != 0x38425053) {
    %%%%%: 7289-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7290:       stbi__rewind( s );
    #####: 7291:       return 0;
    %%%%%: 7291-block  0
        -: 7292:   }
    #####: 7293:   if (stbi__get16be(s) != 1) {
    %%%%%: 7293-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7294:       stbi__rewind( s );
    #####: 7295:       return 0;
    %%%%%: 7295-block  0
        -: 7296:   }
        -: 7297:   stbi__skip(s, 6);
    #####: 7298:   channelCount = stbi__get16be(s);
    %%%%%: 7298-block  0
call    0 never executed
    #####: 7299:   if (channelCount < 0 || channelCount > 16) {
branch  0 never executed
branch  1 never executed
        -: 7300:       stbi__rewind( s );
    #####: 7301:       return 0;
    %%%%%: 7301-block  0
        -: 7302:   }
    #####: 7303:   *y = stbi__get32be(s);
    %%%%%: 7303-block  0
call    0 never executed
    #####: 7304:   *x = stbi__get32be(s);
call    0 never executed
    #####: 7305:   depth = stbi__get16be(s);
call    0 never executed
    #####: 7306:   if (depth != 8 && depth != 16) {
branch  0 never executed
branch  1 never executed
        -: 7307:       stbi__rewind( s );
    #####: 7308:       return 0;
    %%%%%: 7308-block  0
        -: 7309:   }
    #####: 7310:   if (stbi__get16be(s) != 3) {
    %%%%%: 7310-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7311:       stbi__rewind( s );
    #####: 7312:       return 0;
    %%%%%: 7312-block  0
        -: 7313:   }
    #####: 7314:   *comp = 4;
    #####: 7315:   return 1;
    %%%%%: 7315-block  0
        -: 7316:}
        -: 7317:
function _ZL14stbi__psd_is16P13stbi__context called 0 returned 0% blocks executed 0%
    #####: 7318:static int stbi__psd_is16(stbi__context *s)
        -: 7319:{
        -: 7320:   int channelCount, depth;
    #####: 7321:   if (stbi__get32be(s) != 0x38425053) {
    %%%%%: 7321-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7322:       stbi__rewind( s );
    #####: 7323:       return 0;
    %%%%%: 7323-block  0
        -: 7324:   }
    #####: 7325:   if (stbi__get16be(s) != 1) {
    %%%%%: 7325-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7326:       stbi__rewind( s );
    #####: 7327:       return 0;
    %%%%%: 7327-block  0
        -: 7328:   }
        -: 7329:   stbi__skip(s, 6);
    #####: 7330:   channelCount = stbi__get16be(s);
    %%%%%: 7330-block  0
call    0 never executed
    #####: 7331:   if (channelCount < 0 || channelCount > 16) {
branch  0 never executed
branch  1 never executed
        -: 7332:       stbi__rewind( s );
    #####: 7333:       return 0;
    %%%%%: 7333-block  0
        -: 7334:   }
        -: 7335:   STBI_NOTUSED(stbi__get32be(s));
        -: 7336:   STBI_NOTUSED(stbi__get32be(s));
    #####: 7337:   depth = stbi__get16be(s);
    %%%%%: 7337-block  0
call    0 never executed
    #####: 7338:   if (depth != 16) {
branch  0 never executed
branch  1 never executed
        -: 7339:       stbi__rewind( s );
    #####: 7340:       return 0;
    %%%%%: 7340-block  0
        -: 7341:   }
        -: 7342:   return 1;
        -: 7343:}
        -: 7344:#endif
        -: 7345:
        -: 7346:#ifndef STBI_NO_PIC
function _ZL14stbi__pic_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7347:static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
        -: 7348:{
        -: 7349:   int act_comp=0,num_packets=0,chained,dummy;
        -: 7350:   stbi__pic_packet packets[10];
        -: 7351:
    #####: 7352:   if (!x) x = &dummy;
    %%%%%: 7352-block  0
branch  0 never executed
branch  1 never executed
    #####: 7353:   if (!y) y = &dummy;
    %%%%%: 7353-block  0
branch  0 never executed
branch  1 never executed
    #####: 7354:   if (!comp) comp = &dummy;
    %%%%%: 7354-block  0
branch  0 never executed
branch  1 never executed
        -: 7355:
    #####: 7356:   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34")) {
    %%%%%: 7356-block  0
branch  0 never executed
branch  1 never executed
        -: 7357:      stbi__rewind(s);
    #####: 7358:      return 0;
    %%%%%: 7358-block  0
        -: 7359:   }
        -: 7360:
        -: 7361:   stbi__skip(s, 88);
        -: 7362:
    #####: 7363:   *x = stbi__get16be(s);
    %%%%%: 7363-block  0
call    0 never executed
    #####: 7364:   *y = stbi__get16be(s);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 7365:   if (stbi__at_eof(s)) {
    %%%%%: 7365-block  0
branch  0 never executed
branch  1 never executed
        -: 7366:      stbi__rewind( s);
    #####: 7367:      return 0;
    %%%%%: 7367-block  0
        -: 7368:   }
    #####: 7369:   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
    %%%%%: 7369-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7369-block  1
branch  2 never executed
branch  3 never executed
        -: 7370:      stbi__rewind( s );
    #####: 7371:      return 0;
    %%%%%: 7371-block  0
        -: 7372:   }
        -: 7373:
        -: 7374:   stbi__skip(s, 8);
        -: 7375:
        -: 7376:   do {
        -: 7377:      stbi__pic_packet *packet;
        -: 7378:
    #####: 7379:      if (num_packets==sizeof(packets)/sizeof(packets[0]))
    %%%%%: 7379-block  0
branch  0 never executed
branch  1 never executed
        -: 7380:         return 0;
        -: 7381:
    #####: 7382:      packet = &packets[num_packets++];
    #####: 7383:      chained = stbi__get8(s);
    %%%%%: 7383-block  0
call    0 never executed
    #####: 7384:      packet->size    = stbi__get8(s);
call    0 never executed
    #####: 7385:      packet->type    = stbi__get8(s);
call    0 never executed
    #####: 7386:      packet->channel = stbi__get8(s);
call    0 never executed
    #####: 7387:      act_comp |= packet->channel;
branch  0 never executed
branch  1 never executed
        -: 7388:
    #####: 7389:      if (stbi__at_eof(s)) {
    %%%%%: 7389-block  0
branch  0 never executed
branch  1 never executed
        -: 7390:          stbi__rewind( s );
    #####: 7391:          return 0;
    %%%%%: 7391-block  0
        -: 7392:      }
    #####: 7393:      if (packet->size != 8) {
    %%%%%: 7393-block  0
branch  0 never executed
branch  1 never executed
        -: 7394:          stbi__rewind( s );
    #####: 7395:          return 0;
    %%%%%: 7395-block  0
        -: 7396:      }
    #####: 7397:   } while (chained);
    %%%%%: 7397-block  0
branch  0 never executed
branch  1 never executed
        -: 7398:
    #####: 7399:   *comp = (act_comp & 0x10 ? 4 : 3);
    %%%%%: 7399-block  0
branch  0 never executed
branch  1 never executed
        -: 7400:
    #####: 7401:   return 1;
    %%%%%: 7401-block  0
        -: 7402:}
        -: 7403:#endif
        -: 7404:
        -: 7405:// *************************************************************************************************
        -: 7406:// Portable Gray Map and Portable Pixel Map loader
        -: 7407:// by Ken Miller
        -: 7408://
        -: 7409:// PGM: http://netpbm.sourceforge.net/doc/pgm.html
        -: 7410:// PPM: http://netpbm.sourceforge.net/doc/ppm.html
        -: 7411://
        -: 7412:// Known limitations:
        -: 7413://    Does not support comments in the header section
        -: 7414://    Does not support ASCII image data (formats P2 and P3)
        -: 7415:
        -: 7416:#ifndef STBI_NO_PNM
        -: 7417:
function _ZL14stbi__pnm_testP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 7418:static int      stbi__pnm_test(stbi__context *s)
        -: 7419:{
        -: 7420:   char p, t;
    #####: 7421:   p = (char) stbi__get8(s);
    %%%%%: 7421-block  0
call    0 never executed
    #####: 7422:   t = (char) stbi__get8(s);
call    0 never executed
    #####: 7423:   if (p != 'P' || (t != '5' && t != '6')) {
branch  0 never executed
branch  1 never executed
    %%%%%: 7423-block  0
branch  2 never executed
branch  3 never executed
        -: 7424:       stbi__rewind( s );
    #####: 7425:       return 0;
    %%%%%: 7425-block  0
        -: 7426:   }
        -: 7427:   return 1;
        -: 7428:}
        -: 7429:
function _ZL14stbi__pnm_loadP13stbi__contextPiS1_S1_iP17stbi__result_info called 0 returned 0% blocks executed 0%
    #####: 7430:static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
        -: 7431:{
        -: 7432:   stbi_uc *out;
        -: 7433:   STBI_NOTUSED(ri);
        -: 7434:
    #####: 7435:   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);
    %%%%%: 7435-block  0
call    0 never executed
    #####: 7436:   if (ri->bits_per_channel == 0)
branch  0 never executed
branch  1 never executed
        -: 7437:      return 0;
        -: 7438:
    #####: 7439:   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 7439-block  0
branch  0 never executed
branch  1 never executed
    #####: 7440:   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
    %%%%%: 7440-block  0
branch  0 never executed
branch  1 never executed
        -: 7441:
    #####: 7442:   *x = s->img_x;
    #####: 7443:   *y = s->img_y;
    #####: 7444:   if (comp) *comp = s->img_n;
    %%%%%: 7444-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7444-block  1
        -: 7445:
    #####: 7446:   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))
    %%%%%: 7446-block  0
branch  0 never executed
branch  1 never executed
        -: 7447:      return stbi__errpuc("too large", "PNM too large");
        -: 7448:
    #####: 7449:   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);
    %%%%%: 7449-block  0
call    0 never executed
    #####: 7450:   if (!out) return stbi__errpuc("outofmem", "Out of memory");
branch  0 never executed
branch  1 never executed
    #####: 7451:   stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8));
    %%%%%: 7451-block  0
call    0 never executed
        -: 7452:
    #####: 7453:   if (req_comp && req_comp != s->img_n) {
branch  0 never executed
branch  1 never executed
    %%%%%: 7453-block  0
branch  2 never executed
branch  3 never executed
    #####: 7454:      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
    %%%%%: 7454-block  0
call    0 never executed
    #####: 7455:      if (out == NULL) return out; // stbi__convert_format frees input on failure
branch  0 never executed
branch  1 never executed
    %%%%%: 7455-block  0
        -: 7456:   }
        -: 7457:   return out;
        -: 7458:}
        -: 7459:
        -: 7460:static int      stbi__pnm_isspace(char c)
        -: 7461:{
    #####: 7462:   return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
    %%%%%: 7462-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7462-block  1
branch  2 never executed
branch  3 never executed
        -: 7463:}
        -: 7464:
function _ZL25stbi__pnm_skip_whitespaceP13stbi__contextPc called 0 returned 0% blocks executed 0%
    #####: 7465:static void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)
    %%%%%: 7465-block  0
        -: 7466:{
        -: 7467:   for (;;) {
    #####: 7468:      while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))
    %%%%%: 7468-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7468-block  1
branch  2 never executed
branch  3 never executed
    #####: 7469:         *c = (char) stbi__get8(s);
    %%%%%: 7469-block  0
call    0 never executed
        -: 7470:
    #####: 7471:      if (stbi__at_eof(s) || *c != '#')
    %%%%%: 7471-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7471-block  1
branch  2 never executed
branch  3 never executed
        -: 7472:         break;
        -: 7473:
    #####: 7474:      while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )
    %%%%%: 7474-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7474-block  1
branch  2 never executed
branch  3 never executed
    %%%%%: 7474-block  2
branch  4 never executed
branch  5 never executed
    #####: 7475:         *c = (char) stbi__get8(s);
    %%%%%: 7475-block  0
call    0 never executed
        -: 7476:   }
    #####: 7477:}
        -: 7478:
        -: 7479:static int      stbi__pnm_isdigit(char c)
        -: 7480:{
    #####: 7481:   return c >= '0' && c <= '9';
        -: 7482:}
        -: 7483:
function _ZL20stbi__pnm_getintegerP13stbi__contextPc called 0 returned 0% blocks executed 0%
    #####: 7484:static int      stbi__pnm_getinteger(stbi__context *s, char *c)
    %%%%%: 7484-block  0
        -: 7485:{
        -: 7486:   int value = 0;
        -: 7487:
    #####: 7488:   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
    %%%%%: 7488-block  0
branch  0 never executed
branch  1 never executed
    %%%%%: 7488-block  1
branch  2 never executed
branch  3 never executed
    #####: 7489:      value = value*10 + (*c - '0');
    #####: 7490:      *c = (char) stbi__get8(s);
    %%%%%: 7490-block  0
call    0 never executed
        -: 7491:   }
        -: 7492:
    #####: 7493:   return value;
    %%%%%: 7493-block  0
        -: 7494:}
        -: 7495:
function _ZL14stbi__pnm_infoP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7496:static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
        -: 7497:{
        -: 7498:   int maxv, dummy;
        -: 7499:   char c, p, t;
        -: 7500:
    #####: 7501:   if (!x) x = &dummy;
    %%%%%: 7501-block  0
branch  0 never executed
branch  1 never executed
    #####: 7502:   if (!y) y = &dummy;
    %%%%%: 7502-block  0
branch  0 never executed
branch  1 never executed
    #####: 7503:   if (!comp) comp = &dummy;
    %%%%%: 7503-block  0
branch  0 never executed
branch  1 never executed
        -: 7504:
        -: 7505:   stbi__rewind(s);
        -: 7506:
        -: 7507:   // Get identifier
    #####: 7508:   p = (char) stbi__get8(s);
    %%%%%: 7508-block  0
call    0 never executed
    #####: 7509:   t = (char) stbi__get8(s);
call    0 never executed
    #####: 7510:   if (p != 'P' || (t != '5' && t != '6')) {
branch  0 never executed
branch  1 never executed
    %%%%%: 7510-block  0
branch  2 never executed
branch  3 never executed
        -: 7511:       stbi__rewind(s);
    #####: 7512:       return 0;
    %%%%%: 7512-block  0
        -: 7513:   }
        -: 7514:
    #####: 7515:   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm
    %%%%%: 7515-block  0
branch  0 never executed
branch  1 never executed
        -: 7516:
    #####: 7517:   c = (char) stbi__get8(s);
    %%%%%: 7517-block  0
call    0 never executed
    #####: 7518:   stbi__pnm_skip_whitespace(s, &c);
call    0 never executed
        -: 7519:
    #####: 7520:   *x = stbi__pnm_getinteger(s, &c); // read width
call    0 never executed
    #####: 7521:   stbi__pnm_skip_whitespace(s, &c);
call    0 never executed
        -: 7522:
    #####: 7523:   *y = stbi__pnm_getinteger(s, &c); // read height
call    0 never executed
    #####: 7524:   stbi__pnm_skip_whitespace(s, &c);
call    0 never executed
        -: 7525:
    #####: 7526:   maxv = stbi__pnm_getinteger(s, &c);  // read max value
call    0 never executed
    #####: 7527:   if (maxv > 65535)
branch  0 never executed
branch  1 never executed
        -: 7528:      return stbi__err("max value > 65535", "PPM image supports only 8-bit and 16-bit images");
    #####: 7529:   else if (maxv > 255)
    %%%%%: 7529-block  0
branch  0 never executed
branch  1 never executed
        -: 7530:      return 16;
        -: 7531:   else
    #####: 7532:      return 8;
    %%%%%: 7532-block  0
        -: 7533:}
        -: 7534:
        -: 7535:static int stbi__pnm_is16(stbi__context *s)
        -: 7536:{
    #####: 7537:   if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)
    %%%%%: 7537-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7538:	   return 1;
        -: 7539:   return 0;
        -: 7540:}
        -: 7541:#endif
        -: 7542:
function _ZL15stbi__info_mainP13stbi__contextPiS1_S1_ called 0 returned 0% blocks executed 0%
    #####: 7543:static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
        -: 7544:{
        -: 7545:   #ifndef STBI_NO_JPEG
    #####: 7546:   if (stbi__jpeg_info(s, x, y, comp)) return 1;
    %%%%%: 7546-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7547:   #endif
        -: 7548:
        -: 7549:   #ifndef STBI_NO_PNG
    #####: 7550:   if (stbi__png_info(s, x, y, comp))  return 1;
branch  0 never executed
branch  1 never executed
        -: 7551:   #endif
        -: 7552:
        -: 7553:   #ifndef STBI_NO_GIF
    #####: 7554:   if (stbi__gif_info(s, x, y, comp))  return 1;
branch  0 never executed
branch  1 never executed
        -: 7555:   #endif
        -: 7556:
        -: 7557:   #ifndef STBI_NO_BMP
    #####: 7558:   if (stbi__bmp_info(s, x, y, comp))  return 1;
    %%%%%: 7558-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7559:   #endif
        -: 7560:
        -: 7561:   #ifndef STBI_NO_PSD
    #####: 7562:   if (stbi__psd_info(s, x, y, comp))  return 1;
    %%%%%: 7562-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7563:   #endif
        -: 7564:
        -: 7565:   #ifndef STBI_NO_PIC
    #####: 7566:   if (stbi__pic_info(s, x, y, comp))  return 1;
    %%%%%: 7566-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7567:   #endif
        -: 7568:
        -: 7569:   #ifndef STBI_NO_PNM
    #####: 7570:   if (stbi__pnm_info(s, x, y, comp))  return 1;
    %%%%%: 7570-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7571:   #endif
        -: 7572:
        -: 7573:   #ifndef STBI_NO_HDR
    #####: 7574:   if (stbi__hdr_info(s, x, y, comp))  return 1;
    %%%%%: 7574-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7575:   #endif
        -: 7576:
        -: 7577:   // test tga last because it's a crappy test!
        -: 7578:   #ifndef STBI_NO_TGA
    #####: 7579:   if (stbi__tga_info(s, x, y, comp))
    %%%%%: 7579-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 7580:       return 1;
    %%%%%: 7580-block  0
        -: 7581:   #endif
        -: 7582:   return stbi__err("unknown image type", "Image not of any known type, or corrupt");
        -: 7583:}
        -: 7584:
function _ZL16stbi__is_16_mainP13stbi__context called 0 returned 0% blocks executed 0%
    #####: 7585:static int stbi__is_16_main(stbi__context *s)
        -: 7586:{
        -: 7587:   #ifndef STBI_NO_PNG
    #####: 7588:   if (stbi__png_is16(s))  return 1;
    %%%%%: 7588-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7589:   #endif
        -: 7590:
        -: 7591:   #ifndef STBI_NO_PSD
    #####: 7592:   if (stbi__psd_is16(s))  return 1;
    %%%%%: 7592-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7593:   #endif
        -: 7594:
        -: 7595:   #ifndef STBI_NO_PNM
    #####: 7596:   if (stbi__pnm_is16(s))  return 1;
    %%%%%: 7596-block  0
        -: 7597:   #endif
        -: 7598:   return 0;
        -: 7599:}
        -: 7600:
        -: 7601:#ifndef STBI_NO_STDIO
function stbi_info called 0 returned 0% blocks executed 0%
    #####: 7602:STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)
    %%%%%: 7602-block  0
call    0 never executed
        -: 7603:{
        -: 7604:    FILE *f = stbi__fopen(filename, "rb");
        -: 7605:    int result;
    #####: 7606:    if (!f) return stbi__err("can't fopen", "Unable to open file");
branch  0 never executed
branch  1 never executed
    #####: 7607:    result = stbi_info_from_file(f, x, y, comp);
    %%%%%: 7607-block  0
call    0 never executed
    #####: 7608:    fclose(f);
call    0 never executed
    #####: 7609:    return result;
        -: 7610:}
        -: 7611:
function stbi_info_from_file called 0 returned 0% blocks executed 0%
    #####: 7612:STBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
        -: 7613:{
        -: 7614:   int r;
        -: 7615:   stbi__context s;
    #####: 7616:   long pos = ftell(f);
    %%%%%: 7616-block  0
call    0 never executed
        -: 7617:   stbi__start_file(&s, f);
    #####: 7618:   r = stbi__info_main(&s,x,y,comp);
call    0 never executed
    #####: 7619:   fseek(f,pos,SEEK_SET);
call    0 never executed
    #####: 7620:   return r;
        -: 7621:}
        -: 7622:
function stbi_is_16_bit called 0 returned 0% blocks executed 0%
    #####: 7623:STBIDEF int stbi_is_16_bit(char const *filename)
    %%%%%: 7623-block  0
call    0 never executed
        -: 7624:{
        -: 7625:    FILE *f = stbi__fopen(filename, "rb");
        -: 7626:    int result;
    #####: 7627:    if (!f) return stbi__err("can't fopen", "Unable to open file");
branch  0 never executed
branch  1 never executed
    #####: 7628:    result = stbi_is_16_bit_from_file(f);
    %%%%%: 7628-block  0
call    0 never executed
    #####: 7629:    fclose(f);
call    0 never executed
    #####: 7630:    return result;
        -: 7631:}
        -: 7632:
function stbi_is_16_bit_from_file called 0 returned 0% blocks executed 0%
    #####: 7633:STBIDEF int stbi_is_16_bit_from_file(FILE *f)
        -: 7634:{
        -: 7635:   int r;
        -: 7636:   stbi__context s;
    #####: 7637:   long pos = ftell(f);
    %%%%%: 7637-block  0
call    0 never executed
        -: 7638:   stbi__start_file(&s, f);
    #####: 7639:   r = stbi__is_16_main(&s);
call    0 never executed
    #####: 7640:   fseek(f,pos,SEEK_SET);
call    0 never executed
    #####: 7641:   return r;
        -: 7642:}
        -: 7643:#endif // !STBI_NO_STDIO
        -: 7644:
function stbi_info_from_memory called 0 returned 0% blocks executed 0%
    #####: 7645:STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
        -: 7646:{
        -: 7647:   stbi__context s;
        -: 7648:   stbi__start_mem(&s,buffer,len);
    #####: 7649:   return stbi__info_main(&s,x,y,comp);
    %%%%%: 7649-block  0
call    0 never executed
        -: 7650:}
        -: 7651:
function stbi_info_from_callbacks called 0 returned 0% blocks executed 0%
    #####: 7652:STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
    %%%%%: 7652-block  0
call    0 never executed
        -: 7653:{
        -: 7654:   stbi__context s;
        -: 7655:   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
    #####: 7656:   return stbi__info_main(&s,x,y,comp);
call    0 never executed
        -: 7657:}
        -: 7658:
function stbi_is_16_bit_from_memory called 0 returned 0% blocks executed 0%
    #####: 7659:STBIDEF int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len)
        -: 7660:{
        -: 7661:   stbi__context s;
        -: 7662:   stbi__start_mem(&s,buffer,len);
    #####: 7663:   return stbi__is_16_main(&s);
    %%%%%: 7663-block  0
call    0 never executed
        -: 7664:}
        -: 7665:
function stbi_is_16_bit_from_callbacks called 0 returned 0% blocks executed 0%
    #####: 7666:STBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *c, void *user)
    %%%%%: 7666-block  0
call    0 never executed
        -: 7667:{
        -: 7668:   stbi__context s;
        -: 7669:   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
    #####: 7670:   return stbi__is_16_main(&s);
call    0 never executed
        -: 7671:}
        -: 7672:
        -: 7673:#endif // STB_IMAGE_IMPLEMENTATION
        -: 7674:
        -: 7675:/*
        -: 7676:   revision history:
        -: 7677:      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
        -: 7678:      2.19  (2018-02-11) fix warning
        -: 7679:      2.18  (2018-01-30) fix warnings
        -: 7680:      2.17  (2018-01-29) change sbti__shiftsigned to avoid clang -O2 bug
        -: 7681:                         1-bit BMP
        -: 7682:                         *_is_16_bit api
        -: 7683:                         avoid warnings
        -: 7684:      2.16  (2017-07-23) all functions have 16-bit variants;
        -: 7685:                         STBI_NO_STDIO works again;
        -: 7686:                         compilation fixes;
        -: 7687:                         fix rounding in unpremultiply;
        -: 7688:                         optimize vertical flip;
        -: 7689:                         disable raw_len validation;
        -: 7690:                         documentation fixes
        -: 7691:      2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;
        -: 7692:                         warning fixes; disable run-time SSE detection on gcc;
        -: 7693:                         uniform handling of optional "return" values;
        -: 7694:                         thread-safe initialization of zlib tables
        -: 7695:      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
        -: 7696:      2.13  (2016-11-29) add 16-bit API, only supported for PNG right now
        -: 7697:      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
        -: 7698:      2.11  (2016-04-02) allocate large structures on the stack
        -: 7699:                         remove white matting for transparent PSD
        -: 7700:                         fix reported channel count for PNG & BMP
        -: 7701:                         re-enable SSE2 in non-gcc 64-bit
        -: 7702:                         support RGB-formatted JPEG
        -: 7703:                         read 16-bit PNGs (only as 8-bit)
        -: 7704:      2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED
        -: 7705:      2.09  (2016-01-16) allow comments in PNM files
        -: 7706:                         16-bit-per-pixel TGA (not bit-per-component)
        -: 7707:                         info() for TGA could break due to .hdr handling
        -: 7708:                         info() for BMP to shares code instead of sloppy parse
        -: 7709:                         can use STBI_REALLOC_SIZED if allocator doesn't support realloc
        -: 7710:                         code cleanup
        -: 7711:      2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA
        -: 7712:      2.07  (2015-09-13) fix compiler warnings
        -: 7713:                         partial animated GIF support
        -: 7714:                         limited 16-bpc PSD support
        -: 7715:                         #ifdef unused functions
        -: 7716:                         bug with < 92 byte PIC,PNM,HDR,TGA
        -: 7717:      2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
        -: 7718:      2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
        -: 7719:      2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
        -: 7720:      2.03  (2015-04-12) extra corruption checking (mmozeiko)
        -: 7721:                         stbi_set_flip_vertically_on_load (nguillemot)
        -: 7722:                         fix NEON support; fix mingw support
        -: 7723:      2.02  (2015-01-19) fix incorrect assert, fix warning
        -: 7724:      2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2
        -: 7725:      2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
        -: 7726:      2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)
        -: 7727:                         progressive JPEG (stb)
        -: 7728:                         PGM/PPM support (Ken Miller)
        -: 7729:                         STBI_MALLOC,STBI_REALLOC,STBI_FREE
        -: 7730:                         GIF bugfix -- seemingly never worked
        -: 7731:                         STBI_NO_*, STBI_ONLY_*
        -: 7732:      1.48  (2014-12-14) fix incorrectly-named assert()
        -: 7733:      1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)
        -: 7734:                         optimize PNG (ryg)
        -: 7735:                         fix bug in interlaced PNG with user-specified channel count (stb)
        -: 7736:      1.46  (2014-08-26)
        -: 7737:              fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG
        -: 7738:      1.45  (2014-08-16)
        -: 7739:              fix MSVC-ARM internal compiler error by wrapping malloc
        -: 7740:      1.44  (2014-08-07)
        -: 7741:              various warning fixes from Ronny Chevalier
        -: 7742:      1.43  (2014-07-15)
        -: 7743:              fix MSVC-only compiler problem in code changed in 1.42
        -: 7744:      1.42  (2014-07-09)
        -: 7745:              don't define _CRT_SECURE_NO_WARNINGS (affects user code)
        -: 7746:              fixes to stbi__cleanup_jpeg path
        -: 7747:              added STBI_ASSERT to avoid requiring assert.h
        -: 7748:      1.41  (2014-06-25)
        -: 7749:              fix search&replace from 1.36 that messed up comments/error messages
        -: 7750:      1.40  (2014-06-22)
        -: 7751:              fix gcc struct-initialization warning
        -: 7752:      1.39  (2014-06-15)
        -: 7753:              fix to TGA optimization when req_comp != number of components in TGA;
        -: 7754:              fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)
        -: 7755:              add support for BMP version 5 (more ignored fields)
        -: 7756:      1.38  (2014-06-06)
        -: 7757:              suppress MSVC warnings on integer casts truncating values
        -: 7758:              fix accidental rename of 'skip' field of I/O
        -: 7759:      1.37  (2014-06-04)
        -: 7760:              remove duplicate typedef
        -: 7761:      1.36  (2014-06-03)
        -: 7762:              convert to header file single-file library
        -: 7763:              if de-iphone isn't set, load iphone images color-swapped instead of returning NULL
        -: 7764:      1.35  (2014-05-27)
        -: 7765:              various warnings
        -: 7766:              fix broken STBI_SIMD path
        -: 7767:              fix bug where stbi_load_from_file no longer left file pointer in correct place
        -: 7768:              fix broken non-easy path for 32-bit BMP (possibly never used)
        -: 7769:              TGA optimization by Arseny Kapoulkine
        -: 7770:      1.34  (unknown)
        -: 7771:              use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case
        -: 7772:      1.33  (2011-07-14)
        -: 7773:              make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
        -: 7774:      1.32  (2011-07-13)
        -: 7775:              support for "info" function for all supported filetypes (SpartanJ)
        -: 7776:      1.31  (2011-06-20)
        -: 7777:              a few more leak fixes, bug in PNG handling (SpartanJ)
        -: 7778:      1.30  (2011-06-11)
        -: 7779:              added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
        -: 7780:              removed deprecated format-specific test/load functions
        -: 7781:              removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
        -: 7782:              error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
        -: 7783:              fix inefficiency in decoding 32-bit BMP (David Woo)
        -: 7784:      1.29  (2010-08-16)
        -: 7785:              various warning fixes from Aurelien Pocheville
        -: 7786:      1.28  (2010-08-01)
        -: 7787:              fix bug in GIF palette transparency (SpartanJ)
        -: 7788:      1.27  (2010-08-01)
        -: 7789:              cast-to-stbi_uc to fix warnings
        -: 7790:      1.26  (2010-07-24)
        -: 7791:              fix bug in file buffering for PNG reported by SpartanJ
        -: 7792:      1.25  (2010-07-17)
        -: 7793:              refix trans_data warning (Won Chun)
        -: 7794:      1.24  (2010-07-12)
        -: 7795:              perf improvements reading from files on platforms with lock-heavy fgetc()
        -: 7796:              minor perf improvements for jpeg
        -: 7797:              deprecated type-specific functions so we'll get feedback if they're needed
        -: 7798:              attempt to fix trans_data warning (Won Chun)
        -: 7799:      1.23    fixed bug in iPhone support
        -: 7800:      1.22  (2010-07-10)
        -: 7801:              removed image *writing* support
        -: 7802:              stbi_info support from Jetro Lauha
        -: 7803:              GIF support from Jean-Marc Lienher
        -: 7804:              iPhone PNG-extensions from James Brown
        -: 7805:              warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)
        -: 7806:      1.21    fix use of 'stbi_uc' in header (reported by jon blow)
        -: 7807:      1.20    added support for Softimage PIC, by Tom Seddon
        -: 7808:      1.19    bug in interlaced PNG corruption check (found by ryg)
        -: 7809:      1.18  (2008-08-02)
        -: 7810:              fix a threading bug (local mutable static)
        -: 7811:      1.17    support interlaced PNG
        -: 7812:      1.16    major bugfix - stbi__convert_format converted one too many pixels
        -: 7813:      1.15    initialize some fields for thread safety
        -: 7814:      1.14    fix threadsafe conversion bug
        -: 7815:              header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
        -: 7816:      1.13    threadsafe
        -: 7817:      1.12    const qualifiers in the API
        -: 7818:      1.11    Support installable IDCT, colorspace conversion routines
        -: 7819:      1.10    Fixes for 64-bit (don't use "unsigned long")
        -: 7820:              optimized upsampling by Fabian "ryg" Giesen
        -: 7821:      1.09    Fix format-conversion for PSD code (bad global variables!)
        -: 7822:      1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz
        -: 7823:      1.07    attempt to fix C++ warning/errors again
        -: 7824:      1.06    attempt to fix C++ warning/errors again
        -: 7825:      1.05    fix TGA loading to return correct *comp and use good luminance calc
        -: 7826:      1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free
        -: 7827:      1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR
        -: 7828:      1.02    support for (subset of) HDR files, float interface for preferred access to them
        -: 7829:      1.01    fix bug: possible bug in handling right-side up bmps... not sure
        -: 7830:              fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all
        -: 7831:      1.00    interface to zlib that skips zlib header
        -: 7832:      0.99    correct handling of alpha in palette
        -: 7833:      0.98    TGA loader by lonesock; dynamically add loaders (untested)
        -: 7834:      0.97    jpeg errors on too large a file; also catch another malloc failure
        -: 7835:      0.96    fix detection of invalid v value - particleman@mollyrocket forum
        -: 7836:      0.95    during header scan, seek to markers in case of padding
        -: 7837:      0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same
        -: 7838:      0.93    handle jpegtran output; verbose errors
        -: 7839:      0.92    read 4,8,16,24,32-bit BMP files of several formats
        -: 7840:      0.91    output 24-bit Windows 3.0 BMP files
        -: 7841:      0.90    fix a few more warnings; bump version number to approach 1.0
        -: 7842:      0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd
        -: 7843:      0.60    fix compiling as c++
        -: 7844:      0.59    fix warnings: merge Dave Moore's -Wall fixes
        -: 7845:      0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian
        -: 7846:      0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
        -: 7847:      0.56    fix bug: zlib uncompressed mode len vs. nlen
        -: 7848:      0.55    fix bug: restart_interval not initialized to 0
        -: 7849:      0.54    allow NULL for 'int *comp'
        -: 7850:      0.53    fix bug in png 3->4; speedup png decoding
        -: 7851:      0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments
        -: 7852:      0.51    obey req_comp requests, 1-component jpegs return as 1-component,
        -: 7853:              on 'test' only check type, not whether we support this variant
        -: 7854:      0.50  (2006-11-19)
        -: 7855:              first released version
        -: 7856:*/
        -: 7857:
        -: 7858:
        -: 7859:/*
        -: 7860:Copyright (c) 2017 Sean Barrett
        -: 7861:Permission is hereby granted, free of charge, to any person obtaining a copy of
        -: 7862:this software and associated documentation files (the "Software"), to deal in
        -: 7863:the Software without restriction, including without limitation the rights to
        -: 7864:use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
        -: 7865:of the Software, and to permit persons to whom the Software is furnished to do
        -: 7866:so, subject to the following conditions:
        -: 7867:The above copyright notice and this permission notice shall be included in all
        -: 7868:copies or substantial portions of the Software.
        -: 7869:THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -: 7870:IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -: 7871:FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -: 7872:AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -: 7873:LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -: 7874:OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        -: 7875:SOFTWARE.
        -: 7876:*/
        -: 7877:
