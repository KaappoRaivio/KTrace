        -:    0:Source:/home/kaappo/git/raytracercpp/lib/Eigen/src/Core/Product.h
        -:    0:Graph:/home/kaappo/git/raytracercpp/cmake-build-debug-coverage/CMakeFiles/Main.dir/src/core/common/MyVector3.cpp.gcno
        -:    0:Data:/home/kaappo/git/raytracercpp/cmake-build-debug-coverage/CMakeFiles/Main.dir/src/core/common/MyVector3.cpp.gcda
        -:    0:Runs:1
        -:    1:// This file is part of Eigen, a lightweight C++ template library
        -:    2:// for linear algebra.
        -:    3://
        -:    4:// Copyright (C) 2008-2011 Gael Guennebaud <gael.guennebaud@inria.fr>
        -:    5://
        -:    6:// This Source Code Form is subject to the terms of the Mozilla
        -:    7:// Public License v. 2.0. If a copy of the MPL was not distributed
        -:    8:// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
        -:    9:
        -:   10:#ifndef EIGEN_PRODUCT_H
        -:   11:#define EIGEN_PRODUCT_H
        -:   12:
        -:   13:namespace Eigen {
        -:   14:
        -:   15:template<typename Lhs, typename Rhs, int Option, typename StorageKind> class ProductImpl;
        -:   16:
        -:   17:namespace internal {
        -:   18:
        -:   19:template<typename Lhs, typename Rhs, int Option>
        -:   20:struct traits<Product<Lhs, Rhs, Option> >
        -:   21:{
        -:   22:  typedef typename remove_all<Lhs>::type LhsCleaned;
        -:   23:  typedef typename remove_all<Rhs>::type RhsCleaned;
        -:   24:  typedef traits<LhsCleaned> LhsTraits;
        -:   25:  typedef traits<RhsCleaned> RhsTraits;
        -:   26:
        -:   27:  typedef MatrixXpr XprKind;
        -:   28:
        -:   29:  typedef typename ScalarBinaryOpTraits<typename traits<LhsCleaned>::Scalar, typename traits<RhsCleaned>::Scalar>::ReturnType Scalar;
        -:   30:  typedef typename product_promote_storage_type<typename LhsTraits::StorageKind,
        -:   31:                                                typename RhsTraits::StorageKind,
        -:   32:                                                internal::product_type<Lhs,Rhs>::ret>::ret StorageKind;
        -:   33:  typedef typename promote_index_type<typename LhsTraits::StorageIndex,
        -:   34:                                      typename RhsTraits::StorageIndex>::type StorageIndex;
        -:   35:
        -:   36:  enum {
        -:   37:    RowsAtCompileTime    = LhsTraits::RowsAtCompileTime,
        -:   38:    ColsAtCompileTime    = RhsTraits::ColsAtCompileTime,
        -:   39:    MaxRowsAtCompileTime = LhsTraits::MaxRowsAtCompileTime,
        -:   40:    MaxColsAtCompileTime = RhsTraits::MaxColsAtCompileTime,
        -:   41:
        -:   42:    // FIXME: only needed by GeneralMatrixMatrixTriangular
        -:   43:    InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(LhsTraits::ColsAtCompileTime, RhsTraits::RowsAtCompileTime),
        -:   44:
        -:   45:    // The storage order is somewhat arbitrary here. The correct one will be determined through the evaluator.
        -:   46:    Flags = (MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1) ? RowMajorBit
        -:   47:          : (MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1) ? 0
        -:   48:          : (   ((LhsTraits::Flags&NoPreferredStorageOrderBit) && (RhsTraits::Flags&RowMajorBit))
        -:   49:             || ((RhsTraits::Flags&NoPreferredStorageOrderBit) && (LhsTraits::Flags&RowMajorBit)) ) ? RowMajorBit
        -:   50:          : NoPreferredStorageOrderBit
        -:   51:  };
        -:   52:};
        -:   53:
        -:   54:} // end namespace internal
        -:   55:
        -:   56:/** \class Product
        -:   57:  * \ingroup Core_Module
        -:   58:  *
        -:   59:  * \brief Expression of the product of two arbitrary matrices or vectors
        -:   60:  *
        -:   61:  * \tparam _Lhs the type of the left-hand side expression
        -:   62:  * \tparam _Rhs the type of the right-hand side expression
        -:   63:  *
        -:   64:  * This class represents an expression of the product of two arbitrary matrices.
        -:   65:  *
        -:   66:  * The other template parameters are:
        -:   67:  * \tparam Option     can be DefaultProduct, AliasFreeProduct, or LazyProduct
        -:   68:  *
        -:   69:  */
        -:   70:template<typename _Lhs, typename _Rhs, int Option>
        -:   71:class Product : public ProductImpl<_Lhs,_Rhs,Option,
        -:   72:                                   typename internal::product_promote_storage_type<typename internal::traits<_Lhs>::StorageKind,
        -:   73:                                                                                   typename internal::traits<_Rhs>::StorageKind,
        -:   74:                                                                                   internal::product_type<_Lhs,_Rhs>::ret>::ret>
        -:   75:{
        -:   76:  public:
        -:   77:
        -:   78:    typedef _Lhs Lhs;
        -:   79:    typedef _Rhs Rhs;
        -:   80:
        -:   81:    typedef typename ProductImpl<
        -:   82:        Lhs, Rhs, Option,
        -:   83:        typename internal::product_promote_storage_type<typename internal::traits<Lhs>::StorageKind,
        -:   84:                                                        typename internal::traits<Rhs>::StorageKind,
        -:   85:                                                        internal::product_type<Lhs,Rhs>::ret>::ret>::Base Base;
        -:   86:    EIGEN_GENERIC_PUBLIC_INTERFACE(Product)
        -:   87:
        -:   88:    typedef typename internal::ref_selector<Lhs>::type LhsNested;
        -:   89:    typedef typename internal::ref_selector<Rhs>::type RhsNested;
        -:   90:    typedef typename internal::remove_all<LhsNested>::type LhsNestedCleaned;
        -:   91:    typedef typename internal::remove_all<RhsNested>::type RhsNestedCleaned;
        -:   92:
        -:   93:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
    #####:   94:    Product(const Lhs& lhs, const Rhs& rhs) : m_lhs(lhs), m_rhs(rhs)
        -:   95:    {
    #####:   96:      eigen_assert(lhs.cols() == rhs.rows()
        -:   97:        && "invalid matrix product"
        -:   98:        && "if you wanted a coeff-wise or a dot product use the respective explicit functions");
    #####:   99:    }
------------------
_ZN5Eigen7ProductINS_9TransposeIKNS_5BlockIKNS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEELin1ELi1ELb0EEEEENS2_INS2_INS3_IdLi3ELi1ELi0ELi3ELi1EEELin1ELin1ELb0EEELin1ELin1ELb0EEELi1EEC2ERKS8_RKSB_:
function _ZN5Eigen7ProductINS_9TransposeIKNS_5BlockIKNS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEELin1ELi1ELb0EEEEENS2_INS2_INS3_IdLi3ELi1ELi0ELi3ELi1EEELin1ELin1ELb0EEELin1ELin1ELb0EEELi1EEC2ERKS8_RKSB_ called 0 returned 0% blocks executed 0%
    #####:   94:    Product(const Lhs& lhs, const Rhs& rhs) : m_lhs(lhs), m_rhs(rhs)
    %%%%%:   94-block  0
branch  0 never executed
branch  1 never executed
        -:   95:    {
    #####:   96:      eigen_assert(lhs.cols() == rhs.rows()
    %%%%%:   96-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:   96-block  1
call    2 never executed
        -:   97:        && "invalid matrix product"
        -:   98:        && "if you wanted a coeff-wise or a dot product use the respective explicit functions");
    #####:   99:    }
------------------
_ZN5Eigen7ProductINS_9TransposeIKNS_5BlockIKNS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEELin1ELi1ELb0EEEEENS2_INS2_INS3_IdLi3ELi1ELi0ELi3ELi1EEELin1ELin1ELb0EEELin1ELin1ELb0EEELi0EEC2ERKS8_RKSB_:
function _ZN5Eigen7ProductINS_9TransposeIKNS_5BlockIKNS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEELin1ELi1ELb0EEEEENS2_INS2_INS3_IdLi3ELi1ELi0ELi3ELi1EEELin1ELin1ELb0EEELin1ELin1ELb0EEELi0EEC2ERKS8_RKSB_ called 0 returned 0% blocks executed 0%
    #####:   94:    Product(const Lhs& lhs, const Rhs& rhs) : m_lhs(lhs), m_rhs(rhs)
    %%%%%:   94-block  0
branch  0 never executed
branch  1 never executed
        -:   95:    {
    #####:   96:      eigen_assert(lhs.cols() == rhs.rows()
    %%%%%:   96-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:   96-block  1
call    2 never executed
        -:   97:        && "invalid matrix product"
        -:   98:        && "if you wanted a coeff-wise or a dot product use the respective explicit functions");
    #####:   99:    }
------------------
_ZN5Eigen7ProductINS_9TransposeIKNS_5BlockINS2_INS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEELi3ELi1ELb1EEELin1ELi1ELb0EEEEENS2_INS2_IS4_Lin1ELin1ELb0EEELin1ELin1ELb0EEELi1EEC2ERKS8_RKSA_:
function _ZN5Eigen7ProductINS_9TransposeIKNS_5BlockINS2_INS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEELi3ELi1ELb1EEELin1ELi1ELb0EEEEENS2_INS2_IS4_Lin1ELin1ELb0EEELin1ELin1ELb0EEELi1EEC2ERKS8_RKSA_ called 0 returned 0% blocks executed 0%
    #####:   94:    Product(const Lhs& lhs, const Rhs& rhs) : m_lhs(lhs), m_rhs(rhs)
    %%%%%:   94-block  0
branch  0 never executed
branch  1 never executed
        -:   95:    {
    #####:   96:      eigen_assert(lhs.cols() == rhs.rows()
    %%%%%:   96-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:   96-block  1
call    2 never executed
        -:   97:        && "invalid matrix product"
        -:   98:        && "if you wanted a coeff-wise or a dot product use the respective explicit functions");
    #####:   99:    }
------------------
_ZN5Eigen7ProductINS_9TransposeIKNS_5BlockINS2_INS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEELi3ELi1ELb1EEELin1ELi1ELb0EEEEENS2_INS2_IS4_Lin1ELin1ELb0EEELin1ELin1ELb0EEELi0EEC2ERKS8_RKSA_:
function _ZN5Eigen7ProductINS_9TransposeIKNS_5BlockINS2_INS_6MatrixIdLi3ELi3ELi0ELi3ELi3EEELi3ELi1ELb1EEELin1ELi1ELb0EEEEENS2_INS2_IS4_Lin1ELin1ELb0EEELin1ELin1ELb0EEELi0EEC2ERKS8_RKSA_ called 0 returned 0% blocks executed 0%
    #####:   94:    Product(const Lhs& lhs, const Rhs& rhs) : m_lhs(lhs), m_rhs(rhs)
    %%%%%:   94-block  0
branch  0 never executed
branch  1 never executed
        -:   95:    {
    #####:   96:      eigen_assert(lhs.cols() == rhs.rows()
    %%%%%:   96-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:   96-block  1
call    2 never executed
        -:   97:        && "invalid matrix product"
        -:   98:        && "if you wanted a coeff-wise or a dot product use the respective explicit functions");
    #####:   99:    }
------------------
        -:  100:
        -:  101:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
        -:  102:    Index rows() const EIGEN_NOEXCEPT { return m_lhs.rows(); }
        -:  103:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
        -:  104:    Index cols() const EIGEN_NOEXCEPT { return m_rhs.cols(); }
        -:  105:
        -:  106:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
    #####:  107:    const LhsNestedCleaned& lhs() const { return m_lhs; }
    %%%%%:  107-block  0
call    0 never executed
    %%%%%:  107-block  1
call    1 never executed
        -:  108:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
    #####:  109:    const RhsNestedCleaned& rhs() const { return m_rhs; }
    %%%%%:  109-block  0
call    0 never executed
    %%%%%:  109-block  1
call    1 never executed
    %%%%%:  109-block  2
call    2 never executed
    %%%%%:  109-block  3
call    3 never executed
        -:  110:
        -:  111:  protected:
        -:  112:
        -:  113:    LhsNested m_lhs;
        -:  114:    RhsNested m_rhs;
        -:  115:};
        -:  116:
        -:  117:namespace internal {
        -:  118:
        -:  119:template<typename Lhs, typename Rhs, int Option, int ProductTag = internal::product_type<Lhs,Rhs>::ret>
        -:  120:class dense_product_base
        -:  121: : public internal::dense_xpr_base<Product<Lhs,Rhs,Option> >::type
        -:  122:{};
        -:  123:
        -:  124:/** Conversion to scalar for inner-products */
        -:  125:template<typename Lhs, typename Rhs, int Option>
        -:  126:class dense_product_base<Lhs, Rhs, Option, InnerProduct>
        -:  127: : public internal::dense_xpr_base<Product<Lhs,Rhs,Option> >::type
        -:  128:{
        -:  129:  typedef Product<Lhs,Rhs,Option> ProductXpr;
        -:  130:  typedef typename internal::dense_xpr_base<ProductXpr>::type Base;
        -:  131:public:
        -:  132:  using Base::derived;
        -:  133:  typedef typename Base::Scalar Scalar;
        -:  134:
        -:  135:  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE operator const Scalar() const
        -:  136:  {
        -:  137:    return internal::evaluator<ProductXpr>(derived()).coeff(0,0);
        -:  138:  }
        -:  139:};
        -:  140:
        -:  141:} // namespace internal
        -:  142:
        -:  143:// Generic API dispatcher
        -:  144:template<typename Lhs, typename Rhs, int Option, typename StorageKind>
        -:  145:class ProductImpl : public internal::generic_xpr_base<Product<Lhs,Rhs,Option>, MatrixXpr, StorageKind>::type
        -:  146:{
        -:  147:  public:
        -:  148:    typedef typename internal::generic_xpr_base<Product<Lhs,Rhs,Option>, MatrixXpr, StorageKind>::type Base;
        -:  149:};
        -:  150:
        -:  151:template<typename Lhs, typename Rhs, int Option>
        -:  152:class ProductImpl<Lhs,Rhs,Option,Dense>
        -:  153:  : public internal::dense_product_base<Lhs,Rhs,Option>
        -:  154:{
        -:  155:    typedef Product<Lhs, Rhs, Option> Derived;
        -:  156:
        -:  157:  public:
        -:  158:
        -:  159:    typedef typename internal::dense_product_base<Lhs, Rhs, Option> Base;
        -:  160:    EIGEN_DENSE_PUBLIC_INTERFACE(Derived)
        -:  161:  protected:
        -:  162:    enum {
        -:  163:      IsOneByOne = (RowsAtCompileTime == 1 || RowsAtCompileTime == Dynamic) &&
        -:  164:                   (ColsAtCompileTime == 1 || ColsAtCompileTime == Dynamic),
        -:  165:      EnableCoeff = IsOneByOne || Option==LazyProduct
        -:  166:    };
        -:  167:
        -:  168:  public:
        -:  169:
        -:  170:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar coeff(Index row, Index col) const
        -:  171:    {
        -:  172:      EIGEN_STATIC_ASSERT(EnableCoeff, THIS_METHOD_IS_ONLY_FOR_INNER_OR_LAZY_PRODUCTS);
        -:  173:      eigen_assert( (Option==LazyProduct) || (this->rows() == 1 && this->cols() == 1) );
        -:  174:
        -:  175:      return internal::evaluator<Derived>(derived()).coeff(row,col);
        -:  176:    }
        -:  177:
        -:  178:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar coeff(Index i) const
        -:  179:    {
        -:  180:      EIGEN_STATIC_ASSERT(EnableCoeff, THIS_METHOD_IS_ONLY_FOR_INNER_OR_LAZY_PRODUCTS);
        -:  181:      eigen_assert( (Option==LazyProduct) || (this->rows() == 1 && this->cols() == 1) );
        -:  182:
        -:  183:      return internal::evaluator<Derived>(derived()).coeff(i);
        -:  184:    }
        -:  185:
        -:  186:
        -:  187:};
        -:  188:
        -:  189:} // end namespace Eigen
        -:  190:
        -:  191:#endif // EIGEN_PRODUCT_H
