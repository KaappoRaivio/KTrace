        -:    0:Source:/home/kaappo/git/raytracercpp/lib/Eigen/src/Core/DenseBase.h
        -:    0:Graph:/home/kaappo/git/raytracercpp/cmake-build-debug-coverage/CMakeFiles/Main.dir/src/core/common/MyVector3.cpp.gcno
        -:    0:Data:/home/kaappo/git/raytracercpp/cmake-build-debug-coverage/CMakeFiles/Main.dir/src/core/common/MyVector3.cpp.gcda
        -:    0:Runs:1
        -:    1:// This file is part of Eigen, a lightweight C++ template library
        -:    2:// for linear algebra.
        -:    3://
        -:    4:// Copyright (C) 2007-2010 Benoit Jacob <jacob.benoit.1@gmail.com>
        -:    5:// Copyright (C) 2008-2010 Gael Guennebaud <gael.guennebaud@inria.fr>
        -:    6://
        -:    7:// This Source Code Form is subject to the terms of the Mozilla
        -:    8:// Public License v. 2.0. If a copy of the MPL was not distributed
        -:    9:// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
        -:   10:
        -:   11:#ifndef EIGEN_DENSEBASE_H
        -:   12:#define EIGEN_DENSEBASE_H
        -:   13:
        -:   14:namespace Eigen {
        -:   15:
        -:   16:namespace internal {
        -:   17:
        -:   18:// The index type defined by EIGEN_DEFAULT_DENSE_INDEX_TYPE must be a signed type.
        -:   19:// This dummy function simply aims at checking that at compile time.
        -:   20:static inline void check_DenseIndex_is_signed() {
        -:   21:  EIGEN_STATIC_ASSERT(NumTraits<DenseIndex>::IsSigned,THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE)
        -:   22:}
        -:   23:
        -:   24:} // end namespace internal
        -:   25:
        -:   26:/** \class DenseBase
        -:   27:  * \ingroup Core_Module
        -:   28:  *
        -:   29:  * \brief Base class for all dense matrices, vectors, and arrays
        -:   30:  *
        -:   31:  * This class is the base that is inherited by all dense objects (matrix, vector, arrays,
        -:   32:  * and related expression types). The common Eigen API for dense objects is contained in this class.
        -:   33:  *
        -:   34:  * \tparam Derived is the derived type, e.g., a matrix type or an expression.
        -:   35:  *
        -:   36:  * This class can be extended with the help of the plugin mechanism described on the page
        -:   37:  * \ref TopicCustomizing_Plugins by defining the preprocessor symbol \c EIGEN_DENSEBASE_PLUGIN.
        -:   38:  *
        -:   39:  * \sa \blank \ref TopicClassHierarchy
        -:   40:  */
        -:   41:template<typename Derived> class DenseBase
        -:   42:#ifndef EIGEN_PARSED_BY_DOXYGEN
        -:   43:  : public DenseCoeffsBase<Derived, internal::accessors_level<Derived>::value>
        -:   44:#else
        -:   45:  : public DenseCoeffsBase<Derived,DirectWriteAccessors>
        -:   46:#endif // not EIGEN_PARSED_BY_DOXYGEN
        -:   47:{
        -:   48:  public:
        -:   49:
        -:   50:    /** Inner iterator type to iterate over the coefficients of a row or column.
        -:   51:      * \sa class InnerIterator
        -:   52:      */
        -:   53:    typedef Eigen::InnerIterator<Derived> InnerIterator;
        -:   54:
        -:   55:    typedef typename internal::traits<Derived>::StorageKind StorageKind;
        -:   56:
        -:   57:    /**
        -:   58:      * \brief The type used to store indices
        -:   59:      * \details This typedef is relevant for types that store multiple indices such as
        -:   60:      *          PermutationMatrix or Transpositions, otherwise it defaults to Eigen::Index
        -:   61:      * \sa \blank \ref TopicPreprocessorDirectives, Eigen::Index, SparseMatrixBase.
        -:   62:     */
        -:   63:    typedef typename internal::traits<Derived>::StorageIndex StorageIndex;
        -:   64:
        -:   65:    /** The numeric type of the expression' coefficients, e.g. float, double, int or std::complex<float>, etc. */
        -:   66:    typedef typename internal::traits<Derived>::Scalar Scalar;
        -:   67:
        -:   68:    /** The numeric type of the expression' coefficients, e.g. float, double, int or std::complex<float>, etc.
        -:   69:      *
        -:   70:      * It is an alias for the Scalar type */
        -:   71:    typedef Scalar value_type;
        -:   72:
        -:   73:    typedef typename NumTraits<Scalar>::Real RealScalar;
        -:   74:    typedef DenseCoeffsBase<Derived, internal::accessors_level<Derived>::value> Base;
        -:   75:
        -:   76:    using Base::derived;
        -:   77:    using Base::const_cast_derived;
        -:   78:    using Base::rows;
        -:   79:    using Base::cols;
        -:   80:    using Base::size;
        -:   81:    using Base::rowIndexByOuterInner;
        -:   82:    using Base::colIndexByOuterInner;
        -:   83:    using Base::coeff;
        -:   84:    using Base::coeffByOuterInner;
        -:   85:    using Base::operator();
        -:   86:    using Base::operator[];
        -:   87:    using Base::x;
        -:   88:    using Base::y;
        -:   89:    using Base::z;
        -:   90:    using Base::w;
        -:   91:    using Base::stride;
        -:   92:    using Base::innerStride;
        -:   93:    using Base::outerStride;
        -:   94:    using Base::rowStride;
        -:   95:    using Base::colStride;
        -:   96:    typedef typename Base::CoeffReturnType CoeffReturnType;
        -:   97:
        -:   98:    enum {
        -:   99:
        -:  100:      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,
        -:  101:        /**< The number of rows at compile-time. This is just a copy of the value provided
        -:  102:          * by the \a Derived type. If a value is not known at compile-time,
        -:  103:          * it is set to the \a Dynamic constant.
        -:  104:          * \sa MatrixBase::rows(), MatrixBase::cols(), ColsAtCompileTime, SizeAtCompileTime */
        -:  105:
        -:  106:      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,
        -:  107:        /**< The number of columns at compile-time. This is just a copy of the value provided
        -:  108:          * by the \a Derived type. If a value is not known at compile-time,
        -:  109:          * it is set to the \a Dynamic constant.
        -:  110:          * \sa MatrixBase::rows(), MatrixBase::cols(), RowsAtCompileTime, SizeAtCompileTime */
        -:  111:
        -:  112:
        -:  113:      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,
        -:  114:                                                   internal::traits<Derived>::ColsAtCompileTime>::ret),
        -:  115:        /**< This is equal to the number of coefficients, i.e. the number of
        -:  116:          * rows times the number of columns, or to \a Dynamic if this is not
        -:  117:          * known at compile-time. \sa RowsAtCompileTime, ColsAtCompileTime */
        -:  118:
        -:  119:      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,
        -:  120:        /**< This value is equal to the maximum possible number of rows that this expression
        -:  121:          * might have. If this expression might have an arbitrarily high number of rows,
        -:  122:          * this value is set to \a Dynamic.
        -:  123:          *
        -:  124:          * This value is useful to know when evaluating an expression, in order to determine
        -:  125:          * whether it is possible to avoid doing a dynamic memory allocation.
        -:  126:          *
        -:  127:          * \sa RowsAtCompileTime, MaxColsAtCompileTime, MaxSizeAtCompileTime
        -:  128:          */
        -:  129:
        -:  130:      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,
        -:  131:        /**< This value is equal to the maximum possible number of columns that this expression
        -:  132:          * might have. If this expression might have an arbitrarily high number of columns,
        -:  133:          * this value is set to \a Dynamic.
        -:  134:          *
        -:  135:          * This value is useful to know when evaluating an expression, in order to determine
        -:  136:          * whether it is possible to avoid doing a dynamic memory allocation.
        -:  137:          *
        -:  138:          * \sa ColsAtCompileTime, MaxRowsAtCompileTime, MaxSizeAtCompileTime
        -:  139:          */
        -:  140:
        -:  141:      MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCompileTime,
        -:  142:                                                      internal::traits<Derived>::MaxColsAtCompileTime>::ret),
        -:  143:        /**< This value is equal to the maximum possible number of coefficients that this expression
        -:  144:          * might have. If this expression might have an arbitrarily high number of coefficients,
        -:  145:          * this value is set to \a Dynamic.
        -:  146:          *
        -:  147:          * This value is useful to know when evaluating an expression, in order to determine
        -:  148:          * whether it is possible to avoid doing a dynamic memory allocation.
        -:  149:          *
        -:  150:          * \sa SizeAtCompileTime, MaxRowsAtCompileTime, MaxColsAtCompileTime
        -:  151:          */
        -:  152:
        -:  153:      IsVectorAtCompileTime = internal::traits<Derived>::RowsAtCompileTime == 1
        -:  154:                           || internal::traits<Derived>::ColsAtCompileTime == 1,
        -:  155:        /**< This is set to true if either the number of rows or the number of
        -:  156:          * columns is known at compile-time to be equal to 1. Indeed, in that case,
        -:  157:          * we are dealing with a column-vector (if there is only one column) or with
        -:  158:          * a row-vector (if there is only one row). */
        -:  159:
        -:  160:      NumDimensions = int(MaxSizeAtCompileTime) == 1 ? 0 : bool(IsVectorAtCompileTime) ? 1 : 2,
        -:  161:        /**< This value is equal to Tensor::NumDimensions, i.e. 0 for scalars, 1 for vectors,
        -:  162:         * and 2 for matrices.
        -:  163:         */
        -:  164:
        -:  165:      Flags = internal::traits<Derived>::Flags,
        -:  166:        /**< This stores expression \ref flags flags which may or may not be inherited by new expressions
        -:  167:          * constructed from this one. See the \ref flags "list of flags".
        -:  168:          */
        -:  169:
        -:  170:      IsRowMajor = int(Flags) & RowMajorBit, /**< True if this expression has row-major storage order. */
        -:  171:
        -:  172:      InnerSizeAtCompileTime = int(IsVectorAtCompileTime) ? int(SizeAtCompileTime)
        -:  173:                             : int(IsRowMajor) ? int(ColsAtCompileTime) : int(RowsAtCompileTime),
        -:  174:
        -:  175:      InnerStrideAtCompileTime = internal::inner_stride_at_compile_time<Derived>::ret,
        -:  176:      OuterStrideAtCompileTime = internal::outer_stride_at_compile_time<Derived>::ret
        -:  177:    };
        -:  178:
        -:  179:    typedef typename internal::find_best_packet<Scalar,SizeAtCompileTime>::type PacketScalar;
        -:  180:
        -:  181:    enum { IsPlainObjectBase = 0 };
        -:  182:
        -:  183:    /** The plain matrix type corresponding to this expression.
        -:  184:      * \sa PlainObject */
        -:  185:    typedef Matrix<typename internal::traits<Derived>::Scalar,
        -:  186:                internal::traits<Derived>::RowsAtCompileTime,
        -:  187:                internal::traits<Derived>::ColsAtCompileTime,
        -:  188:                AutoAlign | (internal::traits<Derived>::Flags&RowMajorBit ? RowMajor : ColMajor),
        -:  189:                internal::traits<Derived>::MaxRowsAtCompileTime,
        -:  190:                internal::traits<Derived>::MaxColsAtCompileTime
        -:  191:          > PlainMatrix;
        -:  192:
        -:  193:    /** The plain array type corresponding to this expression.
        -:  194:      * \sa PlainObject */
        -:  195:    typedef Array<typename internal::traits<Derived>::Scalar,
        -:  196:                internal::traits<Derived>::RowsAtCompileTime,
        -:  197:                internal::traits<Derived>::ColsAtCompileTime,
        -:  198:                AutoAlign | (internal::traits<Derived>::Flags&RowMajorBit ? RowMajor : ColMajor),
        -:  199:                internal::traits<Derived>::MaxRowsAtCompileTime,
        -:  200:                internal::traits<Derived>::MaxColsAtCompileTime
        -:  201:          > PlainArray;
        -:  202:
        -:  203:    /** \brief The plain matrix or array type corresponding to this expression.
        -:  204:      *
        -:  205:      * This is not necessarily exactly the return type of eval(). In the case of plain matrices,
        -:  206:      * the return type of eval() is a const reference to a matrix, not a matrix! It is however guaranteed
        -:  207:      * that the return type of eval() is either PlainObject or const PlainObject&.
        -:  208:      */
        -:  209:    typedef typename internal::conditional<internal::is_same<typename internal::traits<Derived>::XprKind,MatrixXpr >::value,
        -:  210:                                 PlainMatrix, PlainArray>::type PlainObject;
        -:  211:
        -:  212:    /** \returns the number of nonzero coefficients which is in practice the number
        -:  213:      * of stored coefficients. */
        -:  214:    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
        -:  215:    inline Index nonZeros() const { return size(); }
        -:  216:
        -:  217:    /** \returns the outer size.
        -:  218:      *
        -:  219:      * \note For a vector, this returns just 1. For a matrix (non-vector), this is the major dimension
        -:  220:      * with respect to the \ref TopicStorageOrders "storage order", i.e., the number of columns for a
        -:  221:      * column-major matrix, and the number of rows for a row-major matrix. */
        -:  222:    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
        -:  223:    Index outerSize() const
        -:  224:    {
        -:  225:      return IsVectorAtCompileTime ? 1
        -:  226:           : int(IsRowMajor) ? this->rows() : this->cols();
        -:  227:    }
        -:  228:
        -:  229:    /** \returns the inner size.
        -:  230:      *
        -:  231:      * \note For a vector, this is just the size. For a matrix (non-vector), this is the minor dimension
        -:  232:      * with respect to the \ref TopicStorageOrders "storage order", i.e., the number of rows for a
        -:  233:      * column-major matrix, and the number of columns for a row-major matrix. */
        -:  234:    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
        -:  235:    Index innerSize() const
        -:  236:    {
        -:  237:      return IsVectorAtCompileTime ? this->size()
        -:  238:           : int(IsRowMajor) ? this->cols() : this->rows();
        -:  239:    }
        -:  240:
        -:  241:    /** Only plain matrices/arrays, not expressions, may be resized; therefore the only useful resize methods are
        -:  242:      * Matrix::resize() and Array::resize(). The present method only asserts that the new size equals the old size, and does
        -:  243:      * nothing else.
        -:  244:      */
        -:  245:    EIGEN_DEVICE_FUNC
        -:  246:    void resize(Index newSize)
        -:  247:    {
        -:  248:      EIGEN_ONLY_USED_FOR_DEBUG(newSize);
        -:  249:      eigen_assert(newSize == this->size()
        -:  250:                && "DenseBase::resize() does not actually allow to resize.");
        -:  251:    }
        -:  252:    /** Only plain matrices/arrays, not expressions, may be resized; therefore the only useful resize methods are
        -:  253:      * Matrix::resize() and Array::resize(). The present method only asserts that the new size equals the old size, and does
        -:  254:      * nothing else.
        -:  255:      */
        -:  256:    EIGEN_DEVICE_FUNC
        -:  257:    void resize(Index rows, Index cols)
        -:  258:    {
        -:  259:      EIGEN_ONLY_USED_FOR_DEBUG(rows);
        -:  260:      EIGEN_ONLY_USED_FOR_DEBUG(cols);
    #####:  261:      eigen_assert(rows == this->rows() && cols == this->cols()
    %%%%%:  261-block  0
call    0 never executed
    %%%%%:  261-block  1
call    1 never executed
    %%%%%:  261-block  2
call    2 never executed
    %%%%%:  261-block  3
call    3 never executed
    %%%%%:  261-block  4
call    4 never executed
    %%%%%:  261-block  5
call    5 never executed
        -:  262:                && "DenseBase::resize() does not actually allow to resize.");
        -:  263:    }
        -:  264:
        -:  265:#ifndef EIGEN_PARSED_BY_DOXYGEN
        -:  266:    /** \internal Represents a matrix with all coefficients equal to one another*/
        -:  267:    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,PlainObject> ConstantReturnType;
        -:  268:    /** \internal \deprecated Represents a vector with linearly spaced coefficients that allows sequential access only. */
        -:  269:    EIGEN_DEPRECATED typedef CwiseNullaryOp<internal::linspaced_op<Scalar>,PlainObject> SequentialLinSpacedReturnType;
        -:  270:    /** \internal Represents a vector with linearly spaced coefficients that allows random access. */
        -:  271:    typedef CwiseNullaryOp<internal::linspaced_op<Scalar>,PlainObject> RandomAccessLinSpacedReturnType;
        -:  272:    /** \internal the return type of MatrixBase::eigenvalues() */
        -:  273:    typedef Matrix<typename NumTraits<typename internal::traits<Derived>::Scalar>::Real, internal::traits<Derived>::ColsAtCompileTime, 1> EigenvaluesReturnType;
        -:  274:
        -:  275:#endif // not EIGEN_PARSED_BY_DOXYGEN
        -:  276:
        -:  277:    /** Copies \a other into *this. \returns a reference to *this. */
        -:  278:    template<typename OtherDerived>
        -:  279:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
        -:  280:    Derived& operator=(const DenseBase<OtherDerived>& other);
        -:  281:
        -:  282:    /** Special case of the template operator=, in order to prevent the compiler
        -:  283:      * from generating a default operator= (issue hit with g++ 4.1)
        -:  284:      */
        -:  285:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
        -:  286:    Derived& operator=(const DenseBase& other);
        -:  287:
        -:  288:    template<typename OtherDerived>
        -:  289:    EIGEN_DEVICE_FUNC
        -:  290:    Derived& operator=(const EigenBase<OtherDerived> &other);
        -:  291:
        -:  292:    template<typename OtherDerived>
        -:  293:    EIGEN_DEVICE_FUNC
        -:  294:    Derived& operator+=(const EigenBase<OtherDerived> &other);
        -:  295:
        -:  296:    template<typename OtherDerived>
        -:  297:    EIGEN_DEVICE_FUNC
        -:  298:    Derived& operator-=(const EigenBase<OtherDerived> &other);
        -:  299:
        -:  300:    template<typename OtherDerived>
        -:  301:    EIGEN_DEVICE_FUNC
        -:  302:    Derived& operator=(const ReturnByValue<OtherDerived>& func);
        -:  303:
        -:  304:    /** \internal
        -:  305:      * Copies \a other into *this without evaluating other. \returns a reference to *this. */
        -:  306:    template<typename OtherDerived>
        -:  307:    /** \deprecated */
        -:  308:    EIGEN_DEPRECATED EIGEN_DEVICE_FUNC
        -:  309:    Derived& lazyAssign(const DenseBase<OtherDerived>& other);
        -:  310:
        -:  311:    EIGEN_DEVICE_FUNC
        -:  312:    CommaInitializer<Derived> operator<< (const Scalar& s);
        -:  313:
        -:  314:    template<unsigned int Added,unsigned int Removed>
        -:  315:    /** \deprecated it now returns \c *this */
        -:  316:    EIGEN_DEPRECATED
        -:  317:    const Derived& flagged() const
        -:  318:    { return derived(); }
        -:  319:
        -:  320:    template<typename OtherDerived>
        -:  321:    EIGEN_DEVICE_FUNC
        -:  322:    CommaInitializer<Derived> operator<< (const DenseBase<OtherDerived>& other);
        -:  323:
        -:  324:    typedef Transpose<Derived> TransposeReturnType;
        -:  325:    EIGEN_DEVICE_FUNC
        -:  326:    TransposeReturnType transpose();
        -:  327:    typedef typename internal::add_const<Transpose<const Derived> >::type ConstTransposeReturnType;
        -:  328:    EIGEN_DEVICE_FUNC
        -:  329:    ConstTransposeReturnType transpose() const;
        -:  330:    EIGEN_DEVICE_FUNC
        -:  331:    void transposeInPlace();
        -:  332:
        -:  333:    EIGEN_DEVICE_FUNC static const ConstantReturnType
        -:  334:    Constant(Index rows, Index cols, const Scalar& value);
        -:  335:    EIGEN_DEVICE_FUNC static const ConstantReturnType
        -:  336:    Constant(Index size, const Scalar& value);
        -:  337:    EIGEN_DEVICE_FUNC static const ConstantReturnType
        -:  338:    Constant(const Scalar& value);
        -:  339:
        -:  340:    EIGEN_DEPRECATED EIGEN_DEVICE_FUNC static const RandomAccessLinSpacedReturnType
        -:  341:    LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high);
        -:  342:    EIGEN_DEPRECATED EIGEN_DEVICE_FUNC static const RandomAccessLinSpacedReturnType
        -:  343:    LinSpaced(Sequential_t, const Scalar& low, const Scalar& high);
        -:  344:
        -:  345:    EIGEN_DEVICE_FUNC static const RandomAccessLinSpacedReturnType
        -:  346:    LinSpaced(Index size, const Scalar& low, const Scalar& high);
        -:  347:    EIGEN_DEVICE_FUNC static const RandomAccessLinSpacedReturnType
        -:  348:    LinSpaced(const Scalar& low, const Scalar& high);
        -:  349:
        -:  350:    template<typename CustomNullaryOp> EIGEN_DEVICE_FUNC
        -:  351:    static const CwiseNullaryOp<CustomNullaryOp, PlainObject>
        -:  352:    NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func);
        -:  353:    template<typename CustomNullaryOp> EIGEN_DEVICE_FUNC
        -:  354:    static const CwiseNullaryOp<CustomNullaryOp, PlainObject>
        -:  355:    NullaryExpr(Index size, const CustomNullaryOp& func);
        -:  356:    template<typename CustomNullaryOp> EIGEN_DEVICE_FUNC
        -:  357:    static const CwiseNullaryOp<CustomNullaryOp, PlainObject>
        -:  358:    NullaryExpr(const CustomNullaryOp& func);
        -:  359:
        -:  360:    EIGEN_DEVICE_FUNC static const ConstantReturnType Zero(Index rows, Index cols);
        -:  361:    EIGEN_DEVICE_FUNC static const ConstantReturnType Zero(Index size);
        -:  362:    EIGEN_DEVICE_FUNC static const ConstantReturnType Zero();
        -:  363:    EIGEN_DEVICE_FUNC static const ConstantReturnType Ones(Index rows, Index cols);
        -:  364:    EIGEN_DEVICE_FUNC static const ConstantReturnType Ones(Index size);
        -:  365:    EIGEN_DEVICE_FUNC static const ConstantReturnType Ones();
        -:  366:
        -:  367:    EIGEN_DEVICE_FUNC void fill(const Scalar& value);
        -:  368:    EIGEN_DEVICE_FUNC Derived& setConstant(const Scalar& value);
        -:  369:    EIGEN_DEVICE_FUNC Derived& setLinSpaced(Index size, const Scalar& low, const Scalar& high);
        -:  370:    EIGEN_DEVICE_FUNC Derived& setLinSpaced(const Scalar& low, const Scalar& high);
        -:  371:    EIGEN_DEVICE_FUNC Derived& setZero();
        -:  372:    EIGEN_DEVICE_FUNC Derived& setOnes();
        -:  373:    EIGEN_DEVICE_FUNC Derived& setRandom();
        -:  374:
        -:  375:    template<typename OtherDerived> EIGEN_DEVICE_FUNC
        -:  376:    bool isApprox(const DenseBase<OtherDerived>& other,
        -:  377:                  const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
        -:  378:    EIGEN_DEVICE_FUNC
        -:  379:    bool isMuchSmallerThan(const RealScalar& other,
        -:  380:                           const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
        -:  381:    template<typename OtherDerived> EIGEN_DEVICE_FUNC
        -:  382:    bool isMuchSmallerThan(const DenseBase<OtherDerived>& other,
        -:  383:                           const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
        -:  384:
        -:  385:    EIGEN_DEVICE_FUNC bool isApproxToConstant(const Scalar& value, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
        -:  386:    EIGEN_DEVICE_FUNC bool isConstant(const Scalar& value, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
        -:  387:    EIGEN_DEVICE_FUNC bool isZero(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
        -:  388:    EIGEN_DEVICE_FUNC bool isOnes(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
        -:  389:
        -:  390:    inline bool hasNaN() const;
        -:  391:    inline bool allFinite() const;
        -:  392:
        -:  393:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
        -:  394:    Derived& operator*=(const Scalar& other);
        -:  395:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
        -:  396:    Derived& operator/=(const Scalar& other);
        -:  397:
        -:  398:    typedef typename internal::add_const_on_value_type<typename internal::eval<Derived>::type>::type EvalReturnType;
        -:  399:    /** \returns the matrix or vector obtained by evaluating this expression.
        -:  400:      *
        -:  401:      * Notice that in the case of a plain matrix or vector (not an expression) this function just returns
        -:  402:      * a const reference, in order to avoid a useless copy.
        -:  403:      *
        -:  404:      * \warning Be careful with eval() and the auto C++ keyword, as detailed in this \link TopicPitfalls_auto_keyword page \endlink.
        -:  405:      */
        -:  406:    EIGEN_DEVICE_FUNC
        -:  407:    EIGEN_STRONG_INLINE EvalReturnType eval() const
        -:  408:    {
        -:  409:      // Even though MSVC does not honor strong inlining when the return type
        -:  410:      // is a dynamic matrix, we desperately need strong inlining for fixed
        -:  411:      // size types on MSVC.
        -:  412:      return typename internal::eval<Derived>::type(derived());
        -:  413:    }
        -:  414:
        -:  415:    /** swaps *this with the expression \a other.
        -:  416:      *
        -:  417:      */
        -:  418:    template<typename OtherDerived>
        -:  419:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
        -:  420:    void swap(const DenseBase<OtherDerived>& other)
        -:  421:    {
        -:  422:      EIGEN_STATIC_ASSERT(!OtherDerived::IsPlainObjectBase,THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY);
        -:  423:      eigen_assert(rows()==other.rows() && cols()==other.cols());
        -:  424:      call_assignment(derived(), other.const_cast_derived(), internal::swap_assign_op<Scalar>());
        -:  425:    }
        -:  426:
        -:  427:    /** swaps *this with the matrix or array \a other.
        -:  428:      *
        -:  429:      */
        -:  430:    template<typename OtherDerived>
        -:  431:    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
        -:  432:    void swap(PlainObjectBase<OtherDerived>& other)
        -:  433:    {
        -:  434:      eigen_assert(rows()==other.rows() && cols()==other.cols());
        -:  435:      call_assignment(derived(), other.derived(), internal::swap_assign_op<Scalar>());
        -:  436:    }
        -:  437:
        -:  438:    EIGEN_DEVICE_FUNC inline const NestByValue<Derived> nestByValue() const;
        -:  439:    EIGEN_DEVICE_FUNC inline const ForceAlignedAccess<Derived> forceAlignedAccess() const;
        -:  440:    EIGEN_DEVICE_FUNC inline ForceAlignedAccess<Derived> forceAlignedAccess();
        -:  441:    template<bool Enable> EIGEN_DEVICE_FUNC
        -:  442:    inline const typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf() const;
        -:  443:    template<bool Enable> EIGEN_DEVICE_FUNC
        -:  444:    inline typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf();
        -:  445:
        -:  446:    EIGEN_DEVICE_FUNC Scalar sum() const;
        -:  447:    EIGEN_DEVICE_FUNC Scalar mean() const;
        -:  448:    EIGEN_DEVICE_FUNC Scalar trace() const;
        -:  449:
        -:  450:    EIGEN_DEVICE_FUNC Scalar prod() const;
        -:  451:
        -:  452:    template<int NaNPropagation>
        -:  453:    EIGEN_DEVICE_FUNC typename internal::traits<Derived>::Scalar minCoeff() const;
        -:  454:    template<int NaNPropagation>
        -:  455:    EIGEN_DEVICE_FUNC typename internal::traits<Derived>::Scalar maxCoeff() const;
        -:  456:
        -:  457:
        -:  458:    // By default, the fastest version with undefined NaN propagation semantics is
        -:  459:    // used.
        -:  460:    // TODO(rmlarsen): Replace with default template argument when we move to
        -:  461:    // c++11 or beyond.
        -:  462:    EIGEN_DEVICE_FUNC inline typename internal::traits<Derived>::Scalar minCoeff() const {
        -:  463:      return minCoeff<PropagateFast>();
        -:  464:    }
        -:  465:    EIGEN_DEVICE_FUNC inline typename internal::traits<Derived>::Scalar maxCoeff() const {
        -:  466:      return maxCoeff<PropagateFast>();
        -:  467:    }
        -:  468:
        -:  469:    template<int NaNPropagation, typename IndexType>
        -:  470:    EIGEN_DEVICE_FUNC
        -:  471:    typename internal::traits<Derived>::Scalar minCoeff(IndexType* row, IndexType* col) const;
        -:  472:    template<int NaNPropagation, typename IndexType>
        -:  473:    EIGEN_DEVICE_FUNC
        -:  474:    typename internal::traits<Derived>::Scalar maxCoeff(IndexType* row, IndexType* col) const;
        -:  475:    template<int NaNPropagation, typename IndexType>
        -:  476:    EIGEN_DEVICE_FUNC
        -:  477:    typename internal::traits<Derived>::Scalar minCoeff(IndexType* index) const;
        -:  478:    template<int NaNPropagation, typename IndexType>
        -:  479:    EIGEN_DEVICE_FUNC
        -:  480:    typename internal::traits<Derived>::Scalar maxCoeff(IndexType* index) const;
        -:  481:
        -:  482:    // TODO(rmlarsen): Replace these methods with a default template argument.
        -:  483:    template<typename IndexType>
        -:  484:    EIGEN_DEVICE_FUNC inline
        -:  485:    typename internal::traits<Derived>::Scalar minCoeff(IndexType* row, IndexType* col) const {
        -:  486:      return minCoeff<PropagateFast>(row, col);
        -:  487:    }
        -:  488:    template<typename IndexType>
        -:  489:    EIGEN_DEVICE_FUNC inline
        -:  490:    typename internal::traits<Derived>::Scalar maxCoeff(IndexType* row, IndexType* col) const {
        -:  491:      return maxCoeff<PropagateFast>(row, col);
        -:  492:    }
        -:  493:    template<typename IndexType>
        -:  494:     EIGEN_DEVICE_FUNC inline
        -:  495:    typename internal::traits<Derived>::Scalar minCoeff(IndexType* index) const {
        -:  496:      return minCoeff<PropagateFast>(index);
        -:  497:    }
        -:  498:    template<typename IndexType>
        -:  499:    EIGEN_DEVICE_FUNC inline
        -:  500:    typename internal::traits<Derived>::Scalar maxCoeff(IndexType* index) const {
    #####:  501:      return maxCoeff<PropagateFast>(index);
call    0 never executed
        -:  502:    }
        -:  503:  
        -:  504:    template<typename BinaryOp>
        -:  505:    EIGEN_DEVICE_FUNC
        -:  506:    Scalar redux(const BinaryOp& func) const;
        -:  507:
        -:  508:    template<typename Visitor>
        -:  509:    EIGEN_DEVICE_FUNC
        -:  510:    void visit(Visitor& func) const;
        -:  511:
        -:  512:    /** \returns a WithFormat proxy object allowing to print a matrix the with given
        -:  513:      * format \a fmt.
        -:  514:      *
        -:  515:      * See class IOFormat for some examples.
        -:  516:      *
        -:  517:      * \sa class IOFormat, class WithFormat
        -:  518:      */
        -:  519:    inline const WithFormat<Derived> format(const IOFormat& fmt) const
        -:  520:    {
        -:  521:      return WithFormat<Derived>(derived(), fmt);
        -:  522:    }
        -:  523:
        -:  524:    /** \returns the unique coefficient of a 1x1 expression */
        -:  525:    EIGEN_DEVICE_FUNC
        -:  526:    CoeffReturnType value() const
        -:  527:    {
        -:  528:      EIGEN_STATIC_ASSERT_SIZE_1x1(Derived)
        -:  529:      eigen_assert(this->rows() == 1 && this->cols() == 1);
        -:  530:      return derived().coeff(0,0);
        -:  531:    }
        -:  532:
        -:  533:    EIGEN_DEVICE_FUNC bool all() const;
        -:  534:    EIGEN_DEVICE_FUNC bool any() const;
        -:  535:    EIGEN_DEVICE_FUNC Index count() const;
        -:  536:
        -:  537:    typedef VectorwiseOp<Derived, Horizontal> RowwiseReturnType;
        -:  538:    typedef const VectorwiseOp<const Derived, Horizontal> ConstRowwiseReturnType;
        -:  539:    typedef VectorwiseOp<Derived, Vertical> ColwiseReturnType;
        -:  540:    typedef const VectorwiseOp<const Derived, Vertical> ConstColwiseReturnType;
        -:  541:
        -:  542:    /** \returns a VectorwiseOp wrapper of *this for broadcasting and partial reductions
        -:  543:    *
        -:  544:    * Example: \include MatrixBase_rowwise.cpp
        -:  545:    * Output: \verbinclude MatrixBase_rowwise.out
        -:  546:    *
        -:  547:    * \sa colwise(), class VectorwiseOp, \ref TutorialReductionsVisitorsBroadcasting
        -:  548:    */
        -:  549:    //Code moved here due to a CUDA compiler bug
        -:  550:    EIGEN_DEVICE_FUNC inline ConstRowwiseReturnType rowwise() const {
        -:  551:      return ConstRowwiseReturnType(derived());
        -:  552:    }
        -:  553:    EIGEN_DEVICE_FUNC RowwiseReturnType rowwise();
        -:  554:
        -:  555:    /** \returns a VectorwiseOp wrapper of *this broadcasting and partial reductions
        -:  556:    *
        -:  557:    * Example: \include MatrixBase_colwise.cpp
        -:  558:    * Output: \verbinclude MatrixBase_colwise.out
        -:  559:    *
        -:  560:    * \sa rowwise(), class VectorwiseOp, \ref TutorialReductionsVisitorsBroadcasting
        -:  561:    */
        -:  562:    EIGEN_DEVICE_FUNC inline ConstColwiseReturnType colwise() const {
        -:  563:      return ConstColwiseReturnType(derived());
        -:  564:    }
        -:  565:    EIGEN_DEVICE_FUNC ColwiseReturnType colwise();
        -:  566:
        -:  567:    typedef CwiseNullaryOp<internal::scalar_random_op<Scalar>,PlainObject> RandomReturnType;
        -:  568:    static const RandomReturnType Random(Index rows, Index cols);
        -:  569:    static const RandomReturnType Random(Index size);
        -:  570:    static const RandomReturnType Random();
        -:  571:
        -:  572:    template<typename ThenDerived,typename ElseDerived>
        -:  573:    inline EIGEN_DEVICE_FUNC const Select<Derived,ThenDerived,ElseDerived>
        -:  574:    select(const DenseBase<ThenDerived>& thenMatrix,
        -:  575:           const DenseBase<ElseDerived>& elseMatrix) const;
        -:  576:
        -:  577:    template<typename ThenDerived>
        -:  578:    inline EIGEN_DEVICE_FUNC const Select<Derived,ThenDerived, typename ThenDerived::ConstantReturnType>
        -:  579:    select(const DenseBase<ThenDerived>& thenMatrix, const typename ThenDerived::Scalar& elseScalar) const;
        -:  580:
        -:  581:    template<typename ElseDerived>
        -:  582:    inline EIGEN_DEVICE_FUNC const Select<Derived, typename ElseDerived::ConstantReturnType, ElseDerived >
        -:  583:    select(const typename ElseDerived::Scalar& thenScalar, const DenseBase<ElseDerived>& elseMatrix) const;
        -:  584:
        -:  585:    template<int p> RealScalar lpNorm() const;
        -:  586:
        -:  587:    template<int RowFactor, int ColFactor>
        -:  588:    EIGEN_DEVICE_FUNC
        -:  589:    const Replicate<Derived,RowFactor,ColFactor> replicate() const;
        -:  590:    /**
        -:  591:    * \return an expression of the replication of \c *this
        -:  592:    *
        -:  593:    * Example: \include MatrixBase_replicate_int_int.cpp
        -:  594:    * Output: \verbinclude MatrixBase_replicate_int_int.out
        -:  595:    *
        -:  596:    * \sa VectorwiseOp::replicate(), DenseBase::replicate<int,int>(), class Replicate
        -:  597:    */
        -:  598:    //Code moved here due to a CUDA compiler bug
        -:  599:    EIGEN_DEVICE_FUNC
        -:  600:    const Replicate<Derived, Dynamic, Dynamic> replicate(Index rowFactor, Index colFactor) const
        -:  601:    {
        -:  602:      return Replicate<Derived, Dynamic, Dynamic>(derived(), rowFactor, colFactor);
        -:  603:    }
        -:  604:
        -:  605:    typedef Reverse<Derived, BothDirections> ReverseReturnType;
        -:  606:    typedef const Reverse<const Derived, BothDirections> ConstReverseReturnType;
        -:  607:    EIGEN_DEVICE_FUNC ReverseReturnType reverse();
        -:  608:    /** This is the const version of reverse(). */
        -:  609:    //Code moved here due to a CUDA compiler bug
        -:  610:    EIGEN_DEVICE_FUNC ConstReverseReturnType reverse() const
        -:  611:    {
        -:  612:      return ConstReverseReturnType(derived());
        -:  613:    }
        -:  614:    EIGEN_DEVICE_FUNC void reverseInPlace();
        -:  615:
        -:  616:    #ifdef EIGEN_PARSED_BY_DOXYGEN
        -:  617:    /** STL-like <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">RandomAccessIterator</a>
        -:  618:      * iterator type as returned by the begin() and end() methods.
        -:  619:      */
        -:  620:    typedef random_access_iterator_type iterator;
        -:  621:    /** This is the const version of iterator (aka read-only) */
        -:  622:    typedef random_access_iterator_type const_iterator;
        -:  623:    #else
        -:  624:    typedef typename internal::conditional< (Flags&DirectAccessBit)==DirectAccessBit,
        -:  625:                                            internal::pointer_based_stl_iterator<Derived>,
        -:  626:                                            internal::generic_randaccess_stl_iterator<Derived>
        -:  627:                                          >::type iterator_type;
        -:  628:
        -:  629:    typedef typename internal::conditional< (Flags&DirectAccessBit)==DirectAccessBit,
        -:  630:                                            internal::pointer_based_stl_iterator<const Derived>,
        -:  631:                                            internal::generic_randaccess_stl_iterator<const Derived>
        -:  632:                                          >::type const_iterator_type;
        -:  633:
        -:  634:    // Stl-style iterators are supported only for vectors.
        -:  635:
        -:  636:    typedef typename internal::conditional< IsVectorAtCompileTime,
        -:  637:                                            iterator_type,
        -:  638:                                            void
        -:  639:                                          >::type iterator;
        -:  640:
        -:  641:    typedef typename internal::conditional< IsVectorAtCompileTime,
        -:  642:                                            const_iterator_type,
        -:  643:                                            void
        -:  644:                                          >::type const_iterator;
        -:  645:    #endif
        -:  646:
        -:  647:    inline iterator begin();
        -:  648:    inline const_iterator begin() const;
        -:  649:    inline const_iterator cbegin() const;
        -:  650:    inline iterator end();
        -:  651:    inline const_iterator end() const;
        -:  652:    inline const_iterator cend() const;
        -:  653:
        -:  654:#define EIGEN_CURRENT_STORAGE_BASE_CLASS Eigen::DenseBase
        -:  655:#define EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL
        -:  656:#define EIGEN_DOC_BLOCK_ADDONS_INNER_PANEL_IF(COND)
        -:  657:#define EIGEN_DOC_UNARY_ADDONS(X,Y)
        -:  658:#   include "../plugins/CommonCwiseUnaryOps.h"
        -:  659:#   include "../plugins/BlockMethods.h"
        -:  660:#   include "../plugins/IndexedViewMethods.h"
        -:  661:#   include "../plugins/ReshapedMethods.h"
        -:  662:#   ifdef EIGEN_DENSEBASE_PLUGIN
        -:  663:#     include EIGEN_DENSEBASE_PLUGIN
        -:  664:#   endif
        -:  665:#undef EIGEN_CURRENT_STORAGE_BASE_CLASS
        -:  666:#undef EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL
        -:  667:#undef EIGEN_DOC_BLOCK_ADDONS_INNER_PANEL_IF
        -:  668:#undef EIGEN_DOC_UNARY_ADDONS
        -:  669:
        -:  670:    // disable the use of evalTo for dense objects with a nice compilation error
        -:  671:    template<typename Dest>
        -:  672:    EIGEN_DEVICE_FUNC
        -:  673:    inline void evalTo(Dest& ) const
        -:  674:    {
        -:  675:      EIGEN_STATIC_ASSERT((internal::is_same<Dest,void>::value),THE_EVAL_EVALTO_FUNCTION_SHOULD_NEVER_BE_CALLED_FOR_DENSE_OBJECTS);
        -:  676:    }
        -:  677:
        -:  678:  protected:
        -:  679:    EIGEN_DEFAULT_COPY_CONSTRUCTOR(DenseBase)
        -:  680:    /** Default constructor. Do nothing. */
        -:  681:    EIGEN_DEVICE_FUNC DenseBase()
        -:  682:    {
        -:  683:      /* Just checks for self-consistency of the flags.
        -:  684:       * Only do it when debugging Eigen, as this borders on paranoia and could slow compilation down
        -:  685:       */
        -:  686:#ifdef EIGEN_INTERNAL_DEBUGGING
        -:  687:      EIGEN_STATIC_ASSERT((EIGEN_IMPLIES(MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1, int(IsRowMajor))
        -:  688:                        && EIGEN_IMPLIES(MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1, int(!IsRowMajor))),
        -:  689:                          INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION)
        -:  690:#endif
        -:  691:    }
        -:  692:
        -:  693:  private:
        -:  694:    EIGEN_DEVICE_FUNC explicit DenseBase(int);
        -:  695:    EIGEN_DEVICE_FUNC DenseBase(int,int);
        -:  696:    template<typename OtherDerived> EIGEN_DEVICE_FUNC explicit DenseBase(const DenseBase<OtherDerived>&);
        -:  697:};
        -:  698:
        -:  699:} // end namespace Eigen
        -:  700:
        -:  701:#endif // EIGEN_DENSEBASE_H
